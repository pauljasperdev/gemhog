---
phase: 01-error-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/package.json
  - apps/web/instrumentation.ts
  - apps/web/instrumentation-client.ts
  - apps/web/sentry.server.config.ts
  - apps/web/sentry.edge.config.ts
  - apps/web/next.config.ts
  - apps/web/src/app/global-error.tsx
  - apps/web/src/app/error.tsx
  - apps/web/src/components/section-error-boundary.tsx
  - apps/server/package.json
  - apps/server/src/sentry.ts
  - apps/server/src/index.ts
  - packages/env/src/web.ts
  - packages/env/src/server.ts
  - .env.example
  - infra/secrets.ts
  - infra/web.ts
  - infra/api.ts
autonomous: false
user_setup:
  - service: sentry
    why: "Error monitoring with source map upload"
    env_vars:
      - name: SENTRY_AUTH_TOKEN
        source: "Sentry Dashboard -> Settings -> Auth Tokens -> Create New Token (with project:releases scope)"
    dashboard_config:
      - task: "Configure email alerts for new issues"
        location: "Sentry Dashboard -> Settings -> Alerts -> Create Alert Rule"

must_haves:
  truths:
    - "Frontend errors appear in Sentry dashboard with readable stack traces"
    - "Backend/API errors appear in Sentry dashboard with request context"
    - "Source maps are uploaded during deploy (stack traces show original code)"
    - "Error boundaries display user-friendly fallback UI (production) or stack trace (dev)"
  artifacts:
    - path: "apps/web/instrumentation.ts"
      provides: "Server/edge SDK registration"
      contains: "register"
    - path: "apps/web/instrumentation-client.ts"
      provides: "Client SDK initialization with session ID"
      contains: "Sentry.init"
    - path: "apps/web/sentry.server.config.ts"
      provides: "Server-side Sentry config"
      contains: "Sentry.init"
    - path: "apps/web/sentry.edge.config.ts"
      provides: "Edge runtime Sentry config"
      contains: "Sentry.init"
    - path: "apps/web/next.config.ts"
      provides: "Sentry build integration for source maps"
      contains: "withSentryConfig"
    - path: "apps/web/src/app/global-error.tsx"
      provides: "Root error boundary"
      contains: "Sentry.captureException"
    - path: "apps/web/src/app/error.tsx"
      provides: "App-level error boundary"
      contains: "Sentry.captureException"
    - path: "apps/web/src/components/section-error-boundary.tsx"
      provides: "Reusable section-level error boundary"
      contains: "Sentry.ErrorBoundary"
    - path: "packages/env/src/web.ts"
      provides: "Client env schema with optional Sentry DSN"
      contains: "NEXT_PUBLIC_SENTRY_DSN"
    - path: "packages/env/src/server.ts"
      provides: "Server env schema with optional Sentry vars"
      contains: "SENTRY_DSN"
    - path: ".env.example"
      provides: "Documentation of all env vars including Sentry"
      contains: "SENTRY"
    - path: "apps/server/src/sentry.ts"
      provides: "Sentry initialization and error capture for Hono"
      contains: "Sentry.init"
    - path: "apps/server/src/index.ts"
      provides: "Hono server using sentry module"
      contains: "initSentry"
  key_links:
    - from: "apps/web/instrumentation.ts"
      to: "sentry.server.config.ts"
      via: "dynamic import in register()"
      pattern: "import.*sentry\\.server\\.config"
    - from: "apps/web/next.config.ts"
      to: "SENTRY_AUTH_TOKEN"
      via: "withSentryConfig reads env var for upload"
      pattern: "withSentryConfig"
    - from: "apps/web/src/app/global-error.tsx"
      to: "@sentry/nextjs"
      via: "captureException in useEffect"
      pattern: "Sentry\\.captureException"
    - from: "apps/web/instrumentation-client.ts"
      to: "@gemhog/env/web"
      via: "import env for NEXT_PUBLIC_SENTRY_DSN"
      pattern: "import.*@gemhog/env/web"
    - from: "apps/web/sentry.server.config.ts"
      to: "@gemhog/env/server"
      via: "import env for SENTRY_DSN"
      pattern: "import.*@gemhog/env/server"
---

<objective>
Integrate Sentry error monitoring into the Gemhog Next.js application.

Purpose: Establish error visibility before building more features. Errors from frontend, backend, and edge runtime will be captured and appear in the Sentry dashboard with readable stack traces.

Output: Working Sentry integration with:
- Client-side error capture with session ID tagging
- Server-side error capture with request context
- Edge runtime error capture
- Source map upload during build for readable stack traces
- Error boundaries showing user-friendly UI in production, stack traces in development
</objective>

<execution_context>
@/home/lima/.claude/get-shit-done/workflows/execute-plan.md
@/home/lima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-error-monitoring/01-CONTEXT.md
@.planning/phases/01-error-monitoring/01-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STRUCTURE.md

Sentry project details (from user):
- Org: gemhog
- Project: javascript-nextjs
- DSN: https://b0e726cbc64e580010757cb06aa83a72@o4510769605115904.ingest.de.sentry.io/4510769606295632

Apply React/Next.js best practices from:
@/home/lima/.claude/skills/vercel-react-best-practices/SKILL.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install and configure Sentry SDK</name>
  <files>
    apps/web/package.json
    apps/web/instrumentation.ts
    apps/web/instrumentation-client.ts
    apps/web/sentry.server.config.ts
    apps/web/sentry.edge.config.ts
    apps/web/next.config.ts
    packages/env/src/web.ts
  </files>
  <action>
1. Add @sentry/nextjs to apps/web:
   ```bash
   pnpm add @sentry/nextjs --filter web
   ```

2. Create `apps/web/instrumentation.ts`:
   - Export async `register()` function
   - Conditionally import sentry.server.config.ts for nodejs runtime
   - Conditionally import sentry.edge.config.ts for edge runtime
   - Export `onRequestError = Sentry.captureRequestError`

3. Create `apps/web/instrumentation-client.ts`:
   - Import env from `@gemhog/env/web`
   - **CRITICAL: Add DSN guard to skip initialization when DSN is not configured:**
     ```typescript
     import * as Sentry from "@sentry/nextjs";
     import { env } from "@gemhog/env/web";

     // DSN is optional in env schema - skip Sentry if not configured (local dev)
     if (!env.NEXT_PUBLIC_SENTRY_DSN) {
       // Silent in production, warn in development
       if (process.env.NODE_ENV === "development") {
         console.info("Sentry DSN not configured, skipping client initialization");
       }
     } else {
       Sentry.init({
         dsn: env.NEXT_PUBLIC_SENTRY_DSN,
         // ... rest of config
       });
     }
     ```
   - Only proceed with Sentry.init if DSN exists
   - Initialize Sentry with DSN from `env.NEXT_PUBLIC_SENTRY_DSN`
   - Set environment from `process.env.NODE_ENV`
   - Configure session ID tagging (generate UUID via crypto.randomUUID(), store in sessionStorage)
   - Add session_id tag via `beforeSend` hook
   - Configure sampleRate: 1.0 (capture all errors)
   - Configure tracesSampleRate: 1.0 in dev, 0.1 in production
   - Configure replaysSessionSampleRate: 0, replaysOnErrorSampleRate: 0 (free tier)
   - Add ignoreErrors patterns from RESEARCH.md (ResizeObserver, ChunkLoadError, etc.)
   - Add denyUrls for browser extensions (chrome-extension://, moz-extension://, etc.)
   - Enable breadcrumbs integration (console, dom, fetch, history)

4. Create `apps/web/sentry.server.config.ts`:
   - Import env from `@gemhog/env/server`
   - **CRITICAL: Add DSN guard to skip initialization when DSN is not configured:**
     ```typescript
     import * as Sentry from "@sentry/nextjs";
     import { env } from "@gemhog/env/server";

     // DSN is optional - skip Sentry if not configured (local dev)
     if (!env.SENTRY_DSN) {
       if (process.env.NODE_ENV === "development") {
         console.info("Sentry DSN not configured, skipping server initialization");
       }
     } else {
       Sentry.init({
         dsn: env.SENTRY_DSN,
         // ... rest of config
       });
     }
     ```
   - Only proceed with Sentry.init if DSN exists
   - Initialize Sentry with DSN from `env.SENTRY_DSN`
   - Set environment from `process.env.NODE_ENV`
   - Configure tracesSampleRate: 1.0 in dev, 0.1 in production
   - Add ignoreErrors for expected server errors (ECONNREFUSED, ENOTFOUND)

5. Create `apps/web/sentry.edge.config.ts`:
   - **Note: Edge runtime has limited module support, use process.env directly**
   - **CRITICAL: Add DSN guard to skip initialization when DSN is not configured:**
     ```typescript
     import * as Sentry from "@sentry/nextjs";

     // DSN is optional - skip Sentry if not configured (local dev)
     // Edge runtime: use process.env directly (env package may have import issues)
     const dsn = process.env.SENTRY_DSN;
     if (!dsn) {
       if (process.env.NODE_ENV === "development") {
         console.info("Sentry DSN not configured, skipping edge initialization");
       }
     } else {
       Sentry.init({
         dsn,
         environment: process.env.NODE_ENV,
         tracesSampleRate: process.env.NODE_ENV === "development" ? 1.0 : 0.1,
       });
     }
     ```
   - Only proceed with Sentry.init if DSN exists
   - Simpler config (edge has fewer features)

6. Update `apps/web/next.config.ts`:
   - Import withSentryConfig from @sentry/nextjs
   - Wrap nextConfig with withSentryConfig
   - Configure: org, project, authToken (from env vars)
   - Set tunnelRoute: "/monitoring" to avoid ad blockers
   - Set silent: !process.env.CI (verbose in CI only)
   - Configure sourcemaps.deleteSourcemapsAfterUpload: true

7. Update `packages/env/src/web.ts`:
   - Add NEXT_PUBLIC_SENTRY_DSN to client env schema as **optional string**:
     ```typescript
     client: {
       NEXT_PUBLIC_SERVER_URL: z.url(),
       NEXT_PUBLIC_SENTRY_DSN: z.string().optional(),
     },
     runtimeEnv: {
       NEXT_PUBLIC_SERVER_URL: process.env.NEXT_PUBLIC_SERVER_URL,
       NEXT_PUBLIC_SENTRY_DSN: process.env.NEXT_PUBLIC_SENTRY_DSN,
     },
     ```
   - This ensures builds succeed without Sentry configured (for tests and local dev)

8. Update `packages/env/src/server.ts`:
   - Add server-side Sentry env vars as **optional strings**:
     ```typescript
     server: {
       // ... existing vars ...
       SENTRY_DSN: z.string().optional(),
       SENTRY_AUTH_TOKEN: z.string().optional(),
       SENTRY_ORG: z.string().optional(),
       SENTRY_PROJECT: z.string().optional(),
     },
     ```
   - All Sentry vars are optional because Sentry only runs in production (not local dev)

9. Update `.env.example`:
   - Add all Sentry-related env vars with comments:
     ```bash
     # Sentry Error Monitoring (optional - only needed for production)
     # Get DSN from: Sentry Dashboard -> Project Settings -> Client Keys
     NEXT_PUBLIC_SENTRY_DSN=
     SENTRY_DSN=
     # Get auth token from: Sentry Dashboard -> Settings -> Auth Tokens
     SENTRY_AUTH_TOKEN=
     SENTRY_ORG=gemhog
     SENTRY_PROJECT=javascript-nextjs
     ```
   - These are optional for local dev (app runs without Sentry)

10. Summary of DSN guards (already covered in steps 3-5):
   - `instrumentation-client.ts`: Uses `env.NEXT_PUBLIC_SENTRY_DSN` from `@gemhog/env/web`
   - `sentry.server.config.ts`: Uses `env.SENTRY_DSN` from `@gemhog/env/server`
   - `sentry.edge.config.ts`: Uses `process.env.SENTRY_DSN` directly (edge runtime limitation)
   - All vars are optional in env schemas, so validation passes when not set
   - This ensures Next.js build succeeds without SENTRY_DSN set (critical for startup.int.test.ts and local dev)
  </action>
  <verify>
- `pnpm check-types` passes (no TypeScript errors)
- Files exist: instrumentation.ts, instrumentation-client.ts, sentry.server.config.ts, sentry.edge.config.ts
- next.config.ts exports withSentryConfig wrapped config
- Build succeeds without SENTRY_DSN set: `pnpm test:unit` passes (includes startup.int.test.ts)
  </verify>
  <done>
Sentry SDK installed and configured. Client, server, and edge configs ready with DSN guards to skip initialization when not configured. Next.js build will upload source maps when SENTRY_AUTH_TOKEN is set. Build succeeds without Sentry env vars for tests and local dev.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create error boundaries</name>
  <files>
    apps/web/src/app/global-error.tsx
    apps/web/src/app/error.tsx
    apps/web/src/components/section-error-boundary.tsx
  </files>
  <action>
1. Create `apps/web/src/app/global-error.tsx`:
   - "use client" directive
   - Import Sentry from @sentry/nextjs
   - Export default function GlobalError({ error, reset })
   - useEffect to call Sentry.captureException(error) on mount
   - Return full html/body structure (required for global-error)
   - Production: Show minimal "Something went wrong" with retry button
   - Development: Additionally show error.message and error.stack in a pre tag
   - Use NODE_ENV check for conditional display

2. Create `apps/web/src/app/error.tsx`:
   - "use client" directive
   - Import Sentry from @sentry/nextjs
   - Export default function Error({ error, reset })
   - useEffect to call Sentry.captureException(error, { tags: { route: 'app' } })
   - Production: Show minimal "Something went wrong" with retry button
   - Development: Show error details
   - Style with Tailwind classes

3. Create `apps/web/src/components/section-error-boundary.tsx`:
   - "use client" directive
   - Import Sentry from @sentry/nextjs
   - Create SectionErrorBoundary component with props: children, section (optional string), fallback (optional ReactNode)
   - Use Sentry.ErrorBoundary component
   - Configure beforeCapture to add section tag if provided
   - Default fallback: minimal error UI with retry button
   - In dev mode: show error.message and stack in pre tag
   - Export the component

Follow React best practices (from /vercel-react-best-practices):
- Use primitive dependencies in useEffect (error object reference)
- Keep error boundary components minimal and focused
  </action>
  <verify>
- `pnpm check-types` passes
- All three files exist with "use client" directive
- Each file imports @sentry/nextjs and calls captureException
  </verify>
  <done>
Error boundaries created: global-error.tsx for root errors, error.tsx for app-level, section-error-boundary.tsx for reusable section-level boundaries. All boundaries report to Sentry and show appropriate UI based on environment.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Sentry secrets to SST infrastructure</name>
  <files>
    infra/secrets.ts
    infra/web.ts
    infra/api.ts
  </files>
  <action>
1. Update `infra/secrets.ts`:
   - Add SentryDsn secret: `export const SentryDsn = new sst.Secret("SentryDsn");`
   - Add SentryAuthToken secret: `export const SentryAuthToken = new sst.Secret("SentryAuthToken");`
   - Add SentryOrg secret: `export const SentryOrg = new sst.Secret("SentryOrg");`
   - Add SentryProject secret: `export const SentryProject = new sst.Secret("SentryProject");`

2. Update `infra/web.ts`:
   - Import new Sentry secrets from ./secrets
   - Add to environment object:
     - NEXT_PUBLIC_SENTRY_DSN: SentryDsn.value
     - SENTRY_DSN: SentryDsn.value
     - SENTRY_AUTH_TOKEN: SentryAuthToken.value
     - SENTRY_ORG: SentryOrg.value
     - SENTRY_PROJECT: SentryProject.value

3. Update `infra/api.ts`:
   - Import SentryDsn from ./secrets
   - Add to Hono Lambda environment: SENTRY_DSN: SentryDsn.value

Note: The user will need to set these secrets via `sst secret set` after deployment config is updated. Source map upload requires SENTRY_AUTH_TOKEN during build, which SST handles by injecting env vars at build time.
  </action>
  <verify>
- `pnpm check-types` passes (infra files may not be type-checked in main config, verify no syntax errors)
- infra/secrets.ts contains SentryDsn, SentryAuthToken, SentryOrg, SentryProject exports
- infra/web.ts references all Sentry secrets in environment block
- infra/api.ts references SentryDsn in environment block
  </verify>
  <done>
SST infrastructure updated with Sentry secrets. Both Next.js (web) and Hono (api) will have access to Sentry DSN when deployed.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add Sentry to Hono server (apps/server)</name>
  <files>
    apps/server/package.json
    apps/server/src/sentry.ts
    apps/server/src/index.ts
  </files>
  <action>
**Important:** The project has two backends:
- `apps/web` — Next.js (covered in Task 1)
- `apps/server` — Hono server (this task)

MNTR-02 (backend/API errors) requires both to have Sentry.

1. Add @sentry/node to apps/server:
   ```bash
   pnpm add @sentry/node --filter server
   ```

2. Create `apps/server/src/sentry.ts` (keeps index.ts clean):
   ```typescript
   import * as Sentry from "@sentry/node";
   import type { Context } from "hono";
   import { env } from "@gemhog/env/server";

   /**
    * Initialize Sentry for the Hono server.
    * Call this at app startup, before routes are registered.
    * Gracefully skips if SENTRY_DSN is not configured (local dev).
    */
   export function initSentry() {
     if (!env.SENTRY_DSN) {
       if (env.NODE_ENV === "development") {
         console.info("Sentry DSN not configured, skipping server initialization");
       }
       return;
     }

     Sentry.init({
       dsn: env.SENTRY_DSN,
       environment: env.NODE_ENV,
       tracesSampleRate: env.NODE_ENV === "development" ? 1.0 : 0.1,
     });
   }

   /**
    * Capture an exception to Sentry with request context.
    * Use in Hono's onError handler.
    */
   export function captureError(err: Error, c: Context) {
     if (!env.SENTRY_DSN) return;

     Sentry.captureException(err, {
       extra: {
         url: c.req.url,
         method: c.req.method,
         path: c.req.path,
       },
     });
   }

   export { Sentry };
   ```

3. Update `apps/server/src/index.ts`:
   - Import sentry utilities at the top:
     ```typescript
     import { initSentry, captureError } from "./sentry";
     ```
   - Call `initSentry()` BEFORE creating the Hono app
   - Add error handler using `captureError`:
     ```typescript
     // Error handling (after all routes)
     app.onError((err, c) => {
       captureError(err, c);
       console.error(err);
       return c.json({ error: "Internal Server Error" }, 500);
     });
     ```

4. Verify Hono server still starts locally without SENTRY_DSN:
   - `pnpm dev:server` should work without errors
   - Console should show "Sentry DSN not configured" in dev mode only
  </action>
  <verify>
- `pnpm check-types` passes
- `pnpm dev:server` starts without SENTRY_DSN set
- apps/server/src/sentry.ts exists with initSentry and captureError exports
- apps/server/src/index.ts imports from ./sentry (not @sentry/node directly)
- Error handler registered after routes
  </verify>
  <done>
Hono server now captures errors to Sentry via dedicated sentry.ts module. Index.ts stays clean with just imports and function calls.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Sentry integration: Next.js SDK, Hono middleware, error boundaries, and SST secrets.</what-built>
  <how-to-verify>
**Frontend verification (apps/web):**

1. Start local dev server:
   ```bash
   pnpm dev:web
   ```

2. Create a test error component temporarily:
   - Add a button that throws: `throw new Error("Test Sentry error")`
   - Or add `throw new Error("Test")` in a useEffect

3. Trigger the error and verify:
   - Error boundary catches it and shows fallback UI
   - In dev mode, you should see the stack trace
   - Check browser console for Sentry initialization

**Backend verification (apps/server):**

4. Start Hono server:
   ```bash
   pnpm dev:server
   ```

5. Verify server starts without SENTRY_DSN (no errors)

6. (Optional) Trigger a server error and verify it's logged

**With Sentry configured (optional for local):**

7. If you have SENTRY_DSN set in .env.local:
   - Trigger frontend error → verify in Sentry dashboard with session_id tag
   - Trigger backend error → verify in Sentry dashboard with request context

**Production verification after deploy:**

8. Set SST secrets: `sst secret set SentryDsn "your-dsn"`
9. Deploy and trigger test errors (frontend + backend)
10. Verify source maps show readable stack traces in Sentry

Note: Full production verification requires deployment. This checkpoint validates the local integration works.
  </how-to-verify>
  <resume-signal>Type "approved" if error boundaries work locally, or describe any issues.</resume-signal>
</task>

</tasks>

<verification>
**After each task (use `pnpm verify:commit`):**
- Lint passes: `pnpm check`
- Type checking passes: `pnpm check-types`
- Unit tests pass: `pnpm test:unit`

**Before marking plan complete (use `pnpm verify`):**
1. Full verification pipeline: `pnpm verify`
2. Security review: Check `.planning/codebase/SECURITY-REVIEW.md`
3. Dev servers start without errors:
   - `pnpm dev:web` (no SENTRY_DSN needed)
   - `pnpm dev:server` (no SENTRY_DSN needed)

**Local dev verification (without Sentry):**
- Start both dev servers: `pnpm dev`
- Frontend: Verify console shows "Sentry DSN not configured, skipping initialization"
- Backend: Verify server starts without Sentry warnings
- Trigger test errors in browser and API
- Error boundaries display fallback UI

**Production verification (with Sentry):**
- Set SENTRY_DSN and NEXT_PUBLIC_SENTRY_DSN in .env.local
- Restart dev servers
- Trigger frontend error → appears in Sentry with session_id tag
- Trigger backend error → appears in Sentry with request context
</verification>

<success_criteria>
**Next.js (apps/web):**
1. @sentry/nextjs installed in apps/web
2. Client SDK initializes with session ID tagging and filtering (when DSN configured)
3. Server SDK initializes for nodejs and edge runtimes (when DSN configured)
4. next.config.ts wrapped with withSentryConfig for source map upload
5. global-error.tsx catches root layout errors
6. error.tsx catches app-level errors
7. SectionErrorBoundary component available for section-level use

**Hono Server (apps/server):**
8. @sentry/node installed in apps/server
9. Sentry middleware captures errors with request context
10. Server starts without SENTRY_DSN (graceful skip)

**Infrastructure:**
11. SST secrets configured for Sentry credentials (web + api)
12. Env package updated: SENTRY vars optional in both web.ts and server.ts
13. .env.example documents all Sentry vars

**Verification:**
14. Both apps run locally without Sentry (`pnpm dev` works without SENTRY_DSN)
15. `pnpm verify` passes (full pipeline including integration + E2E)
</success_criteria>

<output>
After completion, create `.planning/phases/01-error-monitoring/01-01-SUMMARY.md`
</output>
