---
phase: 01-error-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/package.json
  - apps/web/instrumentation.ts
  - apps/web/instrumentation-client.ts
  - apps/web/sentry.server.config.ts
  - apps/web/sentry.edge.config.ts
  - apps/web/next.config.ts
  - apps/web/src/app/global-error.tsx
  - apps/web/src/app/error.tsx
  - apps/web/src/components/section-error-boundary.tsx
  - packages/env/src/web.ts
  - packages/env/src/server.ts
  - .env.example
  - infra/secrets.ts
  - infra/web.ts
autonomous: false
user_setup:
  - service: sentry
    why: "Error monitoring with source map upload"
    env_vars:
      - name: SENTRY_AUTH_TOKEN
        source: "Sentry Dashboard -> Settings -> Auth Tokens -> Create New Token (with project:releases scope)"
    dashboard_config:
      - task: "Configure email alerts for new issues"
        location: "Sentry Dashboard -> Settings -> Alerts -> Create Alert Rule"

must_haves:
  truths:
    - "Frontend errors appear in Sentry dashboard with readable stack traces"
    - "Backend/API errors appear in Sentry dashboard with request context"
    - "Source maps are uploaded during deploy (stack traces show original code)"
    - "Error boundaries display user-friendly fallback UI (production) or stack trace (dev)"
  artifacts:
    - path: "apps/web/instrumentation.ts"
      provides: "Server/edge SDK registration"
      contains: "register"
    - path: "apps/web/instrumentation-client.ts"
      provides: "Client SDK initialization with session ID"
      contains: "Sentry.init"
    - path: "apps/web/sentry.server.config.ts"
      provides: "Server-side Sentry config"
      contains: "Sentry.init"
    - path: "apps/web/sentry.edge.config.ts"
      provides: "Edge runtime Sentry config"
      contains: "Sentry.init"
    - path: "apps/web/next.config.ts"
      provides: "Sentry build integration for source maps"
      contains: "withSentryConfig"
    - path: "apps/web/src/app/global-error.tsx"
      provides: "Root error boundary"
      contains: "Sentry.captureException"
    - path: "apps/web/src/app/error.tsx"
      provides: "App-level error boundary"
      contains: "Sentry.captureException"
    - path: "apps/web/src/components/section-error-boundary.tsx"
      provides: "Reusable section-level error boundary"
      contains: "Sentry.ErrorBoundary"
    - path: "packages/env/src/web.ts"
      provides: "Client env schema with optional Sentry DSN"
      contains: "NEXT_PUBLIC_SENTRY_DSN"
    - path: "packages/env/src/server.ts"
      provides: "Server env schema with optional Sentry vars"
      contains: "SENTRY_DSN"
    - path: ".env.example"
      provides: "Documentation of all env vars including Sentry"
      contains: "SENTRY"
  key_links:
    - from: "apps/web/instrumentation.ts"
      to: "sentry.server.config.ts"
      via: "dynamic import in register()"
      pattern: "import.*sentry\\.server\\.config"
    - from: "apps/web/next.config.ts"
      to: "SENTRY_AUTH_TOKEN"
      via: "withSentryConfig reads env var for upload"
      pattern: "withSentryConfig"
    - from: "apps/web/src/app/global-error.tsx"
      to: "@sentry/nextjs"
      via: "captureException in useEffect"
      pattern: "Sentry\\.captureException"
    - from: "apps/web/instrumentation-client.ts"
      to: "@gemhog/env/web"
      via: "import env for NEXT_PUBLIC_SENTRY_DSN"
      pattern: "import.*@gemhog/env/web"
    - from: "apps/web/sentry.server.config.ts"
      to: "@gemhog/env/server"
      via: "import env for SENTRY_DSN"
      pattern: "import.*@gemhog/env/server"
---

<objective>
Integrate Sentry error monitoring into the Gemhog Next.js application.

Purpose: Establish error visibility before building more features. Errors from frontend, backend, and edge runtime will be captured and appear in the Sentry dashboard with readable stack traces.

Output: Working Sentry integration with:
- Client-side error capture with session ID tagging
- Server-side error capture with request context
- Edge runtime error capture
- Source map upload during build for readable stack traces
- Error boundaries showing user-friendly UI in production, stack traces in development
</objective>

<execution_context>
@/home/lima/.claude/get-shit-done/workflows/execute-plan.md
@/home/lima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-error-monitoring/01-CONTEXT.md
@.planning/phases/01-error-monitoring/01-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STRUCTURE.md

Sentry project details (from user):
- Org: gemhog
- Project: javascript-nextjs
- DSN: https://b0e726cbc64e580010757cb06aa83a72@o4510769605115904.ingest.de.sentry.io/4510769606295632

Apply React/Next.js best practices from:
@/home/lima/.claude/skills/vercel-react-best-practices/SKILL.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install and configure Sentry SDK</name>
  <files>
    apps/web/package.json
    apps/web/instrumentation.ts
    apps/web/instrumentation-client.ts
    apps/web/sentry.server.config.ts
    apps/web/sentry.edge.config.ts
    apps/web/next.config.ts
    packages/env/src/web.ts
  </files>
  <action>
1. Add @sentry/nextjs to apps/web:
   ```bash
   pnpm add @sentry/nextjs --filter web
   ```

2. Create `apps/web/instrumentation.ts`:
   - Export async `register()` function
   - Conditionally import sentry.server.config.ts for nodejs runtime
   - Conditionally import sentry.edge.config.ts for edge runtime
   - Export `onRequestError = Sentry.captureRequestError`

3. Create `apps/web/instrumentation-client.ts`:
   - Import env from `@gemhog/env/web`
   - **CRITICAL: Add DSN guard to skip initialization when DSN is not configured:**
     ```typescript
     import * as Sentry from "@sentry/nextjs";
     import { env } from "@gemhog/env/web";

     // DSN is optional in env schema - skip Sentry if not configured (local dev)
     if (!env.NEXT_PUBLIC_SENTRY_DSN) {
       // Silent in production, warn in development
       if (process.env.NODE_ENV === "development") {
         console.info("Sentry DSN not configured, skipping client initialization");
       }
     } else {
       Sentry.init({
         dsn: env.NEXT_PUBLIC_SENTRY_DSN,
         // ... rest of config
       });
     }
     ```
   - Only proceed with Sentry.init if DSN exists
   - Initialize Sentry with DSN from `env.NEXT_PUBLIC_SENTRY_DSN`
   - Set environment from `process.env.NODE_ENV`
   - Configure session ID tagging (generate UUID via crypto.randomUUID(), store in sessionStorage)
   - Add session_id tag via `beforeSend` hook
   - Configure sampleRate: 1.0 (capture all errors)
   - Configure tracesSampleRate: 1.0 in dev, 0.1 in production
   - Configure replaysSessionSampleRate: 0, replaysOnErrorSampleRate: 0 (free tier)
   - Add ignoreErrors patterns from RESEARCH.md (ResizeObserver, ChunkLoadError, etc.)
   - Add denyUrls for browser extensions (chrome-extension://, moz-extension://, etc.)
   - Enable breadcrumbs integration (console, dom, fetch, history)

4. Create `apps/web/sentry.server.config.ts`:
   - Import env from `@gemhog/env/server`
   - **CRITICAL: Add DSN guard to skip initialization when DSN is not configured:**
     ```typescript
     import * as Sentry from "@sentry/nextjs";
     import { env } from "@gemhog/env/server";

     // DSN is optional - skip Sentry if not configured (local dev)
     if (!env.SENTRY_DSN) {
       if (process.env.NODE_ENV === "development") {
         console.info("Sentry DSN not configured, skipping server initialization");
       }
     } else {
       Sentry.init({
         dsn: env.SENTRY_DSN,
         // ... rest of config
       });
     }
     ```
   - Only proceed with Sentry.init if DSN exists
   - Initialize Sentry with DSN from `env.SENTRY_DSN`
   - Set environment from `process.env.NODE_ENV`
   - Configure tracesSampleRate: 1.0 in dev, 0.1 in production
   - Add ignoreErrors for expected server errors (ECONNREFUSED, ENOTFOUND)

5. Create `apps/web/sentry.edge.config.ts`:
   - **Note: Edge runtime has limited module support, use process.env directly**
   - **CRITICAL: Add DSN guard to skip initialization when DSN is not configured:**
     ```typescript
     import * as Sentry from "@sentry/nextjs";

     // DSN is optional - skip Sentry if not configured (local dev)
     // Edge runtime: use process.env directly (env package may have import issues)
     const dsn = process.env.SENTRY_DSN;
     if (!dsn) {
       if (process.env.NODE_ENV === "development") {
         console.info("Sentry DSN not configured, skipping edge initialization");
       }
     } else {
       Sentry.init({
         dsn,
         environment: process.env.NODE_ENV,
         tracesSampleRate: process.env.NODE_ENV === "development" ? 1.0 : 0.1,
       });
     }
     ```
   - Only proceed with Sentry.init if DSN exists
   - Simpler config (edge has fewer features)

6. Update `apps/web/next.config.ts`:
   - Import withSentryConfig from @sentry/nextjs
   - Wrap nextConfig with withSentryConfig
   - Configure: org, project, authToken (from env vars)
   - Set tunnelRoute: "/monitoring" to avoid ad blockers
   - Set silent: !process.env.CI (verbose in CI only)
   - Configure sourcemaps.deleteSourcemapsAfterUpload: true

7. Update `packages/env/src/web.ts`:
   - Add NEXT_PUBLIC_SENTRY_DSN to client env schema as **optional string**:
     ```typescript
     client: {
       NEXT_PUBLIC_SERVER_URL: z.url(),
       NEXT_PUBLIC_SENTRY_DSN: z.string().optional(),
     },
     runtimeEnv: {
       NEXT_PUBLIC_SERVER_URL: process.env.NEXT_PUBLIC_SERVER_URL,
       NEXT_PUBLIC_SENTRY_DSN: process.env.NEXT_PUBLIC_SENTRY_DSN,
     },
     ```
   - This ensures builds succeed without Sentry configured (for tests and local dev)

8. Update `packages/env/src/server.ts`:
   - Add server-side Sentry env vars as **optional strings**:
     ```typescript
     server: {
       // ... existing vars ...
       SENTRY_DSN: z.string().optional(),
       SENTRY_AUTH_TOKEN: z.string().optional(),
       SENTRY_ORG: z.string().optional(),
       SENTRY_PROJECT: z.string().optional(),
     },
     ```
   - All Sentry vars are optional because Sentry only runs in production (not local dev)

9. Update `.env.example`:
   - Add all Sentry-related env vars with comments:
     ```bash
     # Sentry Error Monitoring (optional - only needed for production)
     # Get DSN from: Sentry Dashboard -> Project Settings -> Client Keys
     NEXT_PUBLIC_SENTRY_DSN=
     SENTRY_DSN=
     # Get auth token from: Sentry Dashboard -> Settings -> Auth Tokens
     SENTRY_AUTH_TOKEN=
     SENTRY_ORG=gemhog
     SENTRY_PROJECT=javascript-nextjs
     ```
   - These are optional for local dev (app runs without Sentry)

10. Summary of DSN guards (already covered in steps 3-5):
   - `instrumentation-client.ts`: Uses `env.NEXT_PUBLIC_SENTRY_DSN` from `@gemhog/env/web`
   - `sentry.server.config.ts`: Uses `env.SENTRY_DSN` from `@gemhog/env/server`
   - `sentry.edge.config.ts`: Uses `process.env.SENTRY_DSN` directly (edge runtime limitation)
   - All vars are optional in env schemas, so validation passes when not set
   - This ensures Next.js build succeeds without SENTRY_DSN set (critical for startup.int.test.ts and local dev)
  </action>
  <verify>
- `pnpm check-types` passes (no TypeScript errors)
- Files exist: instrumentation.ts, instrumentation-client.ts, sentry.server.config.ts, sentry.edge.config.ts
- next.config.ts exports withSentryConfig wrapped config
- Build succeeds without SENTRY_DSN set: `pnpm test:unit` passes (includes startup.int.test.ts)
  </verify>
  <done>
Sentry SDK installed and configured. Client, server, and edge configs ready with DSN guards to skip initialization when not configured. Next.js build will upload source maps when SENTRY_AUTH_TOKEN is set. Build succeeds without Sentry env vars for tests and local dev.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create error boundaries</name>
  <files>
    apps/web/src/app/global-error.tsx
    apps/web/src/app/error.tsx
    apps/web/src/components/section-error-boundary.tsx
  </files>
  <action>
1. Create `apps/web/src/app/global-error.tsx`:
   - "use client" directive
   - Import Sentry from @sentry/nextjs
   - Export default function GlobalError({ error, reset })
   - useEffect to call Sentry.captureException(error) on mount
   - Return full html/body structure (required for global-error)
   - Production: Show minimal "Something went wrong" with retry button
   - Development: Additionally show error.message and error.stack in a pre tag
   - Use NODE_ENV check for conditional display

2. Create `apps/web/src/app/error.tsx`:
   - "use client" directive
   - Import Sentry from @sentry/nextjs
   - Export default function Error({ error, reset })
   - useEffect to call Sentry.captureException(error, { tags: { route: 'app' } })
   - Production: Show minimal "Something went wrong" with retry button
   - Development: Show error details
   - Style with Tailwind classes

3. Create `apps/web/src/components/section-error-boundary.tsx`:
   - "use client" directive
   - Import Sentry from @sentry/nextjs
   - Create SectionErrorBoundary component with props: children, section (optional string), fallback (optional ReactNode)
   - Use Sentry.ErrorBoundary component
   - Configure beforeCapture to add section tag if provided
   - Default fallback: minimal error UI with retry button
   - In dev mode: show error.message and stack in pre tag
   - Export the component

Follow React best practices (from /vercel-react-best-practices):
- Use primitive dependencies in useEffect (error object reference)
- Keep error boundary components minimal and focused
  </action>
  <verify>
- `pnpm check-types` passes
- All three files exist with "use client" directive
- Each file imports @sentry/nextjs and calls captureException
  </verify>
  <done>
Error boundaries created: global-error.tsx for root errors, error.tsx for app-level, section-error-boundary.tsx for reusable section-level boundaries. All boundaries report to Sentry and show appropriate UI based on environment.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Sentry secrets to SST infrastructure</name>
  <files>
    infra/secrets.ts
    infra/web.ts
  </files>
  <action>
1. Update `infra/secrets.ts`:
   - Add SentryDsn secret: `export const SentryDsn = new sst.Secret("SentryDsn");`
   - Add SentryAuthToken secret: `export const SentryAuthToken = new sst.Secret("SentryAuthToken");`
   - Add SentryOrg secret: `export const SentryOrg = new sst.Secret("SentryOrg");`
   - Add SentryProject secret: `export const SentryProject = new sst.Secret("SentryProject");`

2. Update `infra/web.ts`:
   - Import new Sentry secrets from ./secrets
   - Add to environment object:
     - NEXT_PUBLIC_SENTRY_DSN: SentryDsn.value
     - SENTRY_DSN: SentryDsn.value
     - SENTRY_AUTH_TOKEN: SentryAuthToken.value
     - SENTRY_ORG: SentryOrg.value
     - SENTRY_PROJECT: SentryProject.value

Note: The user will need to set these secrets via `sst secret set` after deployment config is updated. Source map upload requires SENTRY_AUTH_TOKEN during build, which SST handles by injecting env vars at build time.
  </action>
  <verify>
- `pnpm check-types` passes (infra files may not be type-checked in main config, verify no syntax errors)
- infra/secrets.ts contains SentryDsn, SentryAuthToken, SentryOrg, SentryProject exports
- infra/web.ts references all Sentry secrets in environment block
  </verify>
  <done>
SST infrastructure updated with Sentry secrets. When deployed, the Next.js build will have access to Sentry credentials for source map upload.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Sentry integration: SDK configuration, error boundaries, and SST secrets.</what-built>
  <how-to-verify>
1. Start local dev server:
   ```bash
   pnpm dev:web
   ```

2. Create a test error component temporarily:
   - Add a button that throws: `throw new Error("Test Sentry error")`
   - Or add `throw new Error("Test")` in a useEffect

3. Trigger the error and verify:
   - Error boundary catches it and shows fallback UI
   - In dev mode, you should see the stack trace
   - Check browser console for Sentry initialization

4. (Optional) If you have NEXT_PUBLIC_SENTRY_DSN set in .env.local:
   - Trigger error
   - Check Sentry dashboard (https://sentry.io) for the error event
   - Verify session_id tag appears on the event

5. For production verification after deploy:
   - Set SST secrets: `sst secret set SentryDsn "your-dsn"`
   - Deploy and trigger a test error
   - Verify source maps show readable stack traces in Sentry

Note: Full production verification requires deployment. This checkpoint validates the local integration works.
  </how-to-verify>
  <resume-signal>Type "approved" if error boundaries work locally, or describe any issues.</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. Type checking passes: `pnpm check-types`
2. Lint passes: `pnpm check`
3. Unit tests pass: `pnpm test:unit`
4. Dev server starts without errors: `pnpm dev:web` (no SENTRY_DSN needed)

Local dev verification (without Sentry):
- Start dev server: `pnpm dev:web`
- Verify console shows "Sentry DSN not configured, skipping initialization"
- Trigger a test error in the browser
- Error boundary displays fallback UI (Sentry not involved)

Production verification (with Sentry):
- Set NEXT_PUBLIC_SENTRY_DSN in .env.local
- Restart dev server
- Trigger a test error
- Error appears in Sentry dashboard with session_id tag
</verification>

<success_criteria>
1. @sentry/nextjs installed in apps/web
2. Client SDK initializes with session ID tagging and filtering (when DSN configured)
3. Server SDK initializes for nodejs and edge runtimes (when DSN configured)
4. next.config.ts wrapped with withSentryConfig for source map upload
5. global-error.tsx catches root layout errors
6. error.tsx catches app-level errors
7. SectionErrorBoundary component available for section-level use
8. SST secrets configured for Sentry credentials
9. Env package updated: SENTRY vars optional in both web.ts and server.ts
10. .env.example documents all Sentry vars
11. App runs locally without Sentry (`pnpm dev:web` works without SENTRY_DSN)
12. `pnpm verify:commit` passes (check + types + unit tests)
</success_criteria>

<output>
After completion, create `.planning/phases/01-error-monitoring/01-01-SUMMARY.md`
</output>
