---
phase: 01-testing-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/vitest.config.ts
  - packages/db/test/global-setup.ts
  - packages/db/src/users.test.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Integration tests auto-start Docker container if not running"
    - "Integration tests wait for PostgreSQL to be healthy before running"
    - "Integration tests can run against local Postgres Docker container"
    - "Integration tests can run against Test-stage AWS via env vars"
  artifacts:
    - path: "packages/db/vitest.config.ts"
      provides: "DB package test config with globalSetup"
      contains: "globalSetup"
    - path: "packages/db/test/global-setup.ts"
      provides: "Docker auto-start and healthcheck logic"
      contains: "docker compose"
    - path: "packages/db/src/users.test.ts"
      provides: "Example integration test"
      contains: "describe"
  key_links:
    - from: "packages/db/vitest.config.ts"
      to: "packages/db/test/global-setup.ts"
      via: "globalSetup option"
      pattern: "globalSetup.*global-setup"
    - from: "packages/db/test/global-setup.ts"
      to: "docker-compose.yml"
      via: "execSync docker compose"
      pattern: "docker compose up"
---

<objective>
Set up integration testing with Docker auto-start for packages/db

Purpose: Enable database integration tests that automatically ensure PostgreSQL is running, either via local Docker or Test-stage AWS resources (via env vars).

Output: Working `pnpm test:integration` command that auto-starts Docker when needed
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-testing-infrastructure/01-CONTEXT.md
@.planning/phases/01-testing-infrastructure/01-RESEARCH.md

# Existing configs
@packages/db/package.json
@packages/db/docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create globalSetup for Docker auto-start</name>
  <files>
    - packages/db/test/global-setup.ts
  </files>
  <action>
Create `packages/db/test/global-setup.ts` that:
1. Checks if running against external database (via DATABASE_URL env var pointing to non-localhost)
2. If external, skip Docker setup entirely
3. If local, check if gemhog-postgres container is running
4. If not running, start it with `docker compose up -d`
5. Wait for PostgreSQL to accept connections via `pg_isready`

```typescript
// packages/db/test/global-setup.ts
import { execSync } from 'child_process'

export async function setup() {
  const dbUrl = process.env.DATABASE_URL || ''

  // Skip Docker setup if using external database (Test-stage AWS)
  if (dbUrl && !dbUrl.includes('localhost') && !dbUrl.includes('127.0.0.1')) {
    console.log('Using external database, skipping Docker setup')
    return
  }

  const cwd = new URL('..', import.meta.url).pathname

  // Check if container is running
  try {
    const result = execSync('docker compose ps --filter status=running --format json', {
      cwd,
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe'],
    })

    if (result.includes('gemhog-postgres')) {
      console.log('PostgreSQL container already running')
      await waitForPostgres(cwd)
      return
    }
  } catch {
    // Container not running, will start below
  }

  console.log('Starting PostgreSQL container...')
  execSync('docker compose up -d', { cwd, stdio: 'inherit' })
  await waitForPostgres(cwd)
}

async function waitForPostgres(cwd: string, maxAttempts = 30) {
  console.log('Waiting for PostgreSQL to be ready...')

  for (let i = 0; i < maxAttempts; i++) {
    try {
      execSync('docker compose exec -T postgres pg_isready -U postgres', {
        cwd,
        stdio: 'pipe',
      })
      console.log('PostgreSQL is ready')
      return
    } catch {
      await new Promise(r => setTimeout(r, 1000))
    }
  }

  throw new Error('PostgreSQL did not become ready in time')
}

export async function teardown() {
  // Don't stop the container - it may be reused
  // Container cleanup is manual via `pnpm db:stop` or `pnpm db:down`
}
```

Key design decisions:
- Detect external DB via DATABASE_URL (enables Test-stage AWS without code changes)
- Use `docker compose ps --format json` for reliable container status check
- Wait for `pg_isready` not just container start (healthcheck may not be enough)
- Don't auto-stop container in teardown (developer may want it running for db:studio)
  </action>
  <verify>
Run without Docker container running - should auto-start. Run with container already running - should skip start and wait for ready.
  </verify>
  <done>
globalSetup auto-starts Docker and waits for PostgreSQL health. Skips Docker when DATABASE_URL points to external host.
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure Vitest for db package with integration setup</name>
  <files>
    - packages/db/vitest.config.ts
    - package.json
  </files>
  <action>
Create `packages/db/vitest.config.ts` with globalSetup:

```typescript
// packages/db/vitest.config.ts
import { defineProject } from 'vitest/config'

export default defineProject({
  test: {
    name: '@gemhog/db',
    environment: 'node',
    include: ['src/**/*.test.ts'],
    globalSetup: ['./test/global-setup.ts'],
    hookTimeout: 60000,  // 60s for Docker startup
    testTimeout: 10000,  // 10s per test (DB operations can be slow)
  },
})
```

Update root `package.json` to add integration test script:

```json
{
  "scripts": {
    "test:integration": "vitest run --project @gemhog/db"
  }
}
```

The `--project` flag runs only the db package tests, which have the globalSetup that handles Docker.
  </action>
  <verify>
Run `pnpm test:integration` - should trigger globalSetup (Docker check/start) even with no tests.
  </verify>
  <done>
packages/db has Vitest config with globalSetup. Root has `test:integration` script targeting db project.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add example integration test</name>
  <files>
    - packages/db/src/connection.test.ts
  </files>
  <action>
Create a minimal integration test that verifies database connectivity:

```typescript
// packages/db/src/connection.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest'
import { drizzle } from 'drizzle-orm/node-postgres'
import { sql } from 'drizzle-orm'
import pg from 'pg'

describe('database connection', () => {
  let pool: pg.Pool
  let db: ReturnType<typeof drizzle>

  beforeAll(() => {
    const connectionString = process.env.DATABASE_URL ||
      'postgresql://postgres:password@localhost:5432/gemhog'

    pool = new pg.Pool({ connectionString })
    db = drizzle(pool)
  })

  afterAll(async () => {
    await pool.end()
  })

  it('should connect and execute a query', async () => {
    const result = await db.execute(sql`SELECT 1 as value`)
    expect(result.rows[0]).toEqual({ value: 1 })
  })

  it('should return current timestamp', async () => {
    const result = await db.execute(sql`SELECT NOW() as now`)
    expect(result.rows[0].now).toBeInstanceOf(Date)
  })
})
```

This test:
1. Connects using DATABASE_URL or fallback to local Docker defaults
2. Verifies basic query execution works
3. Proves globalSetup ran successfully (Docker is up)
  </action>
  <verify>
Run `pnpm test:integration` - should pass 2 tests after Docker starts and is healthy.
  </verify>
  <done>
Integration test proves database connectivity. Test uses env var for external DB support.
  </done>
</task>

</tasks>

<verification>
Run full verification:
1. `pnpm db:stop` - ensure Docker is stopped
2. `pnpm test:integration` - should auto-start Docker and pass tests
3. `pnpm test:integration` - second run should detect running container
4. Set `DATABASE_URL=postgresql://fake@remote:5432/db` and run - should skip Docker (will fail to connect, but won't try Docker)
</verification>

<success_criteria>
- [ ] globalSetup auto-starts Docker when container not running
- [ ] globalSetup waits for PostgreSQL to be healthy before tests run
- [ ] globalSetup skips Docker when DATABASE_URL points to non-localhost
- [ ] `pnpm test:integration` runs db package tests with proper setup
- [ ] Integration tests pass when database is accessible
- [ ] Exit codes are correct (0 on pass, non-zero on fail)
</success_criteria>

<output>
After completion, create `.planning/phases/01-testing-infrastructure/01-02-SUMMARY.md`
</output>
