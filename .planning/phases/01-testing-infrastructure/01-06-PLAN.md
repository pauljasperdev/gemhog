---
phase: 01-testing-infrastructure
plan: 06
type: execute
wave: 1
depends_on: [04]
files_modified:
  - vitest.integration.config.ts
  - test/integration-setup.ts
  - package.json
  - packages/db/src/connection.integration.test.ts
  - packages/db/src/connection.test.ts (deleted)
  - vitest.config.ts
autonomous: true

must_haves:
  truths:
    - "Integration tests use *.integration.test.ts suffix convention"
    - "Integration tests are discovered via glob pattern across all packages"
    - "Single globalSetup handles Docker for all integration tests"
    - "test:integration runs all *.integration.test.ts files in monorepo"
    - "Unit tests (*.test.ts) and integration tests (*.integration.test.ts) are separated"
  artifacts:
    - path: "vitest.integration.config.ts"
      provides: "Dedicated config for integration tests with globalSetup"
      contains: "**/*.integration.test.ts"
    - path: "test/integration-setup.ts"
      provides: "Shared Docker auto-start logic for all integration tests"
      contains: "docker compose"
    - path: "package.json"
      provides: "Updated test:integration script using dedicated config"
      contains: "vitest.integration.config.ts"
  key_links:
    - from: "package.json"
      to: "vitest.integration.config.ts"
      via: "test:integration --config flag"
      pattern: "--config vitest.integration.config.ts"
    - from: "vitest.integration.config.ts"
      to: "test/integration-setup.ts"
      via: "globalSetup option"
      pattern: "globalSetup.*integration-setup"
---

<objective>
Create scalable integration test infrastructure with file suffix convention

Purpose: Enable integration tests in any package using *.integration.test.ts suffix, with automatic Docker discovery and startup for all packages (not just packages/db)

Output: Working `pnpm test:integration` that discovers and runs all *.integration.test.ts files across the monorepo
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/TESTING.md
@vitest.config.ts
@packages/db/vitest.config.ts
@packages/db/test/global-setup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared integration test setup</name>
  <files>
    - test/integration-setup.ts
  </files>
  <action>
Create `test/integration-setup.ts` at repository root with Docker auto-start logic.

This is the shared globalSetup used by ALL integration tests across the monorepo.

```typescript
// test/integration-setup.ts
// Shared setup for all integration tests across the monorepo
import { execSync } from 'child_process'
import path from 'path'

export async function setup() {
  const dbUrl = process.env.DATABASE_URL || ''

  // Skip Docker setup if using external database (Test-stage AWS)
  if (dbUrl && !dbUrl.includes('localhost') && !dbUrl.includes('127.0.0.1')) {
    console.log('[integration] Using external database, skipping Docker setup')
    return
  }

  // Docker compose file lives in packages/db
  const dockerDir = path.join(process.cwd(), 'packages', 'db')

  // Check if container is running
  try {
    const result = execSync('docker compose ps --filter status=running --format json', {
      cwd: dockerDir,
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe'],
    })

    if (result.includes('gemhog-postgres')) {
      console.log('[integration] PostgreSQL container already running')
      await waitForPostgres(dockerDir)
      return
    }
  } catch {
    // Container not running, will start below
  }

  console.log('[integration] Starting PostgreSQL container...')
  execSync('docker compose up -d', { cwd: dockerDir, stdio: 'inherit' })
  await waitForPostgres(dockerDir)
}

async function waitForPostgres(cwd: string, maxAttempts = 30) {
  console.log('[integration] Waiting for PostgreSQL to be ready...')

  for (let i = 0; i < maxAttempts; i++) {
    try {
      execSync('docker compose exec -T postgres pg_isready -U postgres', {
        cwd,
        stdio: 'pipe',
      })
      console.log('[integration] PostgreSQL is ready')
      return
    } catch {
      await new Promise(r => setTimeout(r, 1000))
    }
  }

  throw new Error('PostgreSQL did not become ready in time')
}

export async function teardown() {
  // Don't stop the container - it may be reused
  // Container cleanup is manual via `pnpm db:stop` or `pnpm db:down`
}
```

Key design decisions:
- Lives at root `test/` folder, not tied to any specific package
- Uses `process.cwd()` to find docker-compose from repository root
- Same external DB detection logic (DATABASE_URL)
- Prefixed log messages with `[integration]` for clarity
  </action>
  <verify>
File exists at test/integration-setup.ts. Should export setup() and teardown() functions.
  </verify>
  <done>
Shared integration setup created at test/integration-setup.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create dedicated integration test config</name>
  <files>
    - vitest.integration.config.ts
  </files>
  <action>
Create `vitest.integration.config.ts` at repository root for integration tests.

```typescript
// vitest.integration.config.ts
// Dedicated config for integration tests across the monorepo
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    name: 'integration',
    environment: 'node',
    // Discover all *.integration.test.ts files across monorepo
    include: [
      'apps/**/src/**/*.integration.test.ts',
      'packages/**/src/**/*.integration.test.ts',
    ],
    // Exclude node_modules and dist
    exclude: [
      '**/node_modules/**',
      '**/dist/**',
    ],
    // Shared globalSetup handles Docker for all integration tests
    globalSetup: ['./test/integration-setup.ts'],
    // Timeouts for Docker startup and DB operations
    hookTimeout: 60000,  // 60s for Docker startup
    testTimeout: 10000,  // 10s per test (DB operations can be slow)
    // Run integration tests sequentially to avoid DB conflicts
    pool: 'forks',
    poolOptions: {
      forks: {
        singleFork: true,  // Single process for DB consistency
      },
    },
  },
})
```

Key design decisions:
- Separate config file (not modifying root vitest.config.ts)
- Glob pattern `**/*.integration.test.ts` discovers all integration tests
- Single fork mode prevents parallel DB access issues
- globalSetup runs once before any integration test in any package
  </action>
  <verify>
File exists at vitest.integration.config.ts. Should have include patterns for *.integration.test.ts files.
  </verify>
  <done>
Dedicated vitest.integration.config.ts created with glob-based discovery
  </done>
</task>

<task type="auto">
  <name>Task 3: Update test:integration script</name>
  <files>
    - package.json
  </files>
  <action>
Update the `test:integration` script in root package.json to use the new config.

Change from:
```json
"test:integration": "vitest run --project @gemhog/db",
```

To:
```json
"test:integration": "vitest run --config vitest.integration.config.ts",
```

This makes the script:
1. Use the dedicated integration config
2. Discover all *.integration.test.ts files automatically
3. Run the shared globalSetup for Docker
  </action>
  <verify>
Run `cat package.json | grep test:integration` to verify script updated.
  </verify>
  <done>
test:integration script uses dedicated vitest.integration.config.ts
  </done>
</task>

<task type="auto">
  <name>Task 4: Rename existing integration test to new convention</name>
  <files>
    - packages/db/src/connection.integration.test.ts (new)
    - packages/db/src/connection.test.ts (delete)
  </files>
  <action>
Rename the existing integration test to follow the new suffix convention.

1. Move `packages/db/src/connection.test.ts` to `packages/db/src/connection.integration.test.ts`
2. Content stays the same - just the filename changes

This test will now:
- Be discovered by the glob pattern in vitest.integration.config.ts
- NOT be picked up by the unit test runner (which looks for *.test.ts)
- Validate that the new convention works
  </action>
  <verify>
Run `pnpm test:integration` - should find and run the renamed test file.
  </verify>
  <done>
Existing integration test renamed to *.integration.test.ts convention
  </done>
</task>

<task type="auto">
  <name>Task 5: Update root vitest.config.ts to exclude integration tests</name>
  <files>
    - vitest.config.ts
  </files>
  <action>
Update root vitest.config.ts to explicitly exclude integration tests from unit test runs.

The current config excludes `packages/db` entirely. Now we:
1. Remove the `!packages/db` exclusion (packages/db can have unit tests too)
2. Add `**/*.integration.test.ts` to the exclude pattern

```typescript
// vitest.config.ts
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    projects: [
      "apps/*",
      "packages/*",
    ],
    // Exclude integration tests from unit test runs
    exclude: [
      "**/node_modules/**",
      "**/dist/**",
      "**/*.integration.test.ts",  // Integration tests have their own config
    ],
    reporters: ["default"],
    coverage: {
      provider: "v8",
      reporter: ["text"],
      include: ["**/src/**"],
      exclude: [
        "**/node_modules/**",
        "**/dist/**",
        "**/*.test.ts",
        "**/*.spec.ts",
        "**/*.integration.test.ts",
      ],
    },
  },
});
```

This means:
- `pnpm test:unit` runs all *.test.ts files (excluding *.integration.test.ts)
- `pnpm test:integration` runs all *.integration.test.ts files
- Clear separation between test types
  </action>
  <verify>
Run `pnpm test:unit` - should NOT run the integration test. Run `pnpm test:integration` - should run it.
  </verify>
  <done>
Root vitest.config.ts excludes *.integration.test.ts from unit test runs
  </done>
</task>

<task type="auto">
  <name>Task 6: Remove packages/db specific integration setup</name>
  <files>
    - packages/db/vitest.config.ts
    - packages/db/test/global-setup.ts (delete)
  </files>
  <action>
Clean up the now-redundant packages/db-specific integration setup.

1. Delete `packages/db/test/global-setup.ts` (replaced by root test/integration-setup.ts)
2. Update `packages/db/vitest.config.ts` to be a standard package config without globalSetup

```typescript
// packages/db/vitest.config.ts
import { defineProject } from 'vitest/config'

export default defineProject({
  test: {
    name: '@gemhog/db',
    environment: 'node',
    include: ['src/**/*.test.ts'],
    // No globalSetup needed - integration tests use vitest.integration.config.ts
  },
})
```

This means packages/db now works like any other package:
- Unit tests (*.test.ts) run via root vitest.config.ts / pnpm test:unit
- Integration tests (*.integration.test.ts) run via vitest.integration.config.ts / pnpm test:integration
  </action>
  <verify>
Run `pnpm test:unit` - packages/db unit tests should work. Run `pnpm test:integration` - integration tests should still work with shared setup.
  </verify>
  <done>
packages/db uses shared integration infrastructure, local globalSetup removed
  </done>
</task>

<task type="auto">
  <name>Task 7: Update TESTING.md documentation</name>
  <files>
    - .planning/codebase/TESTING.md
  </files>
  <action>
Update TESTING.md to document the new integration test convention.

Add section on test file naming:
- `*.test.ts` - Unit tests (mocked externals, fast)
- `*.integration.test.ts` - Integration tests (real DB, Docker required)
- `*.spec.ts` - E2E tests (Playwright)

Document the discovery mechanism:
- Unit tests: Discovered by root vitest.config.ts
- Integration tests: Discovered by vitest.integration.config.ts via glob pattern
- E2E tests: Discovered by Playwright config

Explain how to add integration tests to any package:
1. Create `src/something.integration.test.ts` (co-located with implementation)
2. Run `pnpm test:integration` - automatically discovered and run
3. Docker is auto-started if not running
  </action>
  <verify>
Read TESTING.md and verify the new convention is documented.
  </verify>
  <done>
TESTING.md updated with integration test convention documentation
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. `ls test/integration-setup.ts` - Shared setup exists at root
2. `ls vitest.integration.config.ts` - Integration config exists
3. `ls packages/db/src/connection.integration.test.ts` - Test renamed to new convention
4. `ls packages/db/test/global-setup.ts` - Should NOT exist (deleted)
5. `pnpm test:unit` - Should run unit tests, NOT integration tests
6. `pnpm test:integration` - Should:
   - Use vitest.integration.config.ts
   - Run shared test/integration-setup.ts (Docker startup)
   - Discover and run packages/db/src/connection.integration.test.ts
   - Pass both tests
7. `pnpm verify` - Full pipeline should complete

Scalability test (optional):
- Create `packages/auth/src/example.integration.test.ts` with a simple test
- Run `pnpm test:integration` - should discover and run both packages' integration tests
</verification>

<success_criteria>
- [ ] Shared integration setup at test/integration-setup.ts
- [ ] Dedicated vitest.integration.config.ts with glob discovery
- [ ] test:integration script uses new config
- [ ] Existing test renamed to *.integration.test.ts
- [ ] Root vitest.config.ts excludes *.integration.test.ts
- [ ] packages/db no longer has package-specific globalSetup
- [ ] TESTING.md documents the convention
- [ ] pnpm test:unit does NOT run integration tests
- [ ] pnpm test:integration discovers and runs all *.integration.test.ts files
</success_criteria>

<output>
After completion, create `.planning/phases/01-testing-infrastructure/01-06-SUMMARY.md`
</output>
