---
phase: 02-email-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/core/src/email/subscriber.sql.ts
  - packages/core/src/email/email.errors.ts
  - packages/core/src/email/token.ts
  - packages/core/src/email/token.test.ts
  - packages/core/src/email/test-fixtures.ts
  - packages/core/src/email/index.ts
  - packages/core/package.json
  - packages/env/src/server.ts
  - packages/env/src/server.test.ts
  - apps/server/.env.example
  - apps/web/.env.example
  - apps/server/src/startup.int.test.ts
autonomous: true

must_haves:
  truths:
    - "Subscriber table exists in database with email, status enum, and timestamps"
    - "HMAC tokens can be created and verified for verify and unsubscribe actions"
    - "Expired tokens are rejected"
    - "Invalid/tampered tokens are rejected"
    - "SUBSCRIBER_TOKEN_SECRET env var is optional in dev (token module falls back gracefully)"
    - "New email domain is importable via @gemhog/core/email"
  artifacts:
    - path: "packages/core/src/email/subscriber.sql.ts"
      provides: "Drizzle schema for subscriber table with pgEnum status"
      contains: "subscriberStatusEnum"
    - path: "packages/core/src/email/email.errors.ts"
      provides: "Tagged errors for email, subscriber, and token operations"
      contains: "EmailSendError"
    - path: "packages/core/src/email/token.ts"
      provides: "HMAC token creation and verification functions"
      exports: ["createToken", "verifyToken"]
    - path: "packages/core/src/email/token.test.ts"
      provides: "TDD tests for token module"
      contains: "createToken"
    - path: "packages/core/src/email/index.ts"
      provides: "Barrel exports for email domain"
    - path: "packages/core/package.json"
      provides: "Export path for @gemhog/core/email"
      contains: "./email"
  key_links:
    - from: "packages/core/src/email/token.ts"
      to: "packages/env/src/server.ts"
      via: "SUBSCRIBER_TOKEN_SECRET env var"
      pattern: "SUBSCRIBER_TOKEN_SECRET"
    - from: "packages/core/src/email/subscriber.sql.ts"
      to: "packages/core/drizzle.config.ts"
      via: "Drizzle schema glob ./src/*/*.sql.ts"
      pattern: "sql\\.ts"
---

<objective>
Create the email domain foundation: Drizzle schema, tagged errors, HMAC token module, env vars, and package exports.

Purpose: Establishes the data layer and cryptographic primitives that subscriber and email services will build on. The token module is a pure-function TDD target. The schema creates the subscriber table. Errors provide typed failure handling for the entire email domain.

Output: `packages/core/src/email/` directory with subscriber schema, error types, token utilities, test fixtures, and barrel exports. SUBSCRIBER_TOKEN_SECRET env var added (optional in dev). `@gemhog/core/email` export path registered.
</objective>

<execution_context>
@/home/lima/.claude/get-shit-done/workflows/execute-plan.md
@/home/lima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/TESTING.md
@.planning/codebase/STRUCTURE.md
@.planning/phases/02-email-infrastructure/02-RESEARCH.md
@.planning/phases/02-email-infrastructure/02-CONTEXT.md
@.planning/phases/02-email-infrastructure/02-01-SUMMARY.md
@packages/core/src/auth/auth.sql.ts
@packages/core/src/auth/auth.errors.ts
@packages/core/src/auth/index.ts
@packages/core/package.json
@packages/env/src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create email domain schema, errors, and package wiring</name>
  <files>
    packages/core/src/email/subscriber.sql.ts
    packages/core/src/email/email.errors.ts
    packages/core/src/email/test-fixtures.ts
    packages/core/src/email/index.ts
    packages/core/package.json
  </files>
  <action>
    Create the `packages/core/src/email/` directory and foundational files:

    1. **subscriber.sql.ts** -- Drizzle schema following the auth.sql.ts pattern:
       - `subscriberStatusEnum`: pgEnum with values `["pending", "active", "unsubscribed"]`
       - `subscriber` table with columns:
         - `id`: text primary key (use `crypto.randomUUID()` as default or nanoid -- match auth pattern)
         - `email`: text, notNull, unique
         - `status`: subscriberStatusEnum, notNull, default "pending"
         - `subscribedAt`: timestamp, defaultNow, notNull
         - `verifiedAt`: timestamp, nullable (set when verified)
         - `unsubscribedAt`: timestamp, nullable (set when unsubscribed)
         - `createdAt`: timestamp, defaultNow, notNull
         - `updatedAt`: timestamp, defaultNow, $onUpdate(() => new Date()), notNull
       - Indexes: `subscriber_email_idx` on email, `subscriber_status_idx` on status
       - NO utm_source, utm_medium, utm_campaign columns (Posthog handles attribution in Phase 3)

    2. **email.errors.ts** -- All error types for the entire email domain (single file, not split):
       - `EmailSendError` extends Data.TaggedError -- for SES/email sending failures (message, cause?)
       - `SubscriberError` extends Data.TaggedError -- for subscriber CRUD failures (message, cause?)
       - `SubscriberNotFoundError` extends Data.TaggedError -- for missing subscriber lookups (email)
       - `InvalidTokenError` extends Data.TaggedError -- for token verification failures (reason: "expired" | "invalid_signature" | "malformed")
       Follow the exact pattern from `packages/core/src/auth/auth.errors.ts`.

    3. **test-fixtures.ts** -- Test helpers following auth/test-fixtures.ts pattern:
       - `truncateSubscriberTable(db)` function to TRUNCATE subscriber table
       - `createTestSubscriber()` factory returning `{ email: \`test-${Date.now()}@example.com\` }`
       - Use same import patterns as auth test fixtures

    4. **index.ts** -- Barrel exports:
       - Export all from `./email.errors`
       - Export schema: `export * as subscriberSchema from "./subscriber.sql"`
       - Export token functions: `export { createToken, verifyToken } from "./token"` (will be created in Task 2)
       - NOTE: Service exports will be added in Plan 03

    5. **packages/core/package.json** -- Add export path:
       ```json
       "./email": {
         "default": "./src/email/index.ts"
       }
       ```
       Add it after the `./auth/auth.sql` entry. Also add:
       ```json
       "./email/subscriber.sql": {
         "default": "./src/email/subscriber.sql.ts"
       }
       ```
  </action>
  <verify>
    Run `pnpm check-types --filter @gemhog/core` to verify TypeScript compiles.
    Verify `packages/core/src/email/subscriber.sql.ts` exists and contains subscriberStatusEnum.
    Verify `packages/core/package.json` has the `./email` export path.
  </verify>
  <done>Email domain directory exists with schema, errors, test fixtures, barrel exports, and package.json export path. TypeScript compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Create HMAC token module with TDD + add SUBSCRIBER_TOKEN_SECRET env var</name>
  <files>
    packages/core/src/email/token.ts
    packages/core/src/email/token.test.ts
    packages/env/src/server.ts
    packages/env/src/server.test.ts
    apps/server/.env.example
    apps/web/.env.example
    apps/server/src/startup.int.test.ts
  </files>
  <action>
    **TDD approach: Write tests first, then implement.**

    1. **SUBSCRIBER_TOKEN_SECRET env var** -- Add to `packages/env/src/server.ts`:
       ```
       SUBSCRIBER_TOKEN_SECRET: z.string().min(32).optional()
       ```
       Make it OPTIONAL because dev doesn't need token verification (emails go to console, dev can click the logged URL directly). In production, it MUST be set via SST secret (enforced at infra level, not app level).

    2. **packages/env/src/server.test.ts** -- Add test for SUBSCRIBER_TOKEN_SECRET:
       - Test that env succeeds without SUBSCRIBER_TOKEN_SECRET (it's optional)
       - Test that env succeeds with a valid SUBSCRIBER_TOKEN_SECRET (32+ chars)
       - The guardrail test will automatically verify coverage since it reads schema vars

    3. **apps/server/.env.example** and **apps/web/.env.example** -- Add:
       ```
       # Subscriber token signing (optional for local dev)
       # SUBSCRIBER_TOKEN_SECRET=replace-with-at-least-32-characters
       ```
       Keep it commented out since it's optional for dev.

    4. **apps/server/src/startup.int.test.ts** -- This test validates that the server starts with .env.example values. Since SUBSCRIBER_TOKEN_SECRET is optional and commented out in .env.example, no changes should be needed here. But verify the build test still passes after the env schema change. If the startup test explicitly tests missing vars, it should NOT test SUBSCRIBER_TOKEN_SECRET since it's optional.

    5. **token.test.ts** -- Write tests FIRST (RED phase). Test cases:
       - `createToken` returns a base64url-encoded string
       - `verifyToken` with valid token returns the original payload
       - `verifyToken` with expired token returns null (or fails with InvalidTokenError)
       - `verifyToken` with tampered token returns null
       - `verifyToken` with malformed/garbage input returns null
       - `createToken` with action "verify" and "unsubscribe" both work
       - Token roundtrip: create -> verify returns matching email and action
       - Different secrets produce different tokens for same payload
       Use a hardcoded test secret (not env var) for deterministic testing.

    6. **token.ts** -- Implement AFTER tests are written:
       - Use Node.js `crypto` module (createHmac, timingSafeEqual) -- NO external dependencies
       - `createToken(payload: TokenPayload, secret: string): string`
         - TokenPayload: `{ email: string; action: "verify" | "unsubscribe"; expiresAt: number }`
         - JSON.stringify the payload, HMAC-SHA256 sign it, combine as `base64url(data.signature)`
       - `verifyToken(token: string, secret: string): TokenPayload | null`
         - Decode base64url, split on last dot, verify HMAC with timingSafeEqual
         - Return null if: malformed, invalid signature, expired (Date.now() > expiresAt)
       - Pure functions. No Effect wrapping. No env var reading (secret passed as parameter).
       - Follow the exact pattern from 02-RESEARCH.md Pattern 2.

    Run tests after implementation to confirm GREEN.
  </action>
  <verify>
    Run `pnpm test` to confirm all tests pass (unit + integration + guardrail).
    Run specific token tests: `pnpm vitest run --project @gemhog/core -- token.test.ts`
    Verify token.test.ts has at least 6 test cases covering create, verify, expired, tampered, malformed.
  </verify>
  <done>
    HMAC token module passes all TDD tests. SUBSCRIBER_TOKEN_SECRET env var is optional in schema with passing tests. .env.example files updated. Guardrail test passes. Full `pnpm test` passes.
  </done>
</task>

</tasks>

<verification>
1. `pnpm test` passes with zero failures
2. `packages/core/src/email/` directory exists with: subscriber.sql.ts, email.errors.ts, token.ts, token.test.ts, test-fixtures.ts, index.ts
3. `import { createToken, verifyToken } from "@gemhog/core/email"` resolves correctly
4. Token roundtrip test passes: createToken -> verifyToken returns original payload
5. Expired token test passes: verifyToken returns null for expired tokens
6. Schema contains subscriberStatusEnum with ["pending", "active", "unsubscribed"]
7. No UTM columns in subscriber schema
</verification>

<success_criteria>
- Email domain directory at packages/core/src/email/ with all foundation files
- Subscriber Drizzle schema with pgEnum status, no UTM columns
- HMAC token module with TDD-verified create/verify functions
- SUBSCRIBER_TOKEN_SECRET env var (optional) with passing guardrail tests
- @gemhog/core/email export path works
- pnpm test passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-email-infrastructure/02-02-SUMMARY.md`
</output>
