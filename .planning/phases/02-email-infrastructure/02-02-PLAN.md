---
phase: 02-email-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/subscriber/subscriber.sql.ts
  - packages/core/src/subscriber/subscriber.errors.ts
  - packages/core/src/subscriber/subscriber.service.ts
  - packages/core/src/subscriber/subscriber.mock.ts
  - packages/core/src/subscriber/token.ts
  - packages/core/src/subscriber/test-fixtures.ts
  - packages/core/src/subscriber/index.ts
  - packages/core/src/subscriber/subscriber.test.ts
  - packages/core/src/subscriber/token.test.ts
  - packages/core/src/subscriber/subscriber.int.test.ts
  - packages/core/package.json
  - packages/core/drizzle.config.ts
autonomous: true

must_haves:
  truths:
    - "Subscriber email is stored in database with status tracking (pending/active/unsubscribed)"
    - "Subscriber status transitions follow the state machine (pending->active, active->unsubscribed)"
    - "HMAC tokens can be created and verified for email verification and unsubscribe"
    - "Expired tokens are rejected"
    - "Duplicate emails are handled gracefully (no error, resend verification)"
  artifacts:
    - path: "packages/core/src/subscriber/subscriber.sql.ts"
      provides: "Subscriber database schema with pgEnum status"
      contains: "subscriberStatusEnum"
    - path: "packages/core/src/subscriber/subscriber.service.ts"
      provides: "Effect service for subscriber CRUD and status management"
      exports: ["SubscriberService", "SubscriberServiceLive"]
    - path: "packages/core/src/subscriber/token.ts"
      provides: "HMAC token creation and verification"
      exports: ["createToken", "verifyToken"]
    - path: "packages/core/src/subscriber/subscriber.errors.ts"
      provides: "Tagged errors for subscriber domain"
      contains: "SubscriberError"
  key_links:
    - from: "packages/core/src/subscriber/subscriber.service.ts"
      to: "packages/core/src/subscriber/subscriber.sql.ts"
      via: "Drizzle queries on subscriber table"
      pattern: "subscriber"
    - from: "packages/core/src/subscriber/subscriber.service.ts"
      to: "packages/core/src/subscriber/token.ts"
      via: "Token generation for verification links"
      pattern: "createToken"
---

<objective>
Build the subscriber domain in packages/core: database schema, Effect service for CRUD and status management, HMAC token utility for verification/unsubscribe links, and comprehensive tests.

Purpose: This is the core data model and business logic for email subscriptions. The subscriber service manages the full lifecycle: signup (pending), verification (active), and unsubscribe. HMAC tokens enable stateless verification without a separate tokens table.

Output: Complete `packages/core/src/subscriber/` domain with schema, service, errors, tokens, mocks, test fixtures, and full test coverage (unit + integration).
</objective>

<execution_context>
@/home/lima/.claude/get-shit-done/workflows/execute-plan.md
@/home/lima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-email-infrastructure/02-CONTEXT.md
@.planning/phases/02-email-infrastructure/02-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/TESTING.md
@.planning/codebase/STRUCTURE.md

Reference files for existing domain pattern (auth domain):
@packages/core/src/auth/auth.sql.ts
@packages/core/src/auth/auth.errors.ts
@packages/core/src/auth/auth.service.ts
@packages/core/src/auth/index.ts
@packages/core/src/auth/test-fixtures.ts
@packages/core/src/auth/auth.int.test.ts
@packages/core/package.json
@packages/core/src/drizzle/index.ts
@packages/core/src/drizzle/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create subscriber schema, errors, token utility, and package exports</name>
  <files>
    packages/core/src/subscriber/subscriber.sql.ts
    packages/core/src/subscriber/subscriber.errors.ts
    packages/core/src/subscriber/token.ts
    packages/core/src/subscriber/token.test.ts
    packages/core/src/subscriber/index.ts
    packages/core/package.json
  </files>
  <action>
    TDD: Write tests first, then implement.

    1. Create `packages/core/src/subscriber/subscriber.sql.ts`:
       - Define `subscriberStatusEnum` using `pgEnum("subscriber_status", ["pending", "active", "unsubscribed"])`
       - Define `subscriber` table using `pgTable("subscriber", {...})`:
         - `id`: `text("id").primaryKey()` (use nanoid or crypto.randomUUID at insert time)
         - `email`: `text("email").notNull().unique()`
         - `status`: `subscriberStatusEnum("status").notNull().default("pending")`
         - `utmSource`: `text("utm_source")`
         - `utmMedium`: `text("utm_medium")`
         - `utmCampaign`: `text("utm_campaign")`
         - `subscribedAt`: `timestamp("subscribed_at").defaultNow().notNull()`
         - `verifiedAt`: `timestamp("verified_at")`
         - `unsubscribedAt`: `timestamp("unsubscribed_at")`
         - `createdAt`: `timestamp("created_at").defaultNow().notNull()`
         - `updatedAt`: `timestamp("updated_at").defaultNow().$onUpdate(() => new Date()).notNull()`
       - Add indexes: `subscriber_email_idx` on email, `subscriber_status_idx` on status
       - Follow the exact pattern from `auth.sql.ts` (imports from `drizzle-orm/pg-core`)

    2. Create `packages/core/src/subscriber/subscriber.errors.ts`:
       - `SubscriberError extends Data.TaggedError("SubscriberError")<{ message: string; cause?: unknown }>`
       - `SubscriberNotFoundError extends Data.TaggedError("SubscriberNotFoundError")<{ email: string }>`
       - `InvalidTokenError extends Data.TaggedError("InvalidTokenError")<{ reason: "expired" | "invalid_signature" | "malformed" }>`
       - Follow exact pattern from `auth.errors.ts`

    3. Create `packages/core/src/subscriber/token.ts` (TDD):
       - Write `token.test.ts` FIRST with these test cases:
         - `createToken` returns a base64url-encoded string
         - `verifyToken` returns payload for valid token
         - `verifyToken` returns null for expired token
         - `verifyToken` returns null for tampered token
         - `verifyToken` returns null for malformed input
         - Tokens work for both "verify" and "unsubscribe" actions
       - Run tests -- they MUST FAIL (red)
       - Then implement `token.ts`:
         - `createToken(payload: TokenPayload, secret: string): string`
         - `verifyToken(token: string, secret: string): TokenPayload | null`
         - `TokenPayload = { email: string; action: "verify" | "unsubscribe"; expiresAt: number }`
         - Use Node.js `crypto.createHmac("sha256", secret)` for signing
         - Use `timingSafeEqual` for constant-time comparison
         - Base64url encode the `data.signature` format
         - See RESEARCH.md Pattern 2 for exact implementation reference
       - Run tests -- they MUST PASS (green)

    4. Create `packages/core/src/subscriber/index.ts`:
       - Export all from `subscriber.errors.ts`
       - Export schema: `export * as subscriberSchema from "./subscriber.sql"`
       - Export token utilities: `export { createToken, verifyToken } from "./token"`
       - Export service types and layers (will be added in Task 2)

    5. Update `packages/core/package.json` exports field:
       - Add `"./subscriber": { "default": "./src/subscriber/index.ts" }`
       - Add `"./subscriber/subscriber.sql": { "default": "./src/subscriber/subscriber.sql.ts" }`

    NOTE: The drizzle.config.ts glob `./src/*/*.sql.ts` already picks up new `*.sql.ts` files in subdirectories. No change needed.
  </action>
  <verify>
    - `pnpm check` passes (types + lint)
    - Token tests pass: `pnpm vitest run packages/core/src/subscriber/token.test.ts`
    - Token tests were written BEFORE implementation (TDD red-green confirmed)
  </verify>
  <done>Subscriber schema defined with pgEnum status tracking. Token utility creates and verifies HMAC-signed tokens with expiry. All tagged errors defined. Package exports registered.</done>
</task>

<task type="auto">
  <name>Task 2: Create subscriber Effect service with mock layer and tests</name>
  <files>
    packages/core/src/subscriber/subscriber.service.ts
    packages/core/src/subscriber/subscriber.mock.ts
    packages/core/src/subscriber/test-fixtures.ts
    packages/core/src/subscriber/subscriber.test.ts
    packages/core/src/subscriber/subscriber.int.test.ts
    packages/core/src/subscriber/index.ts
  </files>
  <action>
    TDD: Write tests first, then implement.

    1. Create `packages/core/src/subscriber/subscriber.service.ts`:
       - Define `SubscriberService` interface:
         - `subscribe(email: string, utm?: { source?: string; medium?: string; campaign?: string }): Effect<{ status: "created" | "resent" }, SubscriberError>`
           - If email not found: create with status "pending", return "created"
           - If email found with status "pending": return "resent" (caller sends new verification email)
           - If email found with status "active": return "created" (silent success, privacy-safe -- don't reveal existence)
           - If email found with status "unsubscribed": reset to "pending", clear unsubscribedAt, return "created" (fresh double opt-in)
         - `verify(email: string): Effect<void, SubscriberNotFoundError | SubscriberError>`
           - Find subscriber by email, update status to "active", set verifiedAt timestamp
           - If not found, fail with SubscriberNotFoundError
         - `unsubscribe(email: string): Effect<void, SubscriberNotFoundError | SubscriberError>`
           - Find subscriber by email, update status to "unsubscribed", set unsubscribedAt timestamp
           - If not found, fail with SubscriberNotFoundError
         - `findByEmail(email: string): Effect<Subscriber | null, SubscriberError>`
           - Return subscriber record or null
       - Define `SubscriberServiceTag` using `Context.Tag("SubscriberService")`
       - Create `SubscriberServiceLive` layer:
         - Uses `@effect/sql-drizzle` for database queries (follow DrizzleLive pattern from `packages/core/src/drizzle/index.ts`)
         - Uses Drizzle query builder with the subscriber schema
         - Generate IDs with `crypto.randomUUID()`
         - Wrap database operations in `Effect.tryPromise` with `SubscriberError`
       - Use Effect.gen for complex flows (subscribe has conditional logic)
       - Follow the Effect service pattern from CONVENTIONS.md

    2. Write unit tests FIRST in `packages/core/src/subscriber/subscriber.test.ts`:
       - Test `subscribe`:
         - New email creates subscriber with "pending" status, returns "created"
         - Already active email returns "created" silently (privacy)
         - Unsubscribed email resets to "pending", returns "created"
         - Pending email returns "resent"
       - Test `verify`:
         - Updates status to "active" and sets verifiedAt
         - Fails with SubscriberNotFoundError for unknown email
       - Test `unsubscribe`:
         - Updates status to "unsubscribed" and sets unsubscribedAt
         - Fails with SubscriberNotFoundError for unknown email
       - Use a mock layer (`subscriber.mock.ts`) with in-memory state for unit tests
       - Use `Layer.succeed(SubscriberServiceTag, {...})` pattern from CONVENTIONS.md
       - Run tests -- they MUST FAIL (red)

    3. Create `packages/core/src/subscriber/subscriber.mock.ts`:
       - In-memory implementation of SubscriberService for unit testing
       - Uses a Map<string, Subscriber> for storage
       - Implements all methods matching the interface
       - Export as `SubscriberServiceTest` layer

    4. Create `packages/core/src/subscriber/test-fixtures.ts`:
       - `truncateSubscriberTables(db)` function (same pattern as auth `test-fixtures.ts`)
       - `createTestSubscriber(overrides?)` factory function returning test data
       - Follow exact pattern from `packages/core/src/auth/test-fixtures.ts`

    5. Write integration tests in `packages/core/src/subscriber/subscriber.int.test.ts`:
       - Test full database round-trip with real Postgres
       - Use `vi.mock("@gemhog/env/server")` pattern from `auth.int.test.ts`
       - Test subscriber CRUD with real database:
         - Insert subscriber and query back
         - Verify status transitions (pending -> active, active -> unsubscribed)
         - Verify unique email constraint
         - Verify UTM params are stored
       - Use truncateSubscriberTables in beforeEach
       - Follow exact pattern from `packages/core/src/auth/auth.int.test.ts`

    6. Update `packages/core/src/subscriber/index.ts`:
       - Add service exports: `export { SubscriberService, SubscriberServiceTag, SubscriberServiceLive } from "./subscriber.service"`

    IMPORTANT: Run `pnpm db:generate` after creating the schema to generate migration files. Then run `pnpm db:push` or `pnpm db:migrate` to apply to local DB before integration tests.
  </action>
  <verify>
    - Unit tests pass: `pnpm vitest run packages/core/src/subscriber/subscriber.test.ts`
    - Integration tests pass: `pnpm vitest run -c vitest.integration.config.ts packages/core/src/subscriber/subscriber.int.test.ts`
    - `pnpm check` passes (types + lint)
    - `pnpm test` passes (full pipeline)
    - Database migration generated and applied
  </verify>
  <done>SubscriberService Effect layer manages full subscriber lifecycle (subscribe, verify, unsubscribe). Mock layer enables unit testing. Integration tests verify real database operations. All status transitions work correctly.</done>
</task>

</tasks>

<verification>
- `pnpm check` passes
- All subscriber unit tests pass
- All subscriber integration tests pass (requires `pnpm db:start`)
- Token unit tests pass with TDD evidence (written before implementation)
- Database migration generated for subscriber table
- `pnpm test` passes (full pipeline)
- Package exports resolve correctly: `@gemhog/core/subscriber`
</verification>

<success_criteria>
- Subscriber table exists in database with pgEnum status (pending/active/unsubscribed)
- SubscriberService handles all status transitions correctly
- HMAC tokens are created and verified with expiry support
- Privacy-safe behavior: duplicate email signup doesn't reveal existence
- Unsubscribed users can re-subscribe (fresh double opt-in flow)
- Full test coverage: unit tests with mocks + integration tests with real DB
- TDD followed: token tests written before implementation
- `pnpm test` passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-email-infrastructure/02-02-SUMMARY.md`
</output>
