---
phase: 02-email-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - packages/core/src/email/subscriber.service.ts
  - packages/core/src/email/subscriber.test.ts
  - packages/core/src/email/subscriber.int.test.ts
  - packages/core/src/email/email.service.ts
  - packages/core/src/email/email.service.test.ts
  - packages/core/src/email/email.templates.ts
  - packages/core/src/email/email.templates.test.ts
  - packages/core/src/email/email.mock.ts
  - packages/core/src/email/index.ts
autonomous: true

must_haves:
  truths:
    - "Subscriber can be created with pending status"
    - "Subscriber can be found by email"
    - "Subscriber status can transition: pending -> active (verify)"
    - "Subscriber status can transition: active -> unsubscribed (unsubscribe)"
    - "Duplicate email signup does not throw (returns existing or upserts)"
    - "Email service sends to console in dev mode"
    - "Verification email HTML contains a confirm button with verify URL"
    - "Unsubscribe email HTML is not needed (unsubscribe is header-based)"
    - "All services use Effect Context.Tag + Layer pattern"
  artifacts:
    - path: "packages/core/src/email/subscriber.service.ts"
      provides: "Effect service for subscriber CRUD and status management"
      exports: ["SubscriberService", "SubscriberServiceLive"]
    - path: "packages/core/src/email/email.service.ts"
      provides: "Effect service for email sending (console dev + SES live)"
      exports: ["EmailService", "EmailServiceConsole"]
    - path: "packages/core/src/email/email.templates.ts"
      provides: "Email HTML template builders"
      exports: ["verificationEmail", "unsubscribeSuccessEmail"]
    - path: "packages/core/src/email/email.mock.ts"
      provides: "Mock layers for testing"
      exports: ["MockEmailService", "MockSubscriberService"]
  key_links:
    - from: "packages/core/src/email/subscriber.service.ts"
      to: "packages/core/src/email/subscriber.sql.ts"
      via: "Drizzle query on subscriber table"
      pattern: "subscriber"
    - from: "packages/core/src/email/email.service.ts"
      to: "packages/core/src/email/email.templates.ts"
      via: "Template functions called when composing emails"
      pattern: "verificationEmail"
    - from: "packages/core/src/email/subscriber.service.ts"
      to: "packages/core/src/email/email.service.ts"
      via: "SubscriberService depends on EmailService to send verification"
      pattern: "EmailService"
---

<objective>
Build the subscriber service (CRUD + status management) and email service (console dev + SES live layer) as Effect services with full test coverage.

Purpose: These services contain the core business logic for the email domain. The subscriber service manages the subscriber lifecycle (create, verify, unsubscribe). The email service abstracts sending so dev uses console output while production uses SES. Templates provide the email HTML content.

Output: Working Effect services with mock layers, email templates, unit tests, and integration tests. Everything works with `pnpm dev` using console-log email sending.
</objective>

<execution_context>
@/home/lima/.claude/get-shit-done/workflows/execute-plan.md
@/home/lima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/TESTING.md
@.planning/phases/02-email-infrastructure/02-RESEARCH.md
@.planning/phases/02-email-infrastructure/02-CONTEXT.md
@.planning/phases/02-email-infrastructure/02-02-SUMMARY.md
@packages/core/src/auth/auth.service.ts
@packages/core/src/auth/auth.errors.ts
@packages/core/src/drizzle/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Email service, templates, and mock layers</name>
  <files>
    packages/core/src/email/email.service.ts
    packages/core/src/email/email.service.test.ts
    packages/core/src/email/email.templates.ts
    packages/core/src/email/email.templates.test.ts
    packages/core/src/email/email.mock.ts
  </files>
  <action>
    Create the email sending service and templates. TDD approach: tests first.

    1. **email.templates.ts** -- Pure template functions (no Effect):
       - `verificationEmail({ verifyUrl: string }): { subject: string; html: string }`
         - Subject: "Confirm your Gemhog subscription"
         - HTML: Warm welcome message with styled confirm button linking to verifyUrl.
         - Include "If you didn't sign up" disclaimer and expiry notice (7 days per CONTEXT.md).
         - Include CAN-SPAM footer placeholder slot (empty for now, populated in Phase 4+).
         - Follow the template pattern from 02-RESEARCH.md.
       - `unsubscribeConfirmationEmail(): { subject: string; html: string }`
         - Simple "You've been unsubscribed" confirmation with link back to site.
         - This is optional and may not be sent (unsubscribe is instant via link). Include for completeness.

    2. **email.templates.test.ts** -- Template tests:
       - verificationEmail returns subject containing "Confirm"
       - verificationEmail HTML contains the verifyUrl
       - verificationEmail HTML contains a confirm button/link
       - unsubscribeConfirmationEmail returns valid subject and HTML

    3. **email.service.ts** -- Effect service with Context.Tag:
       ```typescript
       interface EmailService {
         readonly send: (params: {
           to: string;
           subject: string;
           html: string;
           headers?: Record<string, string>;
         }) => Effect.Effect<void, EmailSendError>;
       }
       ```
       - `EmailService` as `Context.Tag("EmailService")`
       - `EmailServiceConsole` layer: Logs email to console (to, subject, truncated html). Uses `Layer.succeed`. This is the dev implementation.
       - Do NOT create `EmailServiceLive` (SES) in this plan -- that goes in Plan 05 (SST infra). Only create the console implementation here.
       - The console layer should log clearly: `[EMAIL] To: ${to} | Subject: ${subject}` followed by the HTML content (or a preview of it).

    4. **email.service.test.ts** -- Unit tests:
       - EmailServiceConsole.send logs to console (spy on console.log)
       - EmailServiceConsole.send resolves successfully (Effect.runPromise doesn't throw)
       - Test with mock headers (List-Unsubscribe)

    5. **email.mock.ts** -- Mock layers for testing:
       - `MockEmailService`: Layer.succeed with send that returns Effect.void (no-op)
       - `MockSubscriberService`: Layer.succeed with stubbed subscriber operations (will reference SubscriberService interface from Task 2)

    Follow Effect-TS conventions from CONVENTIONS.md:
    - Context.Tag for service tags
    - Layer.succeed for simple implementations
    - Data.TaggedError for errors (already in email.errors.ts)
    - No Effect.gen for single-operation functions (use pipe/flatMap)
  </action>
  <verify>
    Run template tests: `pnpm vitest run --project @gemhog/core -- email.templates.test.ts`
    Run service tests: `pnpm vitest run --project @gemhog/core -- email.service.test.ts`
    All tests pass.
  </verify>
  <done>
    EmailService interface defined. EmailServiceConsole layer logs emails to console. Templates generate correct HTML. Mock layers exist for testing. All unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Subscriber service with Effect DI, unit tests, and integration tests</name>
  <files>
    packages/core/src/email/subscriber.service.ts
    packages/core/src/email/subscriber.test.ts
    packages/core/src/email/subscriber.int.test.ts
    packages/core/src/email/index.ts
  </files>
  <action>
    Create the subscriber service with full CRUD and status management. TDD approach.

    1. **subscriber.service.ts** -- Effect service with Context.Tag:
       ```typescript
       interface SubscriberService {
         readonly subscribe: (email: string) => Effect.Effect<{ id: string; isNew: boolean }, SubscriberError>;
         readonly verify: (email: string) => Effect.Effect<void, SubscriberNotFoundError | SubscriberError>;
         readonly unsubscribe: (email: string) => Effect.Effect<void, SubscriberNotFoundError | SubscriberError>;
         readonly findByEmail: (email: string) => Effect.Effect<Subscriber | null, SubscriberError>;
       }
       ```
       - `SubscriberService` as `Context.Tag("SubscriberService")`
       - `SubscriberServiceLive` layer: Takes a Drizzle db instance as dependency.
         - `subscribe(email)`:
           - Check if subscriber exists by email
           - If exists and status is "pending": Return existing (isNew: false). The API layer will resend verification.
           - If exists and status is "active": Return existing (isNew: false). Silent success (privacy-safe, per CONTEXT.md).
           - If exists and status is "unsubscribed": Reset to "pending", clear unsubscribedAt, update subscribedAt. Return (isNew: true). Full re-opt-in per CONTEXT.md.
           - If not exists: Insert new subscriber with status "pending". Return (isNew: true).
         - `verify(email)`: Update status to "active", set verifiedAt to now. Fail with SubscriberNotFoundError if not found.
         - `unsubscribe(email)`: Update status to "unsubscribed", set unsubscribedAt to now. Fail with SubscriberNotFoundError if not found.
         - `findByEmail(email)`: Return subscriber or null.
       - Use Drizzle query builder (not raw SQL). Import subscriber table from subscriber.sql.ts.
       - The service does NOT send emails itself. Email sending is orchestrated at the API layer (Plan 04) which calls both SubscriberService and EmailService.
       - For the Drizzle db dependency, accept it via the Layer constructor (similar to how auth.service.ts uses the db). Use the existing Drizzle client pattern from `packages/core/src/drizzle/`.

    2. **subscriber.test.ts** -- Unit tests with mock database:
       - subscribe creates a new subscriber with pending status
       - subscribe with existing pending email returns isNew: false
       - subscribe with existing active email returns isNew: false (silent success)
       - subscribe with existing unsubscribed email resets to pending, returns isNew: true
       - verify sets status to active and verifiedAt
       - verify with nonexistent email fails with SubscriberNotFoundError
       - unsubscribe sets status to unsubscribed and unsubscribedAt
       - unsubscribe with nonexistent email fails with SubscriberNotFoundError
       - findByEmail returns subscriber or null
       Use mock layers (MockSubscriberService or inline mocks for the db).

    3. **subscriber.int.test.ts** -- Integration tests with real database:
       - Full subscribe -> verify lifecycle (pending -> active)
       - Full subscribe -> verify -> unsubscribe lifecycle
       - Duplicate subscribe (same email twice) returns existing
       - Re-subscribe after unsubscribe creates fresh opt-in
       - Use truncateSubscriberTable from test-fixtures.ts in beforeEach
       - Requires `pnpm db:start` and schema pushed. Run `pnpm db:push` if subscriber table doesn't exist yet (the test should handle this, or document it).
       - Follow the @effect/vitest pattern from TESTING.md if using Effect layers, or use standard vitest with Effect.runPromise.

    4. **index.ts** -- Update barrel exports to include:
       - `export { SubscriberService, SubscriberServiceLive } from "./subscriber.service"`
       - `export { EmailService, EmailServiceConsole } from "./email.service"`
       - `export { verificationEmail } from "./email.templates"`
       - `export { MockEmailService, MockSubscriberService } from "./email.mock"`
       Keep existing exports from Task 1 (errors, schema, token).

    Before running integration tests, ensure the subscriber table exists:
    - Run `pnpm db:generate` to create migration for the new subscriber table
    - Run `pnpm db:push` (or `pnpm db:migrate`) to apply schema to local DB
    - Then run integration tests
  </action>
  <verify>
    Run `pnpm db:generate` to verify migration generates for subscriber table.
    Run `pnpm db:push` to apply schema.
    Run unit tests: `pnpm vitest run --project @gemhog/core -- subscriber.test.ts`
    Run integration tests: `pnpm vitest run -c vitest.integration.config.ts -- subscriber.int.test.ts`
    Run full suite: `pnpm test`
    All tests pass.
  </verify>
  <done>
    SubscriberService handles full subscriber lifecycle (subscribe, verify, unsubscribe, findByEmail). Unit tests cover all status transitions and edge cases. Integration tests verify real database operations. Migration generated and applied. Email service, templates, and mocks all working. pnpm test passes.
  </done>
</task>

</tasks>

<verification>
1. `pnpm test` passes with zero failures
2. SubscriberService.subscribe creates subscriber with "pending" status
3. SubscriberService.verify transitions to "active" and sets verifiedAt
4. SubscriberService.unsubscribe transitions to "unsubscribed" and sets unsubscribedAt
5. Duplicate subscribe is handled gracefully (no errors, privacy-safe)
6. EmailServiceConsole logs email content to console
7. Templates produce valid HTML with correct content
8. Integration tests pass with real database
9. Migration file exists in packages/core/src/migrations/
</verification>

<success_criteria>
- SubscriberService Effect service with subscribe/verify/unsubscribe/findByEmail
- EmailService Effect service with console implementation
- Email templates for verification
- Mock layers for both services
- Unit tests for all service methods and templates
- Integration tests for subscriber lifecycle with real DB
- Database migration generated and applied
- All exports available via @gemhog/core/email
- pnpm test passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-email-infrastructure/02-03-SUMMARY.md`
</output>
