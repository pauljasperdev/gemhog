---
phase: 02-email-infrastructure
plan: 04
type: execute
wave: 2
depends_on: ["02-02", "02-03"]
files_modified:
  - packages/api/src/routers/subscriber.ts
  - packages/api/src/routers/index.ts
  - packages/api/src/routers/subscriber.test.ts
  - apps/web/src/app/api/unsubscribe/route.ts
  - apps/web/src/app/verify/page.tsx
  - apps/web/src/app/unsubscribed/page.tsx
  - apps/web/src/app/verify-expired/page.tsx
autonomous: true

must_haves:
  truths:
    - "Subscriber can sign up via tRPC mutation and receives verification email"
    - "Clicking verification link confirms subscription and shows success page"
    - "Clicking unsubscribe link changes status and shows confirmation page"
    - "Expired verification link shows expiry page with option to re-request"
    - "One-click unsubscribe POST endpoint works for RFC 8058 compliance"
    - "Email headers include List-Unsubscribe for one-click unsubscribe"
    - "Test email can be sent to verify SES is working"
  artifacts:
    - path: "packages/api/src/routers/subscriber.ts"
      provides: "tRPC router for subscribe mutation"
      exports: ["subscriberRouter"]
    - path: "apps/web/src/app/api/unsubscribe/route.ts"
      provides: "Next.js API route for one-click unsubscribe (POST) and link unsubscribe (GET)"
      exports: ["POST", "GET"]
    - path: "apps/web/src/app/verify/page.tsx"
      provides: "Verification confirmation page"
      contains: "confirmed"
    - path: "apps/web/src/app/unsubscribed/page.tsx"
      provides: "Unsubscribe confirmation page"
      contains: "unsubscribed"
    - path: "apps/web/src/app/verify-expired/page.tsx"
      provides: "Expired verification link page with re-request form"
      contains: "expired"
  key_links:
    - from: "packages/api/src/routers/subscriber.ts"
      to: "@gemhog/core/subscriber"
      via: "SubscriberService for database operations"
      pattern: "SubscriberService"
    - from: "packages/api/src/routers/subscriber.ts"
      to: "@gemhog/core/email"
      via: "EmailService for sending verification email"
      pattern: "EmailService"
    - from: "apps/web/src/app/api/unsubscribe/route.ts"
      to: "@gemhog/core/subscriber"
      via: "Token verification and status update"
      pattern: "verifyToken.*unsubscribe"
    - from: "apps/web/src/app/verify/page.tsx"
      to: "@gemhog/core/subscriber"
      via: "Token verification and status update"
      pattern: "verifyToken.*verify"
---

<objective>
Wire the subscriber and email domains into API endpoints and user-facing pages: tRPC subscribe mutation, verification page, unsubscribe endpoint (RFC 8058), and status pages.

Purpose: This connects the core domain logic (Plans 02 + 03) to user-facing flows. After this plan, the full double opt-in lifecycle works end-to-end: signup -> verification email -> confirm link -> active subscriber. Unsubscribe flow also works: unsubscribe link -> instant unsubscribe -> confirmation page.

Output: tRPC subscriber router, Next.js verification/unsubscribe routes, and status pages for the complete email subscription lifecycle.
</objective>

<execution_context>
@/home/lima/.claude/get-shit-done/workflows/execute-plan.md
@/home/lima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-email-infrastructure/02-CONTEXT.md
@.planning/phases/02-email-infrastructure/02-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/TESTING.md
@.planning/codebase/STRUCTURE.md

Prior plan summaries (needed for service interfaces):
@.planning/phases/02-email-infrastructure/02-02-SUMMARY.md
@.planning/phases/02-email-infrastructure/02-03-SUMMARY.md

Reference files for existing patterns:
@packages/api/src/routers/index.ts
@packages/api/src/index.ts
@packages/core/src/auth/index.ts
@apps/web/src/app/api/auth/[...all]/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tRPC subscriber router with subscribe mutation</name>
  <files>
    packages/api/src/routers/subscriber.ts
    packages/api/src/routers/index.ts
    packages/api/src/routers/subscriber.test.ts
  </files>
  <action>
    TDD: Write tests first, then implement.

    1. Write tests FIRST in `packages/api/src/routers/subscriber.test.ts`:
       - Test `subscribe` mutation:
         - Valid email returns success response (no error)
         - Invalid email format rejects with validation error
         - Response does NOT reveal whether email already exists (privacy)
         - Returns a generic success message regardless of email state
       - Use `t.createCallerFactory(appRouter)` pattern from existing tests
       - Mock the subscriber and email services at the Effect layer level
       - Run tests -- they MUST FAIL (red)

    2. Create `packages/api/src/routers/subscriber.ts`:
       - Import: `z` from "zod", `publicProcedure`, `router` from "../index"
       - Define `subscriberRouter`:
         - `subscribe` mutation:
           - Input: `z.object({ email: z.string().email(), utmSource: z.string().optional(), utmMedium: z.string().optional(), utmCampaign: z.string().optional() })`
           - Logic:
             1. Call SubscriberService.subscribe(email, utm params)
             2. If result is "created" or "resent": generate verification token using `createToken({ email, action: "verify", expiresAt: Date.now() + 7 * 24 * 60 * 60 * 1000 })` (7 days per CONTEXT.md)
             3. Build verify URL: `${APP_URL}/verify?token=${token}`
             4. Build unsubscribe URL: `${APP_URL}/api/unsubscribe?token=${unsubToken}`
             5. Call EmailService.send with verificationEmail template + unsubscribeHeaders
             6. If result is "created" and the subscriber was already active: skip sending email (they're already verified)
           - Response: `{ success: true, message: "Check your email to confirm your subscription." }` (same message regardless of email state for privacy)
           - This is a publicProcedure (no auth required)
           - Read `SUBSCRIBER_TOKEN_SECRET` and `APP_URL` from `process.env` (SST-agnostic)
       - Run tests -- they MUST PASS (green)

    3. Update `packages/api/src/routers/index.ts`:
       - Import `subscriberRouter` from "./subscriber"
       - Add to appRouter: `subscriber: subscriberRouter`
       - This merges the subscriber router into the existing app router

    IMPORTANT: The subscribe endpoint must NEVER reveal whether an email already exists in the system. Always return the same generic success message. This prevents email enumeration attacks.

    NOTE on Effect integration with tRPC: The subscriber and email services use Effect. In the tRPC procedure, run the Effect pipeline with `Effect.runPromise` providing the necessary layers. Use `SubscriberServiceLive` and `EmailServiceLive` (or `EmailServiceDev` based on NODE_ENV). The layers need database access -- compose them with `DatabaseLive` from `@gemhog/core`.
  </action>
  <verify>
    - Subscriber router tests pass: `pnpm vitest run packages/api/src/routers/subscriber.test.ts`
    - `pnpm check` passes (types + lint)
    - tRPC healthCheck still works (no regression)
  </verify>
  <done>tRPC subscriber router handles email signup with privacy-safe response. Verification email sent on new signups. Input validated with Zod. Effect services properly composed and executed.</done>
</task>

<task type="auto">
  <name>Task 2: Create verification page, unsubscribe API route, and status pages</name>
  <files>
    apps/web/src/app/api/unsubscribe/route.ts
    apps/web/src/app/verify/page.tsx
    apps/web/src/app/unsubscribed/page.tsx
    apps/web/src/app/verify-expired/page.tsx
  </files>
  <action>
    1. Create `apps/web/src/app/verify/page.tsx` (Server Component):
       - This is a Next.js server component that handles the verification link click
       - Read `token` from `searchParams`
       - Verify token using `verifyToken(token, process.env.SUBSCRIBER_TOKEN_SECRET)`
       - If token is valid and action is "verify":
         - Call SubscriberService.verify(payload.email) via Effect.runPromise
         - Show success page: "You're confirmed!" with friendly message and link back to site
       - If token is expired:
         - Redirect to `/verify-expired?email={encodeURIComponent(payload.email)}` (extract email before expiry check if possible, or show generic expired page)
       - If token is invalid/malformed:
         - Show error: "This link is invalid" with link back to site
       - Keep it simple: minimal styling with Tailwind, centered content, clean typography
       - NOTE: This is a server component. Use async function for the page. Access searchParams via props.

    2. Create `apps/web/src/app/verify-expired/page.tsx` (Client Component):
       - Shows "This link has expired" message
       - Includes an inline email input and "Resend" button to request a new verification email
       - On submit, calls the tRPC `subscriber.subscribe` mutation (which resends verification)
       - Shows confirmation after resend: "Check your email for a new confirmation link"
       - Use `"use client"` directive for interactivity

    3. Create `apps/web/src/app/api/unsubscribe/route.ts` (Next.js API route):
       - This is a Next.js route handler (NOT tRPC) because email clients POST directly to it
       - `POST` handler (RFC 8058 one-click unsubscribe):
         - Read `token` from URL search params
         - Verify token with action "unsubscribe"
         - If valid: update subscriber status to "unsubscribed" via SubscriberService
         - Return 200 OK (email clients expect simple 200)
         - If invalid: return 400
       - `GET` handler (link click from email body):
         - Read `token` from URL search params
         - Verify token with action "unsubscribe"
         - If valid: update subscriber status to "unsubscribed"
         - Redirect to `/unsubscribed` page
         - If invalid/expired: show error or redirect to home

    4. Create `apps/web/src/app/unsubscribed/page.tsx` (Server Component):
       - Clean goodbye page: "You've been unsubscribed" with friendly message
       - Link back to site: "Return to Gemhog"
       - No re-subscribe option on this page (per CONTEXT.md)
       - Minimal styling with Tailwind, centered content

    IMPORTANT:
    - The verify page and unsubscribe route need access to the subscriber service. Since these run on Next.js server-side, they can import from `@gemhog/core/subscriber` directly.
    - Use `process.env.SUBSCRIBER_TOKEN_SECRET` for token operations (SST-agnostic).
    - The unsubscribe POST must return a simple 200 OK with no redirect (email clients expect this for RFC 8058).
    - The unsubscribe GET can redirect to the confirmation page (for human clicks from email body).
  </action>
  <verify>
    - `pnpm check` passes (types + lint)
    - Pages render without errors: `pnpm build` in apps/web (or check with dev server)
    - Unsubscribe API route exports POST and GET
    - `pnpm test` passes (full pipeline)
  </verify>
  <done>Verification flow: click link -> verify token -> show success/expired page. Unsubscribe flow: POST returns 200 (RFC 8058), GET redirects to confirmation page. All status pages are clean and on-brand.</done>
</task>

<task type="auto">
  <name>Task 3: Integration test for full subscribe-verify-unsubscribe lifecycle</name>
  <files>
    packages/core/src/subscriber/lifecycle.int.test.ts
  </files>
  <action>
    Create an integration test that verifies the full subscriber lifecycle end-to-end with a real database.

    1. Create `packages/core/src/subscriber/lifecycle.int.test.ts`:
       - Use same setup pattern as `auth.int.test.ts` (vi.mock env, Pool, drizzle, beforeEach truncate)
       - Test the complete flow:
         a. **Subscribe**: Call SubscriberService.subscribe("test@example.com") -> status is "pending"
         b. **Token creation**: Create verification token -> token is a valid string
         c. **Verify**: Call SubscriberService.verify("test@example.com") -> status is "active", verifiedAt is set
         d. **Unsubscribe**: Call SubscriberService.unsubscribe("test@example.com") -> status is "unsubscribed", unsubscribedAt is set
         e. **Re-subscribe**: Call SubscriberService.subscribe("test@example.com") -> status resets to "pending"
         f. **Duplicate handling**: Subscribe with existing active email -> returns "created" (silent success)
       - Test token expiry:
         a. Create token with expiresAt in the past
         b. Verify it returns null
       - Test email sending integration:
         a. Use EmailServiceTest mock layer
         b. Subscribe and check that getSentEmails() has one email
         c. Verify email contains correct verification URL

    This is the "acceptance test" for the entire subscriber domain. It proves the services work together correctly.
  </action>
  <verify>
    - Integration test passes: `pnpm vitest run -c vitest.integration.config.ts packages/core/src/subscriber/lifecycle.int.test.ts`
    - `pnpm test` passes (full pipeline)
    - All 6+ test cases pass covering the complete lifecycle
  </verify>
  <done>Full subscriber lifecycle verified end-to-end: subscribe -> verify -> unsubscribe -> re-subscribe. Token expiry and duplicate handling confirmed. Email sending verified via mock layer.</done>
</task>

</tasks>

<verification>
- `pnpm check` passes
- tRPC subscriber router tests pass
- Full lifecycle integration test passes
- All Next.js pages build without errors
- Unsubscribe API route handles both POST (RFC 8058) and GET (link click)
- `pnpm test` passes (full pipeline)
- No email enumeration possible (same response for all subscribe inputs)
</verification>

<success_criteria>
- tRPC `subscriber.subscribe` mutation accepts email, sends verification, returns generic success
- Verification page: valid token -> "You're confirmed!", expired -> "Link expired" with resend, invalid -> error
- Unsubscribe POST returns 200 OK for RFC 8058 one-click compliance
- Unsubscribe GET redirects to clean goodbye page
- Verification email includes List-Unsubscribe and List-Unsubscribe-Post headers
- Full lifecycle works: subscribe (pending) -> verify (active) -> unsubscribe (unsubscribed) -> re-subscribe (pending)
- Privacy-safe: same response regardless of email existence
- Integration tests verify complete lifecycle with real database
- `pnpm test` passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-email-infrastructure/02-04-SUMMARY.md`
</output>
