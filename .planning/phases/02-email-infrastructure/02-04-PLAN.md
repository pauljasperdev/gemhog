---
phase: 02-email-infrastructure
plan: 04
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - apps/web/src/app/api/subscribe/route.ts
  - apps/web/src/app/api/verify/route.ts
  - apps/web/src/app/api/unsubscribe/route.ts
  - apps/web/src/app/verify/page.tsx
  - apps/web/src/app/unsubscribe/page.tsx
  - apps/web/src/app/api/subscribe/route.test.ts
  - apps/web/src/app/api/verify/route.test.ts
  - apps/web/src/app/api/unsubscribe/route.test.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/subscribe accepts email, creates pending subscriber, sends verification email"
    - "GET /api/verify?token=... verifies token, activates subscriber, redirects to success page"
    - "POST /api/unsubscribe?token=... verifies token, unsubscribes, returns 200 (RFC 8058 one-click)"
    - "GET /api/unsubscribe?token=... shows unsubscribe confirmation page"
    - "Duplicate signup returns success (privacy-safe, no email leak)"
    - "Expired verification link shows expiry page with re-signup option"
    - "Verification success page shows confirmation message"
    - "Unsubscribe confirmation page shows goodbye message"
  artifacts:
    - path: "apps/web/src/app/api/subscribe/route.ts"
      provides: "POST /api/subscribe endpoint"
      exports: ["POST"]
    - path: "apps/web/src/app/api/verify/route.ts"
      provides: "GET /api/verify endpoint for email verification"
      exports: ["GET"]
    - path: "apps/web/src/app/api/unsubscribe/route.ts"
      provides: "POST /api/unsubscribe for RFC 8058 one-click + GET for browser"
      exports: ["POST", "GET"]
    - path: "apps/web/src/app/verify/page.tsx"
      provides: "Verification success and expired link pages"
    - path: "apps/web/src/app/unsubscribe/page.tsx"
      provides: "Unsubscribe confirmation page"
  key_links:
    - from: "apps/web/src/app/api/subscribe/route.ts"
      to: "packages/core/src/email/subscriber.service.ts"
      via: "SubscriberService.subscribe call"
      pattern: "subscribe"
    - from: "apps/web/src/app/api/subscribe/route.ts"
      to: "packages/core/src/email/email.service.ts"
      via: "EmailService.send for verification email"
      pattern: "send"
    - from: "apps/web/src/app/api/subscribe/route.ts"
      to: "packages/core/src/email/token.ts"
      via: "createToken for verification URL"
      pattern: "createToken"
    - from: "apps/web/src/app/api/verify/route.ts"
      to: "packages/core/src/email/token.ts"
      via: "verifyToken to validate verification link"
      pattern: "verifyToken"
    - from: "apps/web/src/app/api/unsubscribe/route.ts"
      to: "packages/core/src/email/token.ts"
      via: "verifyToken to validate unsubscribe link"
      pattern: "verifyToken"
---

<objective>
Create the API endpoints for subscribe, verify, and unsubscribe flows, plus the status pages (success, expired, unsubscribed).

Purpose: These endpoints wire together the subscriber service, email service, and token module into working user flows. This is where the double opt-in flow comes to life. The subscribe endpoint creates a subscriber and sends a verification email. The verify endpoint confirms the subscription. The unsubscribe endpoint handles both RFC 8058 one-click POST and browser GET.

Output: Working API routes in Next.js App Router. Status pages for verification success, expired link, and unsubscribe confirmation. Full flow works with console email service in dev.
</objective>

<execution_context>
@/home/lima/.claude/get-shit-done/workflows/execute-plan.md
@/home/lima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/TESTING.md
@.planning/codebase/STRUCTURE.md
@.planning/phases/02-email-infrastructure/02-RESEARCH.md
@.planning/phases/02-email-infrastructure/02-CONTEXT.md
@.planning/phases/02-email-infrastructure/02-03-SUMMARY.md
@apps/web/src/app/api/auth/[...all]/route.ts
@packages/core/src/email/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Subscribe and verify API endpoints</name>
  <files>
    apps/web/src/app/api/subscribe/route.ts
    apps/web/src/app/api/verify/route.ts
    apps/web/src/app/api/subscribe/route.test.ts
    apps/web/src/app/api/verify/route.test.ts
    apps/web/src/app/verify/page.tsx
  </files>
  <action>
    Create the subscribe and verify endpoints as Next.js API routes (NOT tRPC, because these are called from email links and external clients).

    1. **POST /api/subscribe** (`apps/web/src/app/api/subscribe/route.ts`):
       - Accept JSON body: `{ email: string }`
       - Validate email with Zod: `z.object({ email: z.string().email() })`
       - Call SubscriberService.subscribe(email)
       - If isNew (new subscriber or re-subscribing after unsubscribe):
         - Create verification token using createToken({ email, action: "verify", expiresAt: Date.now() + 7 * 24 * 60 * 60 * 1000 })
         - Get secret from env: `process.env.SUBSCRIBER_TOKEN_SECRET` (for dev, use a fallback like "dev-secret-not-for-production-use-replace" if env var is not set)
         - Build verify URL: `${env.APP_URL}/api/verify?token=${token}`
         - Generate email HTML using verificationEmail({ verifyUrl })
         - Send via EmailService.send({ to: email, subject, html })
       - If NOT isNew (duplicate or already active): Do nothing extra (silent success, privacy-safe)
       - ALWAYS return 200 with `{ message: "Check your email to confirm your subscription" }` regardless of whether email existed (privacy-safe per CONTEXT.md)
       - On validation error: Return 400 with `{ error: "Invalid email address" }`
       - On service error: Return 500 with `{ error: "Something went wrong" }` (don't leak internals)
       - For re-signup of pending subscriber (isNew: false but status pending): ALSO resend verification email with fresh token. The subscribe method should indicate this. Alternatively, always send verification for pending subscribers. Simplest: if status is pending, send verification regardless of isNew flag. The SubscriberService returns the subscriber record -- check if status is "pending" to decide.

       **Important Effect wiring:** Since the API route is a Next.js handler (not Effect), you need to run the Effect pipeline. Use Effect.runPromise to execute. Build the Effect program that depends on SubscriberService and EmailService, then provide the layers. For dev, use EmailServiceConsole. For the subscriber layer, use SubscriberServiceLive with the Drizzle client.

       **Layer composition:** Create a shared layer composition function (or inline it) that provides:
       - SubscriberServiceLive (needs db from @gemhog/core/drizzle)
       - EmailServiceConsole (no deps)
       This can live in a shared file like `apps/web/src/lib/email-layers.ts` or inline in each route.

    2. **GET /api/verify** (`apps/web/src/app/api/verify/route.ts`):
       - Read `token` from URL search params
       - If no token: Return 400 `{ error: "Missing token" }`
       - Verify token using verifyToken(token, secret)
       - If null (invalid/expired/tampered):
         - Check if expired specifically (decode without verification, check expiresAt)
         - If expired: Redirect to `/verify?status=expired`
         - If invalid: Redirect to `/verify?status=invalid`
       - If valid:
         - Call SubscriberService.verify(payload.email)
         - Redirect to `/verify?status=success`
       - On service error: Redirect to `/verify?status=error`

    3. **Verify page** (`apps/web/src/app/verify/page.tsx`):
       - Read `status` from searchParams
       - `success`: "You're confirmed! Thanks for subscribing to Gemhog." with link back to home
       - `expired`: "This link has expired." with inline email input to request a new verification email (form POSTs to /api/subscribe)
       - `invalid`: "This link is invalid." with link back to home
       - `error`: "Something went wrong. Please try again." with link back to home
       - Clean, minimal design. No auth required. Use Tailwind for styling.

    4. **Tests** -- Unit tests for both routes:
       - Subscribe: valid email returns 200
       - Subscribe: invalid email returns 400
       - Subscribe: missing body returns 400
       - Verify: valid token redirects to /verify?status=success
       - Verify: expired token redirects to /verify?status=expired
       - Verify: missing token returns 400
       - Mock SubscriberService and EmailService for unit tests (use mock layers).
       - Test with real Next.js request/response objects (NextRequest, NextResponse).
  </action>
  <verify>
    Run tests: `pnpm vitest run --project @gemhog/web -- route.test.ts`
    Run full suite: `pnpm test`
    All tests pass.
  </verify>
  <done>
    POST /api/subscribe creates subscriber and sends verification email via console in dev. GET /api/verify validates token and activates subscriber. Verify page shows appropriate status messages. Tests cover happy path and error cases.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unsubscribe endpoint with RFC 8058 one-click support</name>
  <files>
    apps/web/src/app/api/unsubscribe/route.ts
    apps/web/src/app/api/unsubscribe/route.test.ts
    apps/web/src/app/unsubscribe/page.tsx
  </files>
  <action>
    Create the unsubscribe endpoint supporting both RFC 8058 one-click POST and browser GET.

    1. **POST /api/unsubscribe** (`apps/web/src/app/api/unsubscribe/route.ts`):
       - RFC 8058 one-click unsubscribe: Email clients (Gmail, Apple Mail) POST directly to this URL
       - Read `token` from URL search params
       - Verify token using verifyToken(token, secret) with action "unsubscribe"
       - If valid: Call SubscriberService.unsubscribe(payload.email), return 200
       - If invalid/expired: Return 400 `{ error: "Invalid or expired link" }`
       - On service error: Return 500 `{ error: "Something went wrong" }`

    2. **GET /api/unsubscribe** (same file):
       - Browser-based unsubscribe: User clicks link in email body
       - Read `token` from URL search params
       - Verify token using verifyToken(token, secret) with action "unsubscribe"
       - If valid:
         - Call SubscriberService.unsubscribe(payload.email) -- instant unsubscribe per CONTEXT.md
         - Redirect to `/unsubscribe?status=success`
       - If invalid/expired: Redirect to `/unsubscribe?status=invalid`
       - On service error: Redirect to `/unsubscribe?status=error`

    3. **Unsubscribe page** (`apps/web/src/app/unsubscribe/page.tsx`):
       - Read `status` from searchParams
       - `success`: "You've been unsubscribed. Sorry to see you go!" with link back to site. No re-subscribe option on this page (per CONTEXT.md).
       - `invalid`: "This unsubscribe link is invalid or has expired." with link back to home.
       - `error`: "Something went wrong. Please try again." with link back to home.
       - Clean, minimal design matching verify page style.

    4. **Tests** -- Unit tests:
       - POST unsubscribe: valid token returns 200
       - POST unsubscribe: invalid token returns 400
       - POST unsubscribe: missing token returns 400
       - GET unsubscribe: valid token redirects to /unsubscribe?status=success
       - GET unsubscribe: invalid token redirects to /unsubscribe?status=invalid
       - Mock SubscriberService for unit tests.

    **List-Unsubscribe header wiring note:** The List-Unsubscribe and List-Unsubscribe-Post headers are set at email send time (in the subscribe flow in Task 1), not in the unsubscribe endpoint. When sending the verification email (or any future newsletter), include these headers:
    ```
    List-Unsubscribe: <${unsubscribeUrl}>
    List-Unsubscribe-Post: List-Unsubscribe=One-Click
    ```
    where unsubscribeUrl uses action "unsubscribe" in the token. This should be added to the subscribe route in Task 1. If not already there, add it now: when sending verification email, also generate an unsubscribe token and include List-Unsubscribe headers.

    **Effect layer wiring:** Same pattern as Task 1. Use shared layer composition. Run Effect program with Effect.runPromise, provide SubscriberServiceLive and EmailServiceConsole layers.

    After both tasks, run `pnpm test` to verify the entire test suite passes.
  </action>
  <verify>
    Run tests: `pnpm vitest run --project @gemhog/web -- unsubscribe`
    Run full suite: `pnpm test`
    All tests pass.
    Manually test full flow with `pnpm dev`:
    1. POST /api/subscribe with curl -> see verification email in console
    2. Copy verify URL from console -> GET /api/verify?token=... -> see success page
    3. POST /api/unsubscribe with curl using unsubscribe token -> 200
  </verify>
  <done>
    Unsubscribe POST endpoint handles RFC 8058 one-click unsubscribe. Unsubscribe GET endpoint handles browser clicks. Confirmation page shows appropriate messages. List-Unsubscribe headers included in verification emails. All tests pass. Full double opt-in + unsubscribe flow works end-to-end with console email in dev.
  </done>
</task>

</tasks>

<verification>
1. `pnpm test` passes with zero failures
2. Full dev flow works:
   - `curl -X POST http://localhost:3001/api/subscribe -H "Content-Type: application/json" -d '{"email":"test@example.com"}'` returns 200
   - Verification email content appears in console
   - Verify URL from console works in browser (redirects to success page)
   - Unsubscribe works via both POST and GET
3. Privacy-safe: duplicate signup returns same 200 message without revealing email exists
4. Expired token shows expiry page with re-signup option
5. RFC 8058 POST /api/unsubscribe returns 200 for valid token
6. List-Unsubscribe headers included in sent emails
</verification>

<success_criteria>
- POST /api/subscribe creates subscriber and sends verification email
- GET /api/verify validates token and activates subscriber
- POST /api/unsubscribe handles RFC 8058 one-click unsubscribe
- GET /api/unsubscribe handles browser-based unsubscribe
- Status pages for verify (success, expired, invalid) and unsubscribe (success, invalid)
- Privacy-safe duplicate handling
- List-Unsubscribe + List-Unsubscribe-Post headers in emails
- All tests pass
- Full flow works with pnpm dev (console email)
</success_criteria>

<output>
After completion, create `.planning/phases/02-email-infrastructure/02-04-SUMMARY.md`
</output>
