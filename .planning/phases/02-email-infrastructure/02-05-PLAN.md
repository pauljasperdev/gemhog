---
phase: 02-email-infrastructure
plan: 05
type: execute
wave: 5
depends_on: ["02-04"]
files_modified:
  - infra/email.ts
  - infra/secrets.ts
  - infra/web.ts
  - infra/api.ts
  - sst.config.ts
  - packages/core/src/email/email.service.ts
  - packages/core/package.json
autonomous: false
user_setup:
  - service: aws-ses
    why: "Email sending via SES requires domain verification and DNS propagation"
    env_vars:
      - name: SUBSCRIBER_TOKEN_SECRET
        source: "Generate with: openssl rand -base64 32"
    dashboard_config:
      - task: "After sst deploy, verify SES domain identity is active"
        location: "AWS Console -> SES -> Verified Identities"
      - task: "If SES is in sandbox, request production access"
        location: "AWS Console -> SES -> Account Dashboard -> Request production access"

must_haves:
  truths:
    - "SST Email component creates SES domain identity with DKIM/SPF/DMARC"
    - "Deployed app sends real emails via SES (not console)"
    - "SUBSCRIBER_TOKEN_SECRET is stored as SST secret"
    - "SES_FROM_EMAIL env var is wired to Lambda functions"
    - "sst deploy succeeds without errors"
  artifacts:
    - path: "infra/email.ts"
      provides: "SST Email component for gemhog.com domain"
      contains: "sst.aws.Email"
    - path: "infra/secrets.ts"
      provides: "SubscriberTokenSecret SST secret"
      contains: "SubscriberTokenSecret"
    - path: "packages/core/src/email/email.service.ts"
      provides: "EmailServiceLive layer using SES v2 client"
      exports: ["EmailServiceLive"]
  key_links:
    - from: "infra/email.ts"
      to: "infra/web.ts"
      via: "email.sender wired as SES_FROM_EMAIL env var"
      pattern: "SES_FROM_EMAIL"
    - from: "infra/secrets.ts"
      to: "infra/web.ts"
      via: "SubscriberTokenSecret.value wired as SUBSCRIBER_TOKEN_SECRET"
      pattern: "SUBSCRIBER_TOKEN_SECRET"
    - from: "sst.config.ts"
      to: "infra/email.ts"
      via: "Dynamic import in run()"
      pattern: "import.*email"
---

<objective>
Set up SST Email infrastructure (SES domain, DKIM/SPF/DMARC), add the SES live email service layer, wire secrets and env vars, and deploy.

Purpose: This is the final plan that connects the dev-ready email system to production AWS infrastructure. Everything built in Plans 01-04 works with console email in dev. This plan adds the real SES sending capability and deploys it.

Output: infra/email.ts with SST Email component. EmailServiceLive layer using @aws-sdk/client-sesv2. SubscriberTokenSecret in SST secrets. All env vars wired in infra/web.ts and infra/api.ts. Deployed and working.
</objective>

<execution_context>
@/home/lima/.claude/get-shit-done/workflows/execute-plan.md
@/home/lima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/TESTING.md
@.planning/phases/02-email-infrastructure/02-RESEARCH.md
@.planning/phases/02-email-infrastructure/02-CONTEXT.md
@.planning/phases/02-email-infrastructure/02-04-SUMMARY.md
@infra/secrets.ts
@infra/web.ts
@infra/api.ts
@infra/router.ts
@sst.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: SST Email infrastructure and secrets wiring</name>
  <files>
    infra/email.ts
    infra/secrets.ts
    infra/web.ts
    infra/api.ts
    sst.config.ts
  </files>
  <action>
    Create the SST Email component and wire all env vars for production.

    1. **infra/email.ts** -- New file. SST Email component:
       ```typescript
       import { secrets } from "./secrets";

       export const email = new sst.aws.Email("Email", {
         sender: "gemhog.com",
         dns: sst.cloudflare.dns({
           zone: secrets.CloudflareZoneId.value,
         }),
         dmarc: "v=DMARC1; p=quarantine; adkim=s; aspf=s;",
       });
       ```
       This creates the SES domain identity with automatic DKIM CNAME records and DMARC TXT record in Cloudflare DNS. The Cloudflare DNS adapter ensures DKIM records use "DNS only" (gray cloud) which is required for DKIM verification.

    2. **infra/secrets.ts** -- Add SubscriberTokenSecret:
       ```typescript
       SubscriberTokenSecret: new sst.Secret("SubscriberTokenSecret"),
       ```
       Add after the existing secrets.

    3. **sst.config.ts** -- Add email import in run():
       ```typescript
       await import("./infra/email");
       ```
       Add before the api and web imports so the email identity exists before they reference it. Update the run() function to:
       ```typescript
       async run() {
         // ... existing transform hack
         await import("./infra/secrets");
         await import("./infra/neon");
         await import("./infra/email");  // NEW
         const api = await import("./infra/api");
         const web = await import("./infra/web");
         return { ...(api.outputs || {}), ...(web.outputs || {}) };
       }
       ```

    4. **infra/web.ts** -- Add email env vars to the Nextjs environment block:
       ```typescript
       // Email infrastructure
       SES_FROM_EMAIL: $dev ? "" : `hello@gemhog.com`,
       SUBSCRIBER_TOKEN_SECRET: secrets.SubscriberTokenSecret.value,
       ```
       Notes:
       - SES_FROM_EMAIL is empty string in dev because dev uses EmailServiceConsole (no SES)
       - SUBSCRIBER_TOKEN_SECRET is always wired (in dev, the app code treats it as optional)
       - APP_URL already exists from Plan 01 rename (was CORS_ORIGIN)
       - Do NOT import from email.ts directly (SST-agnostic). Use string literal for sender address.

    5. **infra/api.ts** -- Add email env vars to the Function environment block:
       ```typescript
       // Email infrastructure
       SES_FROM_EMAIL: $dev ? "" : `hello@gemhog.com`,
       SUBSCRIBER_TOKEN_SECRET: secrets.SubscriberTokenSecret.value,
       ```
       Same pattern as web.ts. The Hono server doesn't send emails directly, but having the env vars available ensures consistency. If the API server doesn't need them, skip this -- but it's safer to include since core package validates all env vars.

       WAIT: The server env schema validates SES_FROM_EMAIL if it's added. But SES_FROM_EMAIL will be added to the env schema in this plan's Task 2. For dev, SES_FROM_EMAIL should be optional (empty/missing is fine). So in infra, set it to empty string for $dev, and the env schema marks it optional.
  </action>
  <verify>
    Verify infra/email.ts exists and contains sst.aws.Email.
    Verify infra/secrets.ts has SubscriberTokenSecret.
    Verify sst.config.ts imports ./infra/email.
    Verify infra/web.ts has SES_FROM_EMAIL and SUBSCRIBER_TOKEN_SECRET.
    NOTE: sst deploy is NOT run in this task -- that requires user action (setting secrets).
  </verify>
  <done>
    SST Email infrastructure defined. Secrets wired. Env vars added to web and api infra configs. sst.config.ts imports email module.
  </done>
</task>

<task type="auto">
  <name>Task 2: SES live email service layer and env var additions</name>
  <files>
    packages/core/src/email/email.service.ts
    packages/core/package.json
    packages/env/src/server.ts
    packages/env/src/server.test.ts
    apps/server/.env.example
    apps/web/.env.example
  </files>
  <action>
    Add the SES live implementation of EmailService and wire the SES_FROM_EMAIL env var.

    1. **Install @aws-sdk/client-sesv2:**
       ```bash
       pnpm add @aws-sdk/client-sesv2 --filter @gemhog/core
       ```

    2. **packages/env/src/server.ts** -- Add SES_FROM_EMAIL:
       ```typescript
       SES_FROM_EMAIL: z.string().email().optional(),
       ```
       Optional because dev doesn't use SES. Production sets it via SST infra.

    3. **packages/env/src/server.test.ts** -- Add tests for SES_FROM_EMAIL:
       - Test that env succeeds without SES_FROM_EMAIL (optional)
       - Test that env succeeds with valid SES_FROM_EMAIL
       - The guardrail test will verify coverage

    4. **apps/server/.env.example** and **apps/web/.env.example** -- Add:
       ```
       # Email sending (optional for local dev - uses console logger)
       # SES_FROM_EMAIL=hello@gemhog.com
       ```
       Commented out since it's optional for dev.

    5. **packages/core/src/email/email.service.ts** -- Add EmailServiceLive:
       ```typescript
       import { SESv2Client, SendEmailCommand } from "@aws-sdk/client-sesv2";

       export const EmailServiceLive = Layer.sync(EmailServiceTag, () => {
         const client = new SESv2Client({
           region: process.env.AWS_REGION ?? "eu-central-1",
         });
         const senderEmail = process.env.SES_FROM_EMAIL ?? "hello@gemhog.com";

         return {
           send: ({ to, subject, html, headers }) =>
             Effect.tryPromise({
               try: () =>
                 client.send(
                   new SendEmailCommand({
                     FromEmailAddress: senderEmail,
                     Destination: { ToAddresses: [to] },
                     Content: {
                       Simple: {
                         Subject: { Data: subject },
                         Body: { Html: { Data: html } },
                         Headers: headers
                           ? Object.entries(headers).map(([name, value]) => ({
                               Name: name,
                               Value: value,
                             }))
                           : undefined,
                       },
                     },
                   }),
                 ),
               catch: (error) =>
                 new EmailSendError({
                   message: `Failed to send email to ${to}`,
                   cause: error,
                 }),
             }),
         };
       });
       ```
       Follow the exact pattern from 02-RESEARCH.md Pattern 1.
       Note: This reads env vars directly (SST-agnostic). No SST SDK imports.

    6. **Update email.service.ts exports** to export both EmailServiceConsole and EmailServiceLive. The API routes (Plan 04) should use EmailServiceConsole in dev and EmailServiceLive in production. Add a convenience layer:
       ```typescript
       export const EmailServiceAuto = process.env.SES_FROM_EMAIL
         ? EmailServiceLive
         : EmailServiceConsole;
       ```
       This auto-selects based on whether SES is configured. When SES_FROM_EMAIL is set (production), use SES. When not set (dev), use console.

    7. **Update API routes from Plan 04** to use EmailServiceAuto instead of hardcoded EmailServiceConsole. This ensures deployed version sends real emails while dev still logs to console. Check the layer composition in the subscribe/verify/unsubscribe routes and swap in EmailServiceAuto.

    Run `pnpm test` to verify everything still passes. The unit tests use mock layers so they won't try to call SES.
  </action>
  <verify>
    Run `pnpm test` to confirm all tests pass.
    Verify `@aws-sdk/client-sesv2` is in packages/core/package.json dependencies.
    Verify EmailServiceLive and EmailServiceAuto are exported from email.service.ts.
    Verify SES_FROM_EMAIL is in env schema as optional.
  </verify>
  <done>
    EmailServiceLive layer wraps SES v2 client. EmailServiceAuto selects console/SES based on env. SES_FROM_EMAIL env var added (optional). @aws-sdk/client-sesv2 installed. All tests pass. App code remains SST-agnostic.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete email infrastructure:
    - SST Email component (infra/email.ts) for SES domain identity with DKIM/SPF/DMARC
    - SubscriberTokenSecret in SST secrets
    - EmailServiceLive layer using @aws-sdk/client-sesv2
    - All env vars wired in infra/web.ts and infra/api.ts
  </what-built>
  <how-to-verify>
    Deploy and verify:

    1. Set the new SST secret:
       ```bash
       pnpm sst secret set SubscriberTokenSecret $(openssl rand -base64 32)
       ```

    2. Deploy to dev stage:
       ```bash
       pnpm sst deploy --stage dev
       ```

    3. Verify SES domain identity:
       - Go to AWS Console -> SES -> Verified Identities
       - Check that gemhog.com (or dev.gemhog.com) shows as verified
       - DKIM status should show "Verified" (may take up to 72 hours for DNS propagation)

    4. If SES is in sandbox mode:
       - Verify a test recipient email in SES console
       - Or request production access: AWS Console -> SES -> Account Dashboard -> Request production access

    5. Test real email sending:
       - POST to https://dev.gemhog.com/api/subscribe with a verified recipient email
       - Check inbox for verification email
       - Click verification link
       - Verify it redirects to success page

    6. Verify unsubscribe:
       - From verification email, extract unsubscribe token
       - GET /api/unsubscribe?token=... should show confirmation page
  </how-to-verify>
  <resume-signal>Type "approved" once SES is verified and test email arrives, or describe issues encountered</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm test` passes with zero failures
2. infra/email.ts creates sst.aws.Email with gemhog.com domain
3. infra/secrets.ts has SubscriberTokenSecret
4. sst.config.ts imports ./infra/email
5. infra/web.ts and infra/api.ts wire SES_FROM_EMAIL and SUBSCRIBER_TOKEN_SECRET
6. EmailServiceLive exists and wraps @aws-sdk/client-sesv2
7. EmailServiceAuto selects correct implementation based on env
8. sst deploy succeeds (after user sets secret)
9. Test email arrives in inbox (after SES verification)
</verification>

<success_criteria>
- SST Email component configured for gemhog.com with DKIM/SPF/DMARC
- SubscriberTokenSecret stored as SST secret
- EmailServiceLive layer sends via SES v2
- EmailServiceAuto switches between console (dev) and SES (prod)
- SES_FROM_EMAIL env var added (optional for dev)
- All infra env vars wired
- sst deploy succeeds
- Real email arrives in inbox (post-deployment verification)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-email-infrastructure/02-05-SUMMARY.md`
</output>
