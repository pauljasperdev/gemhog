---
phase: 02-email-infrastructure
plan: 07
type: execute
wave: 7
depends_on: ["02-06"]
files_modified:
  - packages/api/src/routers/subscriber.ts
  - packages/api/src/routers/index.ts
  - packages/api/package.json
  - apps/web/src/app/verify/page.tsx
  - apps/web/src/app/unsubscribe/page.tsx
  - apps/web/src/app/api/unsubscribe/route.ts
  - apps/web/src/app/api/unsubscribe/route.test.ts
  - apps/web/src/app/api/subscribe/route.ts
  - apps/web/src/app/api/subscribe/route.test.ts
  - apps/web/src/app/api/verify/route.ts
  - apps/web/src/app/api/verify/route.test.ts
  - apps/web/src/lib/email-layers.ts
  - infra/secrets.ts
  - infra/api.ts
  - infra/web.ts
  - apps/web/.env.example
  - apps/server/.env.example
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Subscribe uses a tRPC mutation (not a Next.js route handler)"
    - "Verify page reads ?token from searchParams and does verification directly as a server component"
    - "Unsubscribe page reads ?token from searchParams and does unsubscribe directly as a server component"
    - "POST /api/unsubscribe still works for RFC 8058 one-click email client unsubscribe"
    - "No GET /api/subscribe, GET /api/verify, or GET /api/unsubscribe routes exist"
    - "Token signing uses BETTER_AUTH_SECRET (not SUBSCRIBER_TOKEN_SECRET)"
    - "email-layers.ts uses env package for layer selection (not raw process.env)"
    - "SubscriberTokenSecret removed from SST infra"
    - "SES_FROM_EMAIL uses real domain in sst dev mode"
    - "All tests pass with pnpm test"
  artifacts:
    - path: "packages/api/src/routers/subscriber.ts"
      provides: "tRPC subscriber router with subscribe mutation"
      exports: ["subscriberRouter"]
    - path: "packages/api/src/routers/index.ts"
      provides: "App router with subscriber sub-router"
      contains: "subscriberRouter"
    - path: "apps/web/src/app/verify/page.tsx"
      provides: "Server component that verifies token directly"
      contains: "verifyToken"
    - path: "apps/web/src/app/unsubscribe/page.tsx"
      provides: "Server component that unsubscribes directly"
      contains: "verifyToken"
    - path: "apps/web/src/app/api/unsubscribe/route.ts"
      provides: "POST-only route for RFC 8058"
      exports: ["POST"]
    - path: "apps/web/src/lib/email-layers.ts"
      provides: "Layer composition using env package"
      contains: "makeEmailServiceLive"
  key_links:
    - from: "packages/api/src/routers/subscriber.ts"
      to: "packages/core/src/email/subscriber.service.ts"
      via: "tRPC mutation calls SubscriberServiceTag"
      pattern: "SubscriberServiceTag"
    - from: "apps/web/src/app/verify/page.tsx"
      to: "packages/core/src/email/token.ts"
      via: "Server component calls verifyToken with BETTER_AUTH_SECRET"
      pattern: "verifyToken.*BETTER_AUTH_SECRET"
    - from: "apps/web/src/lib/email-layers.ts"
      to: "packages/core/src/email/email.service.ts"
      via: "Uses makeEmailServiceLive factory"
      pattern: "makeEmailServiceLive"
    - from: "apps/web/src/app/api/unsubscribe/route.ts"
      to: "packages/core/src/email/token.ts"
      via: "POST handler uses verifyToken for RFC 8058"
      pattern: "verifyToken"
---

<objective>
Replace Next.js API routes with tRPC router and server component pages, fix infra config, and clean up SUBSCRIBER_TOKEN_SECRET references.

Purpose: Address code review items 1, 4, 5, 7, 8, and the architectural decision to move subscribe to tRPC, verify/unsubscribe to server component pages. Remove all SUBSCRIBER_TOKEN_SECRET references from infra and .env.example files. Fix SES_FROM_EMAIL to use real domain in sst dev.

Output: New tRPC subscriber router, refactored verify/unsubscribe pages, cleaned up API routes, fixed infra config, updated tests.
</objective>

<execution_context>
@/home/lima/.claude/get-shit-done/workflows/execute-plan.md
@/home/lima/.claude/get-shit-done/templates/summary.md
</execution_context>

<skills>
Use `/effect-ts` skill before writing ANY Effect code — tRPC mutation handlers, server
component Effect pipelines, layer composition, etc. It has correct APIs for Effect.gen,
Layer.mergeAll, Effect.provide, Effect.catchTag, Effect.either, Effect.runPromise, etc.

Use `/vercel-react-best-practices` skill when writing the verify/unsubscribe server
component pages — ensure proper Next.js 15 patterns for async server components,
searchParams handling, and data fetching.
</skills>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/phases/02-email-infrastructure/02-06-SUMMARY.md

@packages/api/src/routers/index.ts
@packages/api/src/index.ts
@packages/api/package.json
@apps/web/src/app/verify/page.tsx
@apps/web/src/app/unsubscribe/page.tsx
@apps/web/src/app/api/unsubscribe/route.ts
@apps/web/src/app/api/subscribe/route.ts
@apps/web/src/app/api/verify/route.ts
@apps/web/src/lib/email-layers.ts
@infra/secrets.ts
@infra/api.ts
@infra/web.ts
@apps/web/.env.example
@apps/server/.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tRPC subscriber router and update email-layers</name>
  <files>
    packages/api/src/routers/subscriber.ts
    packages/api/src/routers/index.ts
    packages/api/package.json
    apps/web/src/lib/email-layers.ts
  </files>
  <action>
**packages/api/package.json**: Add `effect` and `@gemhog/env` as dependencies:
```json
"effect": "catalog:",
"@gemhog/env": "workspace:*"
```

**packages/api/src/routers/subscriber.ts**: Create a new tRPC router for subscriber operations. This replaces the POST /api/subscribe Next.js route.

```typescript
import {
  createToken,
  EmailServiceTag,
  SubscriberServiceTag,
  verificationEmail,
} from "@gemhog/core/email";
import { env } from "@gemhog/env/server";
import { Effect } from "effect";
import { z } from "zod";

import { publicProcedure, router } from "../index";
import { EmailLayers } from "./subscriber.layers"; // see below

// NOTE: The subscribe mutation needs EmailLayers which require DB + email service.
// Since the tRPC context doesn't provide Effect layers, we provide them manually.
// This is the same pattern used by the old Next.js routes.
```

Wait -- the tRPC router needs access to Effect layers (SubscriberServiceTag, EmailServiceTag). The existing architecture has these provided via EmailLayers in the web app. But tRPC routers live in the `@gemhog/api` package.

**Architecture approach:** The tRPC subscriber router should accept the layers via the tRPC context, OR the router can compose the Effect pipeline and provide layers internally. Since the router is called from the web app (which has the layers), the simplest approach is:

1. The tRPC subscriber router builds the Effect program (using SubscriberServiceTag and EmailServiceTag).
2. The web app's tRPC handler already creates context. We need to make EmailLayers available.

Actually, the cleanest approach: The subscriber router does NOT directly depend on Effect layers at the tRPC level. Instead, it builds an Effect program and runs it with layers that are passed through. But tRPC context is synchronous setup.

**Simplest correct approach:** The subscriber router imports and uses EmailLayers directly. This means the `@gemhog/api` package needs to know about DatabaseLive and email layers. This is acceptable since `@gemhog/api` already depends on `@gemhog/core`.

Create the router:

```typescript
import {
  createToken,
  EmailServiceTag,
  makeEmailServiceLive,
  SubscriberServiceTag,
  SubscriberServiceLive,
  verificationEmail,
  EmailServiceConsole,
} from "@gemhog/core/email";
import { DatabaseLive } from "@gemhog/core/drizzle";
import { env } from "@gemhog/env/server";
import { Effect, Layer } from "effect";
import { z } from "zod";

import { publicProcedure, router } from "../index";

const EmailLayers = Layer.mergeAll(
  env.SES_FROM_EMAIL
    ? makeEmailServiceLive(env.SES_FROM_EMAIL)
    : EmailServiceConsole,
  SubscriberServiceLive.pipe(Layer.provide(DatabaseLive)),
);

export const subscriberRouter = router({
  subscribe: publicProcedure
    .input(z.object({ email: z.string().email() }))
    .mutation(async ({ input }) => {
      const { email } = input;
      const secret = env.BETTER_AUTH_SECRET;
      const appUrl = env.APP_URL;

      const program = Effect.gen(function* () {
        const subscriberService = yield* SubscriberServiceTag;
        const emailService = yield* EmailServiceTag;

        const result = yield* subscriberService.subscribe(email);

        const sub = yield* subscriberService.findByEmail(email);
        const shouldSendEmail = result.isNew || sub?.status === "pending";

        if (shouldSendEmail) {
          const token = yield* createToken(
            {
              email,
              action: "verify",
              expiresAt: Date.now() + 7 * 24 * 60 * 60 * 1000,
            },
            secret,
          );

          const unsubscribeToken = yield* createToken(
            {
              email,
              action: "unsubscribe",
              expiresAt: Date.now() + 365 * 24 * 60 * 60 * 1000,
            },
            secret,
          );

          const verifyUrl = `${appUrl}/verify?token=${token}`;
          const unsubscribeUrl = `${appUrl}/api/unsubscribe?token=${unsubscribeToken}`;
          const { subject, html } = verificationEmail({ verifyUrl });

          yield* emailService.send({
            to: email,
            subject,
            html,
            headers: {
              "List-Unsubscribe": `<${unsubscribeUrl}>`,
              "List-Unsubscribe-Post": "List-Unsubscribe=One-Click",
            },
          });
        }
      });

      await Effect.runPromise(program.pipe(Effect.provide(EmailLayers)));

      return {
        message: "Check your email to confirm your subscription",
      };
    }),
});
```

Note the URL changes: `verifyUrl` now points to `/verify?token=...` (the page, not `/api/verify`). `unsubscribeUrl` still points to `/api/unsubscribe?token=...` for RFC 8058 POST support from email clients.

**packages/api/src/routers/index.ts**: Import and merge the subscriber router:

```typescript
import { protectedProcedure, publicProcedure, router } from "../index";
import { subscriberRouter } from "./subscriber";

export const appRouter = router({
  healthCheck: publicProcedure.query(() => {
    return "OK";
  }),
  privateData: protectedProcedure.query(({ ctx }) => {
    return {
      message: "This is private",
      user: ctx.session.user,
    };
  }),
  subscriber: subscriberRouter,
});
export type AppRouter = typeof appRouter;
```

**apps/web/src/lib/email-layers.ts**: Update to use env package and makeEmailServiceLive factory:

```typescript
import { DatabaseLive } from "@gemhog/core/drizzle";
import {
  EmailServiceConsole,
  makeEmailServiceLive,
  SubscriberServiceLive,
} from "@gemhog/core/email";
import { env } from "@gemhog/env/server";
import { Layer } from "effect";

export const EmailLayers = Layer.mergeAll(
  env.SES_FROM_EMAIL
    ? makeEmailServiceLive(env.SES_FROM_EMAIL)
    : EmailServiceConsole,
  SubscriberServiceLive.pipe(Layer.provide(DatabaseLive)),
);
```

This replaces raw `process.env` with the typed env package and uses `makeEmailServiceLive` factory from plan 02-06.
  </action>
  <verify>
Run `pnpm check` to verify the new files pass formatting and linting.
Verify `packages/api/src/routers/subscriber.ts` exports `subscriberRouter`.
Verify `packages/api/src/routers/index.ts` includes `subscriber: subscriberRouter`.
  </verify>
  <done>
- tRPC subscriber router exists with subscribe mutation
- App router includes subscriber sub-router
- email-layers.ts uses env package and makeEmailServiceLive factory
- @gemhog/api package.json has effect and @gemhog/env dependencies
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert verify/unsubscribe pages to server components, clean up routes and infra</name>
  <files>
    apps/web/src/app/verify/page.tsx
    apps/web/src/app/unsubscribe/page.tsx
    apps/web/src/app/api/unsubscribe/route.ts
    apps/web/src/app/api/unsubscribe/route.test.ts
    apps/web/src/app/api/subscribe/route.ts
    apps/web/src/app/api/subscribe/route.test.ts
    apps/web/src/app/api/verify/route.ts
    apps/web/src/app/api/verify/route.test.ts
    infra/secrets.ts
    infra/api.ts
    infra/web.ts
    apps/web/.env.example
    apps/server/.env.example
  </files>
  <action>
**apps/web/src/app/verify/page.tsx**: Convert from reading `?status` (redirected from API route) to reading `?token` and doing verification directly as a server component.

The page should:
1. Read `token` from searchParams (it's a server component, searchParams is a Promise in Next.js 15)
2. If no token, show the error/invalid state
3. If token exists, run the verification Effect pipeline directly:
   - Use `verifyToken(token, env.BETTER_AUTH_SECRET)` from core
   - Use `SubscriberServiceTag.verify(payload.email)`
   - Provide EmailLayers
   - Catch InvalidTokenError to determine expired vs invalid
   - Catch all other errors as generic error
4. Render the appropriate UI based on the result

```tsx
import { env } from "@gemhog/env/server";
import {
  SubscriberServiceTag,
  verifyToken,
} from "@gemhog/core/email";
import { Effect } from "effect";
import Link from "next/link";

import { EmailLayers } from "@/lib/email-layers";

type VerifyStatus = "success" | "expired" | "invalid" | "error";

async function getVerifyStatus(token: string): Promise<VerifyStatus> {
  const program = Effect.gen(function* () {
    const subscriberService = yield* SubscriberServiceTag;
    const payload = yield* verifyToken(token, env.BETTER_AUTH_SECRET);
    yield* subscriberService.verify(payload.email);
    return "success" as VerifyStatus;
  }).pipe(
    Effect.catchTag("InvalidTokenError", (error) =>
      Effect.succeed(
        (error.reason === "expired" ? "expired" : "invalid") as VerifyStatus,
      ),
    ),
    Effect.catchAll(() => Effect.succeed("error" as VerifyStatus)),
  );

  return Effect.runPromise(program.pipe(Effect.provide(EmailLayers)));
}

// Keep existing SuccessContent, ExpiredContent, InvalidContent, ErrorContent components.
// Update the page component:

export default async function VerifyPage({
  searchParams,
}: {
  searchParams: Promise<{ token?: string }>;
}) {
  const { token } = await searchParams;

  const status = token ? await getVerifyStatus(token) : "invalid";

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-50 px-4">
      <div className="w-full max-w-md rounded-lg border border-gray-200 bg-white p-8 text-center shadow-sm">
        {status === "success" && <SuccessContent />}
        {status === "expired" && <ExpiredContent />}
        {status === "invalid" && <InvalidContent />}
        {status === "error" && <ErrorContent />}
      </div>
    </div>
  );
}
```

Note: Remove the `form action="/api/subscribe"` from ExpiredContent since subscribe is now tRPC. Replace with a simple "Go back to sign up" link or just a link to home. The re-signup form would use tRPC in the landing page (Phase 4).

**apps/web/src/app/unsubscribe/page.tsx**: Same pattern as verify -- read `?token` and do unsubscribe directly.

```tsx
import { env } from "@gemhog/env/server";
import {
  SubscriberServiceTag,
  verifyToken,
} from "@gemhog/core/email";
import { Effect } from "effect";
import Link from "next/link";

import { EmailLayers } from "@/lib/email-layers";

type UnsubscribeStatus = "success" | "invalid" | "error";

async function getUnsubscribeStatus(token: string): Promise<UnsubscribeStatus> {
  const program = Effect.gen(function* () {
    const subscriberService = yield* SubscriberServiceTag;
    const payload = yield* verifyToken(token, env.BETTER_AUTH_SECRET);
    yield* subscriberService.unsubscribe(payload.email);
    return "success" as UnsubscribeStatus;
  }).pipe(
    Effect.catchTag("InvalidTokenError", () =>
      Effect.succeed("invalid" as UnsubscribeStatus),
    ),
    Effect.catchAll(() => Effect.succeed("error" as UnsubscribeStatus)),
  );

  return Effect.runPromise(program.pipe(Effect.provide(EmailLayers)));
}

// Keep existing SuccessContent, InvalidContent, ErrorContent components.
// Update the page component to read token, not status.
```

**apps/web/src/app/api/subscribe/route.ts**: DELETE this file entirely. Subscribe is now a tRPC mutation.

**apps/web/src/app/api/subscribe/route.test.ts**: DELETE this file entirely. Tests for subscribe belong with the tRPC router (or we skip them here since the tRPC integration is tested via the router).

**apps/web/src/app/api/verify/route.ts**: DELETE this file entirely. Verify is now handled by the page server component.

**apps/web/src/app/api/verify/route.test.ts**: DELETE this file entirely.

**apps/web/src/app/api/unsubscribe/route.ts**: Keep ONLY the POST handler for RFC 8058. Remove the GET handler. Update to use `env.BETTER_AUTH_SECRET` instead of SUBSCRIBER_TOKEN_SECRET:

```typescript
import {
  SubscriberServiceTag,
  verifyToken,
} from "@gemhog/core/email";
import { env } from "@gemhog/env/server";
import { Effect } from "effect";
import { type NextRequest, NextResponse } from "next/server";

import { EmailLayers } from "@/lib/email-layers";

export async function POST(request: NextRequest) {
  const token = request.nextUrl.searchParams.get("token");

  if (!token) {
    return NextResponse.json({ error: "Missing token" }, { status: 400 });
  }

  const program = Effect.gen(function* () {
    const subscriberService = yield* SubscriberServiceTag;
    const payload = yield* verifyToken(token, env.BETTER_AUTH_SECRET);
    yield* subscriberService.unsubscribe(payload.email);
  }).pipe(
    Effect.catchTag("InvalidTokenError", () => Effect.fail("invalid" as const)),
    Effect.catchAll(() => Effect.fail("error" as const)),
  );

  const result = await Effect.runPromise(
    program.pipe(
      Effect.provide(EmailLayers),
      Effect.either,
    ),
  );

  if (result._tag === "Right") {
    return NextResponse.json({ message: "Unsubscribed successfully" });
  }
  if (result.left === "invalid") {
    return NextResponse.json(
      { error: "Invalid or expired link" },
      { status: 400 },
    );
  }
  return NextResponse.json({ error: "Something went wrong" }, { status: 500 });
}
```

**apps/web/src/app/api/unsubscribe/route.test.ts**: Update to test only POST (remove GET tests). Update to use `BETTER_AUTH_SECRET` instead of `SUBSCRIBER_TOKEN_SECRET` in vi.stubEnv. Import only `POST` (not `GET`).

**infra/secrets.ts**: Remove the `SubscriberTokenSecret` line:
```typescript
export const secrets = {
  DatabaseUrl: new sst.Secret("DatabaseUrl"),
  DatabaseUrlPooler: new sst.Secret("DatabaseUrlPooler"),
  BetterAuthSecret: new sst.Secret("BetterAuthSecret"),
  GoogleApiKey: new sst.Secret("GoogleApiKey"),
  CloudflareZoneId: new sst.Secret("CloudflareZoneId"),
  // Sentry error monitoring
  SentryDsn: new sst.Secret("SentryDsn"),
  SentryAuthToken: new sst.Secret("SentryAuthToken"),
  SentryOrg: new sst.Secret("SentryOrg"),
  SentryProject: new sst.Secret("SentryProject"),
};
```

**infra/api.ts**: Two changes:
1. Remove `SUBSCRIBER_TOKEN_SECRET: secrets.SubscriberTokenSecret.value` line.
2. Fix `SES_FROM_EMAIL`: In `$dev` mode, use the real domain `"hello@gemhog.com"` (not empty string). SES needs a real sender address even in dev for the email service to work when testing with real SES. Change:
   ```
   SES_FROM_EMAIL: $dev ? "" : "hello@gemhog.com"
   ```
   to:
   ```
   SES_FROM_EMAIL: "hello@gemhog.com"
   ```
   (Same value for both dev and prod.)

**infra/web.ts**: Remove `SUBSCRIBER_TOKEN_SECRET: secrets.SubscriberTokenSecret.value` line. Apply the same SES_FROM_EMAIL fix as api.ts.

**apps/web/.env.example**: Remove the SUBSCRIBER_TOKEN_SECRET lines (both the comment and the commented-out value, lines 12-13).

**apps/server/.env.example**: Remove the SUBSCRIBER_TOKEN_SECRET lines (both the comment and the commented-out value, lines 11-12).

After all file changes, run `pnpm install` to update the lockfile (since packages/api/package.json changed).
  </action>
  <verify>
Run `pnpm install` to update lockfile.
Run `pnpm db:start && pnpm test` -- ALL tests must pass.
Run `pnpm check` -- no formatting or lint errors.

Verify deleted files:
- `apps/web/src/app/api/subscribe/route.ts` does NOT exist
- `apps/web/src/app/api/subscribe/route.test.ts` does NOT exist
- `apps/web/src/app/api/verify/route.ts` does NOT exist
- `apps/web/src/app/api/verify/route.test.ts` does NOT exist

Verify remaining files:
- `apps/web/src/app/api/unsubscribe/route.ts` exports only POST (no GET)
- `apps/web/src/app/verify/page.tsx` contains `verifyToken` and `BETTER_AUTH_SECRET`
- `apps/web/src/app/unsubscribe/page.tsx` contains `verifyToken` and `BETTER_AUTH_SECRET`
- `infra/secrets.ts` has no `SubscriberTokenSecret`
- `infra/api.ts` has no `SUBSCRIBER_TOKEN_SECRET` and SES_FROM_EMAIL is `"hello@gemhog.com"` unconditionally
- `infra/web.ts` has no `SUBSCRIBER_TOKEN_SECRET`
- No `.env.example` file mentions SUBSCRIBER_TOKEN_SECRET

Grep across repo: `grep -r "SUBSCRIBER_TOKEN_SECRET" --include="*.ts" --include="*.tsx" --include="*.example"` should return 0 results.
  </verify>
  <done>
- Subscribe is a tRPC mutation (api/subscribe route deleted)
- Verify page reads ?token and does verification directly (api/verify route deleted)
- Unsubscribe page reads ?token and does unsubscribe directly (api/unsubscribe GET deleted)
- POST /api/unsubscribe kept for RFC 8058 one-click
- All routes/pages use BETTER_AUTH_SECRET for token signing
- SubscriberTokenSecret removed from infra/secrets.ts
- SUBSCRIBER_TOKEN_SECRET removed from api.ts, web.ts, .env.example files
- SES_FROM_EMAIL uses real domain in dev mode
- All tests pass with `pnpm test`
  </done>
</task>

</tasks>

<verification>
After both tasks complete, run the full verification:

1. `pnpm install` -- lockfile updated
2. `pnpm db:start && pnpm test` -- all tests pass
3. `pnpm check` -- no formatting/lint errors
4. `grep -r "SUBSCRIBER_TOKEN_SECRET" --include="*.ts" --include="*.tsx" --include="*.example"` -- zero results
5. `grep -r "EmailServiceAuto" --include="*.ts"` -- zero results
6. Verify `apps/web/src/app/api/subscribe/` directory is deleted or empty
7. Verify `apps/web/src/app/api/verify/` directory is deleted or empty
8. Verify tRPC subscriber router is registered in appRouter
</verification>

<success_criteria>
- Subscribe flow works via tRPC mutation
- Verify and unsubscribe flows work via server component pages
- RFC 8058 POST /api/unsubscribe still works
- No SUBSCRIBER_TOKEN_SECRET references remain anywhere
- SES_FROM_EMAIL is always the real domain
- Infra config is clean (no orphaned secrets)
- All tests pass end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/02-email-infrastructure/02-07-SUMMARY.md`
</output>
