---
phase: 02-email-infrastructure
plan: 07
type: execute
wave: 7
depends_on: ["02-06"]
files_modified:
  - packages/api/src/routers/subscriber.ts
  - packages/api/src/routers/index.ts
  - packages/api/package.json
  - apps/web/src/app/verify/page.tsx
  - apps/web/src/app/unsubscribe/page.tsx
  - apps/web/src/app/api/unsubscribe/route.ts
  - apps/web/src/app/api/unsubscribe/route.test.ts
  - apps/web/src/app/api/subscribe/route.ts
  - apps/web/src/app/api/subscribe/route.test.ts
  - apps/web/src/app/api/verify/route.ts
  - apps/web/src/app/api/verify/route.test.ts
  - apps/web/src/lib/email-layers.ts
  - infra/secrets.ts
  - infra/api.ts
  - infra/web.ts
  - apps/web/.env.example
  - apps/server/.env.example
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Subscribe uses a tRPC mutation (not a Next.js route handler)"
    - "Verify page reads ?token from searchParams and does verification directly as a server component"
    - "Unsubscribe page reads ?token from searchParams and does unsubscribe directly as a server component"
    - "POST /api/unsubscribe still works for RFC 8058 one-click email client unsubscribe"
    - "No GET /api/subscribe, GET /api/verify, or GET /api/unsubscribe routes exist"
    - "Token signing uses BETTER_AUTH_SECRET (not SUBSCRIBER_TOKEN_SECRET)"
    - "email-layers.ts uses env package for layer selection (not raw process.env)"
    - "SubscriberTokenSecret removed from SST infra"
    - "SES_FROM_EMAIL uses real domain in sst dev mode"
    - "All tests pass with pnpm db:start && pnpm test"
  artifacts:
    - path: "packages/api/src/routers/subscriber.ts"
      provides: "tRPC subscriber router with subscribe mutation"
      exports: ["subscriberRouter"]
    - path: "packages/api/src/routers/index.ts"
      provides: "App router with subscriber sub-router"
      contains: "subscriberRouter"
    - path: "apps/web/src/app/verify/page.tsx"
      provides: "Server component that verifies token directly"
      contains: "verifyToken"
    - path: "apps/web/src/app/unsubscribe/page.tsx"
      provides: "Server component that unsubscribes directly"
      contains: "verifyToken"
    - path: "apps/web/src/app/api/unsubscribe/route.ts"
      provides: "POST-only route for RFC 8058"
      exports: ["POST"]
    - path: "apps/web/src/lib/email-layers.ts"
      provides: "Layer composition using env package"
      contains: "makeEmailServiceLive"
  key_links:
    - from: "packages/api/src/routers/subscriber.ts"
      to: "packages/core/src/email/subscriber.service.ts"
      via: "tRPC mutation calls SubscriberServiceTag"
      pattern: "SubscriberServiceTag"
    - from: "apps/web/src/app/verify/page.tsx"
      to: "packages/core/src/email/token.ts"
      via: "Server component calls verifyToken with BETTER_AUTH_SECRET"
      pattern: "verifyToken.*BETTER_AUTH_SECRET"
    - from: "apps/web/src/lib/email-layers.ts"
      to: "packages/core/src/email/email.service.ts"
      via: "Uses makeEmailServiceLive factory"
      pattern: "makeEmailServiceLive"
    - from: "apps/web/src/app/api/unsubscribe/route.ts"
      to: "packages/core/src/email/token.ts"
      via: "POST handler uses verifyToken for RFC 8058"
      pattern: "verifyToken"
---

<objective>
Replace Next.js API routes with tRPC router and server component pages, fix infra config, and clean up SUBSCRIBER_TOKEN_SECRET references.

Purpose: Address code review items for architectural changes (Next.js routes -> tRPC/server components), infra config fixes, and complete removal of SUBSCRIBER_TOKEN_SECRET from all layers.

**Code review item mapping:**
- Items 4, 5 -- Task 1 (subscribe moves from Next.js route to tRPC mutation)
- Item 7 -- Task 2 (unsubscribe moves from Next.js route to server component page + POST-only API for RFC 8058)
- Item 8 -- Task 2 (SES_FROM_EMAIL uses real domain in $dev mode)
- Items 2, 6, 9 (infra side) -- Task 2 (SubscriberTokenSecret removed from SST secrets, api.ts, web.ts, .env.example files)
- Item 12 (app layer side) -- Task 1 (email-layers.ts uses env package, not raw process.env)

Output: New tRPC subscriber router, refactored verify/unsubscribe pages, cleaned up API routes, fixed infra config, updated tests.
</objective>

<execution_context>
@/home/lima/.claude/get-shit-done/workflows/execute-plan.md
@/home/lima/.claude/get-shit-done/templates/summary.md
</execution_context>

<skills>
Use `/effect-ts` skill before writing ANY Effect code -- tRPC mutation handlers, server
component Effect pipelines, layer composition, etc. It has correct APIs for Effect.gen,
Layer.mergeAll, Effect.provide, Effect.catchTag, Effect.either, Effect.runPromise, etc.

Use `/vercel-react-best-practices` skill when writing the verify/unsubscribe server
component pages -- ensure proper Next.js 15 patterns for async server components,
searchParams handling, and data fetching.
</skills>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/phases/02-email-infrastructure/02-06-SUMMARY.md

@packages/api/src/routers/index.ts
@packages/api/src/index.ts
@packages/api/package.json
@apps/web/src/app/verify/page.tsx
@apps/web/src/app/unsubscribe/page.tsx
@apps/web/src/app/api/unsubscribe/route.ts
@apps/web/src/app/api/subscribe/route.ts
@apps/web/src/app/api/verify/route.ts
@apps/web/src/lib/email-layers.ts
@infra/secrets.ts
@infra/api.ts
@infra/web.ts
@apps/web/.env.example
@apps/server/.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tRPC subscriber router and update email-layers</name>
  <files>
    packages/api/src/routers/subscriber.ts
    packages/api/src/routers/index.ts
    packages/api/package.json
    apps/web/src/lib/email-layers.ts
  </files>
  <action>
**Code review items addressed: 4, 5, 12 (app layer side)**

**packages/api/package.json (item 4 prerequisite)**: Add `effect` and `@gemhog/env` as dependencies:
```json
"effect": "catalog:",
"@gemhog/env": "workspace:*"
```

**packages/api/src/routers/subscriber.ts (items 4, 5)**: Create a new tRPC router for subscriber operations. This replaces the POST /api/subscribe Next.js route. The user explicitly said "we should use trpc endpoint not next route" (item 4) and "we dont use nextjs routes. we have a trpc endpoint and should make a router for subscriber" (item 5).

Architecture approach: The tRPC subscriber router imports and uses EmailLayers directly. The `@gemhog/api` package already depends on `@gemhog/core`, so it can access DatabaseLive and email services.

```typescript
import {
  createToken,
  EmailServiceTag,
  SubscriberServiceTag,
  SubscriberServiceLive,
  EmailServiceConsole,
  makeEmailServiceLive,
  verificationEmail,
} from "@gemhog/core/email";
import { DatabaseLive } from "@gemhog/core/drizzle";
import { env } from "@gemhog/env/server";
import { Effect, Layer } from "effect";
import { z } from "zod";

import { publicProcedure, router } from "../index";

const EmailLayers = Layer.mergeAll(
  env.SES_FROM_EMAIL
    ? makeEmailServiceLive(env.SES_FROM_EMAIL)
    : EmailServiceConsole,
  SubscriberServiceLive.pipe(Layer.provide(DatabaseLive)),
);

export const subscriberRouter = router({
  subscribe: publicProcedure
    .input(z.object({ email: z.string().email() }))
    .mutation(async ({ input }) => {
      const { email } = input;
      const secret = env.BETTER_AUTH_SECRET;
      const appUrl = env.APP_URL;

      const program = Effect.gen(function* () {
        const subscriberService = yield* SubscriberServiceTag;
        const emailService = yield* EmailServiceTag;

        const result = yield* subscriberService.subscribe(email);

        const sub = yield* subscriberService.findByEmail(email);
        const shouldSendEmail = result.isNew || sub?.status === "pending";

        if (shouldSendEmail) {
          const token = yield* createToken(
            {
              email,
              action: "verify",
              expiresAt: Date.now() + 7 * 24 * 60 * 60 * 1000,
            },
            secret,
          );

          const unsubscribeToken = yield* createToken(
            {
              email,
              action: "unsubscribe",
              expiresAt: Date.now() + 365 * 24 * 60 * 60 * 1000,
            },
            secret,
          );

          const verifyUrl = `${appUrl}/verify?token=${token}`;
          const unsubscribeUrl = `${appUrl}/api/unsubscribe?token=${unsubscribeToken}`;
          const { subject, html } = verificationEmail({ verifyUrl });

          yield* emailService.send({
            to: email,
            subject,
            html,
            headers: {
              "List-Unsubscribe": `<${unsubscribeUrl}>`,
              "List-Unsubscribe-Post": "List-Unsubscribe=One-Click",
            },
          });
        }
      });

      await Effect.runPromise(program.pipe(Effect.provide(EmailLayers)));

      return {
        message: "Check your email to confirm your subscription",
      };
    }),
});
```

Note: `verifyUrl` points to `/verify?token=...` (the page, not `/api/verify`). `unsubscribeUrl` still points to `/api/unsubscribe?token=...` for RFC 8058 POST support from email clients.

**packages/api/src/routers/index.ts (item 5)**: Import and merge the subscriber router:

```typescript
import { protectedProcedure, publicProcedure, router } from "../index";
import { subscriberRouter } from "./subscriber";

export const appRouter = router({
  healthCheck: publicProcedure.query(() => {
    return "OK";
  }),
  privateData: protectedProcedure.query(({ ctx }) => {
    return {
      message: "This is private",
      user: ctx.session.user,
    };
  }),
  subscriber: subscriberRouter,
});
export type AppRouter = typeof appRouter;
```

**apps/web/src/lib/email-layers.ts (item 12 -- app layer side)**: Update to use env package and makeEmailServiceLive factory. This replaces raw `process.env` with the typed env package:

```typescript
import { DatabaseLive } from "@gemhog/core/drizzle";
import {
  EmailServiceConsole,
  makeEmailServiceLive,
  SubscriberServiceLive,
} from "@gemhog/core/email";
import { env } from "@gemhog/env/server";
import { Layer } from "effect";

export const EmailLayers = Layer.mergeAll(
  env.SES_FROM_EMAIL
    ? makeEmailServiceLive(env.SES_FROM_EMAIL)
    : EmailServiceConsole,
  SubscriberServiceLive.pipe(Layer.provide(DatabaseLive)),
);
```

This replaces raw `process.env` with the typed env package and uses `makeEmailServiceLive` factory from plan 02-06.
  </action>
  <verify>
Run `pnpm check` to verify the new files pass formatting and linting.
Verify `packages/api/src/routers/subscriber.ts` exports `subscriberRouter`.
Verify `packages/api/src/routers/index.ts` includes `subscriber: subscriberRouter`.
  </verify>
  <done>
- tRPC subscriber router exists with subscribe mutation [items 4, 5]
- App router includes subscriber sub-router
- email-layers.ts uses env package and makeEmailServiceLive factory [item 12 app layer]
- @gemhog/api package.json has effect and @gemhog/env dependencies
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert verify/unsubscribe pages to server components, clean up routes and infra</name>
  <files>
    apps/web/src/app/verify/page.tsx
    apps/web/src/app/unsubscribe/page.tsx
    apps/web/src/app/api/unsubscribe/route.ts
    apps/web/src/app/api/unsubscribe/route.test.ts
    apps/web/src/app/api/subscribe/route.ts
    apps/web/src/app/api/subscribe/route.test.ts
    apps/web/src/app/api/verify/route.ts
    apps/web/src/app/api/verify/route.test.ts
    infra/secrets.ts
    infra/api.ts
    infra/web.ts
    apps/web/.env.example
    apps/server/.env.example
  </files>
  <action>
**Code review items addressed: 7, 8, and infra side of items 2, 6, 9**

**apps/web/src/app/verify/page.tsx (item 7 -- related, verify follows same pattern as unsubscribe)**: Convert from reading `?status` (redirected from API route) to reading `?token` and doing verification directly as a server component.

The page should:
1. Read `token` from searchParams (it's a server component, searchParams is a Promise in Next.js 15)
2. If no token, show the error/invalid state
3. If token exists, run the verification Effect pipeline directly:
   - Use `verifyToken(token, env.BETTER_AUTH_SECRET)` from core
   - Use `SubscriberServiceTag.verify(payload.email)`
   - Provide EmailLayers
   - Catch InvalidTokenError to determine expired vs invalid
   - Catch all other errors as generic error
4. Render the appropriate UI based on the result

```tsx
import { env } from "@gemhog/env/server";
import {
  SubscriberServiceTag,
  verifyToken,
} from "@gemhog/core/email";
import { Effect } from "effect";
import Link from "next/link";

import { EmailLayers } from "@/lib/email-layers";

type VerifyStatus = "success" | "expired" | "invalid" | "error";

async function getVerifyStatus(token: string): Promise<VerifyStatus> {
  const program = Effect.gen(function* () {
    const subscriberService = yield* SubscriberServiceTag;
    const payload = yield* verifyToken(token, env.BETTER_AUTH_SECRET);
    yield* subscriberService.verify(payload.email);
    return "success" as VerifyStatus;
  }).pipe(
    Effect.catchTag("InvalidTokenError", (error) =>
      Effect.succeed(
        (error.reason === "expired" ? "expired" : "invalid") as VerifyStatus,
      ),
    ),
    Effect.catchAll(() => Effect.succeed("error" as VerifyStatus)),
  );

  return Effect.runPromise(program.pipe(Effect.provide(EmailLayers)));
}

// Keep existing SuccessContent, ExpiredContent, InvalidContent, ErrorContent components.
// Update the page component:

export default async function VerifyPage({
  searchParams,
}: {
  searchParams: Promise<{ token?: string }>;
}) {
  const { token } = await searchParams;

  const status = token ? await getVerifyStatus(token) : "invalid";

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-50 px-4">
      <div className="w-full max-w-md rounded-lg border border-gray-200 bg-white p-8 text-center shadow-sm">
        {status === "success" && <SuccessContent />}
        {status === "expired" && <ExpiredContent />}
        {status === "invalid" && <InvalidContent />}
        {status === "error" && <ErrorContent />}
      </div>
    </div>
  );
}
```

Note: Remove the `form action="/api/subscribe"` from ExpiredContent since subscribe is now tRPC. Replace with a simple "Go back to sign up" link or just a link to home. The re-signup form would use tRPC in the landing page (Phase 4).

**apps/web/src/app/unsubscribe/page.tsx (item 7)**: Same pattern as verify -- read `?token` and do unsubscribe directly as a server component.

```tsx
import { env } from "@gemhog/env/server";
import {
  SubscriberServiceTag,
  verifyToken,
} from "@gemhog/core/email";
import { Effect } from "effect";
import Link from "next/link";

import { EmailLayers } from "@/lib/email-layers";

type UnsubscribeStatus = "success" | "invalid" | "error";

async function getUnsubscribeStatus(token: string): Promise<UnsubscribeStatus> {
  const program = Effect.gen(function* () {
    const subscriberService = yield* SubscriberServiceTag;
    const payload = yield* verifyToken(token, env.BETTER_AUTH_SECRET);
    yield* subscriberService.unsubscribe(payload.email);
    return "success" as UnsubscribeStatus;
  }).pipe(
    Effect.catchTag("InvalidTokenError", () =>
      Effect.succeed("invalid" as UnsubscribeStatus),
    ),
    Effect.catchAll(() => Effect.succeed("error" as UnsubscribeStatus)),
  );

  return Effect.runPromise(program.pipe(Effect.provide(EmailLayers)));
}

// Keep existing SuccessContent, InvalidContent, ErrorContent components.
// Update the page component to read token, not status.
```

**apps/web/src/app/api/subscribe/route.ts (items 4, 5)**: DELETE this file entirely. Subscribe is now a tRPC mutation.

**apps/web/src/app/api/subscribe/route.test.ts**: DELETE this file entirely. Tests for subscribe belong with the tRPC router.

**apps/web/src/app/api/verify/route.ts**: DELETE this file entirely. Verify is now handled by the page server component.

**apps/web/src/app/api/verify/route.test.ts**: DELETE this file entirely.

**apps/web/src/app/api/unsubscribe/route.ts (item 7)**: Keep ONLY the POST handler for RFC 8058. Remove the GET handler. Update to use `env.BETTER_AUTH_SECRET` instead of SUBSCRIBER_TOKEN_SECRET:

```typescript
import {
  SubscriberServiceTag,
  verifyToken,
} from "@gemhog/core/email";
import { env } from "@gemhog/env/server";
import { Effect } from "effect";
import { type NextRequest, NextResponse } from "next/server";

import { EmailLayers } from "@/lib/email-layers";

export async function POST(request: NextRequest) {
  const token = request.nextUrl.searchParams.get("token");

  if (!token) {
    return NextResponse.json({ error: "Missing token" }, { status: 400 });
  }

  const program = Effect.gen(function* () {
    const subscriberService = yield* SubscriberServiceTag;
    const payload = yield* verifyToken(token, env.BETTER_AUTH_SECRET);
    yield* subscriberService.unsubscribe(payload.email);
  }).pipe(
    Effect.catchTag("InvalidTokenError", () => Effect.fail("invalid" as const)),
    Effect.catchAll(() => Effect.fail("error" as const)),
  );

  const result = await Effect.runPromise(
    program.pipe(
      Effect.provide(EmailLayers),
      Effect.either,
    ),
  );

  if (result._tag === "Right") {
    return NextResponse.json({ message: "Unsubscribed successfully" });
  }
  if (result.left === "invalid") {
    return NextResponse.json(
      { error: "Invalid or expired link" },
      { status: 400 },
    );
  }
  return NextResponse.json({ error: "Something went wrong" }, { status: 500 });
}
```

**apps/web/src/app/api/unsubscribe/route.test.ts**: Update to test only POST (remove GET tests). Update to use `BETTER_AUTH_SECRET` instead of `SUBSCRIBER_TOKEN_SECRET` in vi.stubEnv. Import only `POST` (not `GET`).

**infra/secrets.ts (item 9 -- infra side)**: Remove the `SubscriberTokenSecret` line:
```typescript
export const secrets = {
  DatabaseUrl: new sst.Secret("DatabaseUrl"),
  DatabaseUrlPooler: new sst.Secret("DatabaseUrlPooler"),
  BetterAuthSecret: new sst.Secret("BetterAuthSecret"),
  GoogleApiKey: new sst.Secret("GoogleApiKey"),
  CloudflareZoneId: new sst.Secret("CloudflareZoneId"),
  // Sentry error monitoring
  SentryDsn: new sst.Secret("SentryDsn"),
  SentryAuthToken: new sst.Secret("SentryAuthToken"),
  SentryOrg: new sst.Secret("SentryOrg"),
  SentryProject: new sst.Secret("SentryProject"),
};
```

**infra/api.ts (items 8, 9)**: Two changes:
1. Remove `SUBSCRIBER_TOKEN_SECRET: secrets.SubscriberTokenSecret.value` line.
2. Fix `SES_FROM_EMAIL` (item 8): In `$dev` mode, use the real domain. The user said "in sst dev we should still use real domain. $dev means running in sst dev". Change:
   ```
   SES_FROM_EMAIL: $dev ? "" : "hello@gemhog.com"
   ```
   to:
   ```
   SES_FROM_EMAIL: "hello@gemhog.com"
   ```
   Same value for both dev and prod.

**infra/web.ts (items 8, 9)**: Remove `SUBSCRIBER_TOKEN_SECRET: secrets.SubscriberTokenSecret.value` line. Apply the same SES_FROM_EMAIL fix as api.ts -- use `"hello@gemhog.com"` unconditionally.

**apps/web/.env.example (items 2, 6)**: Remove the SUBSCRIBER_TOKEN_SECRET lines (both the comment and the commented-out value).

**apps/server/.env.example (items 2, 6)**: Remove the SUBSCRIBER_TOKEN_SECRET lines (both the comment and the commented-out value).

After all file changes, run `pnpm install` to update the lockfile (since packages/api/package.json changed).
  </action>
  <verify>
Run `pnpm install` to update lockfile.
Run `pnpm db:start && pnpm test` -- ALL tests must pass.
Run `pnpm check` -- no formatting or lint errors.

Verify deleted files:
- `apps/web/src/app/api/subscribe/route.ts` does NOT exist
- `apps/web/src/app/api/subscribe/route.test.ts` does NOT exist
- `apps/web/src/app/api/verify/route.ts` does NOT exist
- `apps/web/src/app/api/verify/route.test.ts` does NOT exist

Verify remaining files:
- `apps/web/src/app/api/unsubscribe/route.ts` exports only POST (no GET)
- `apps/web/src/app/verify/page.tsx` contains `verifyToken` and `BETTER_AUTH_SECRET`
- `apps/web/src/app/unsubscribe/page.tsx` contains `verifyToken` and `BETTER_AUTH_SECRET`
- `infra/secrets.ts` has no `SubscriberTokenSecret`
- `infra/api.ts` has no `SUBSCRIBER_TOKEN_SECRET` and SES_FROM_EMAIL is `"hello@gemhog.com"` unconditionally
- `infra/web.ts` has no `SUBSCRIBER_TOKEN_SECRET`
- No `.env.example` file mentions SUBSCRIBER_TOKEN_SECRET

Grep across repo: `grep -r "SUBSCRIBER_TOKEN_SECRET" --include="*.ts" --include="*.tsx" --include="*.example"` should return 0 results.
  </verify>
  <done>
- Subscribe is a tRPC mutation (api/subscribe route deleted) [items 4, 5]
- Verify page reads ?token and does verification directly (api/verify route deleted)
- Unsubscribe page reads ?token and does unsubscribe directly (api/unsubscribe GET deleted) [item 7]
- POST /api/unsubscribe kept for RFC 8058 one-click
- All routes/pages use BETTER_AUTH_SECRET for token signing
- SubscriberTokenSecret removed from infra/secrets.ts [item 9]
- SUBSCRIBER_TOKEN_SECRET removed from api.ts, web.ts, .env.example files [items 2, 6]
- SES_FROM_EMAIL uses real domain in dev mode [item 8]
- All tests pass with `pnpm db:start && pnpm test`
  </done>
</task>

</tasks>

<verification>
After both tasks complete, run the full verification:

1. `pnpm install` -- lockfile updated
2. `pnpm db:start && pnpm test` -- all tests pass (unit, integration, e2e)
3. `pnpm check` -- no formatting/lint errors
4. `grep -r "SUBSCRIBER_TOKEN_SECRET" --include="*.ts" --include="*.tsx" --include="*.example"` -- zero results
5. `grep -r "EmailServiceAuto" --include="*.ts"` -- zero results
6. Verify `apps/web/src/app/api/subscribe/` directory is deleted or empty
7. Verify `apps/web/src/app/api/verify/` directory is deleted or empty
8. Verify tRPC subscriber router is registered in appRouter
9. Verify `infra/api.ts` SES_FROM_EMAIL is `"hello@gemhog.com"` (no conditional)
10. Verify `infra/web.ts` SES_FROM_EMAIL is `"hello@gemhog.com"` (no conditional)
</verification>

<success_criteria>
- Subscribe flow works via tRPC mutation
- Verify and unsubscribe flows work via server component pages
- RFC 8058 POST /api/unsubscribe still works
- No SUBSCRIBER_TOKEN_SECRET references remain anywhere
- SES_FROM_EMAIL is always the real domain (no empty string in dev)
- Infra config is clean (no orphaned secrets)
- All tests pass end-to-end (pnpm db:start && pnpm test)
</success_criteria>

<output>
After completion, create `.planning/phases/02-email-infrastructure/02-07-SUMMARY.md`
</output>
