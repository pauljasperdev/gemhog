---
phase: 02-email-infrastructure
plan: 08
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/api/src/routers/subscriber.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "tRPC subscribe mutation is tested with mock services"
    - "Subscribe mutation returns expected success message"
    - "Subscribe mutation calls subscriberService.subscribe and emailService.send for new subscribers"
    - "Subscribe mutation handles pending subscribers by re-sending verification email"
  artifacts:
    - path: "packages/api/src/routers/subscriber.test.ts"
      provides: "Unit tests for subscriber tRPC router"
      min_lines: 50
  key_links:
    - from: "subscriber.test.ts"
      to: "subscriber.ts"
      via: "createCallerFactory + appRouter"
      pattern: "caller\\.subscriber\\.subscribe"
---

<objective>
Add unit tests for the tRPC subscriber router `subscribe` mutation to close the high-severity test coverage gap.

Purpose: Plan 02-07 introduced the tRPC subscriber router but deleted old `POST /api/subscribe` tests without replacement. This gap closure adds tests for the `subscribe` mutation covering: successful subscription with email sending, re-subscription of pending users, and correct return message.

Output: `packages/api/src/routers/subscriber.test.ts` with unit tests
</objective>

<execution_context>
@/home/lima/.claude/get-shit-done/workflows/execute-plan.md
@/home/lima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/codebase/TESTING.md
@.planning/codebase/CONVENTIONS.md

@packages/api/src/routers/subscriber.ts
@packages/api/src/routers/index.ts
@packages/api/src/index.ts
@packages/api/src/routers/procedures.int.test.ts
@packages/core/src/email/email.mock.ts
@packages/core/src/email/email.errors.ts
@packages/core/src/email/token.ts
@packages/core/src/email/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create subscriber router unit tests</name>
  <files>packages/api/src/routers/subscriber.test.ts</files>
  <action>
Create `packages/api/src/routers/subscriber.test.ts` with unit tests for the `subscribe` mutation.

**Mocking strategy (CRITICAL — follow this exactly):**

1. Mock `@gemhog/env/server` BEFORE any imports that transitively load it (same pattern as `procedures.int.test.ts`):

```typescript
vi.mock("@gemhog/env/server", () => ({
  env: {
    BETTER_AUTH_SECRET: "test-secret-at-least-32-characters-long",
    APP_URL: "http://localhost:3001",
    DATABASE_URL: "postgresql://localhost/test",
    DATABASE_URL_POOLER: "postgresql://localhost/test",
    BETTER_AUTH_URL: "http://localhost:3001",
    GOOGLE_GENERATIVE_AI_API_KEY: "test-key",
  },
}));
```

2. Mock `@gemhog/core/drizzle` to prevent real DB connection:

```typescript
vi.mock("@gemhog/core/drizzle", () => ({
  DatabaseLive: Layer.empty,
}));
```

3. Mock `@gemhog/core/email` to provide mock services instead of real ones. The key is that `getEmailLayers()` in `subscriber.ts` constructs layers using these imports. We need to replace them with mocks:

```typescript
vi.mock("@gemhog/core/email", async () => {
  const { Effect, Layer, Context } = await import("effect");

  // Create tags
  const EmailServiceTag = Context.GenericTag("EmailServiceTag");
  const SubscriberServiceTag = Context.GenericTag("SubscriberServiceTag");

  // Track calls for assertions
  const sendCalls: unknown[] = [];
  const subscribeCalls: string[] = [];

  const MockEmailLayer = Layer.succeed(EmailServiceTag, {
    send: (params) => {
      sendCalls.push(params);
      return Effect.void;
    },
  });

  const MockSubscriberLayer = Layer.succeed(SubscriberServiceTag, {
    subscribe: (email) => {
      subscribeCalls.push(email);
      return Effect.succeed({ id: "mock-id", isNew: true });
    },
    verify: (_email) => Effect.void,
    unsubscribe: (_email) => Effect.void,
    findByEmail: (_email) => Effect.succeed({ id: "mock-id", email: _email, status: "pending" }),
  });

  return {
    EmailServiceTag,
    SubscriberServiceTag,
    EmailServiceConsole: MockEmailLayer,
    makeEmailServiceLive: () => MockEmailLayer,
    SubscriberServiceLive: MockSubscriberLayer,
    createToken: () => Effect.succeed("mock-token"),
    verificationEmail: () => ({ subject: "Verify", html: "<p>Verify</p>" }),
    _sendCalls: sendCalls,
    _subscribeCalls: subscribeCalls,
  };
});
```

IMPORTANT: The `_sendCalls` and `_subscribeCalls` arrays are exported from the mock so tests can inspect what was called. Import them in tests via `await import("@gemhog/core/email")`.

4. After all mocks, import the router and create the caller:

```typescript
import { Layer } from "effect";
import { t } from "../index";
import { appRouter } from "./index";

const createCaller = t.createCallerFactory(appRouter);
```

**Test cases (describe "subscriberRouter" > describe "subscribe mutation"):**

1. `it("should return success message for valid email")` — Call `caller.subscriber.subscribe({ email: "test@example.com" })`, expect result to have `message: "Check your email to confirm your subscription"`.

2. `it("should call subscriberService.subscribe with the email")` — After calling the mutation, check that `_subscribeCalls` includes the email.

3. `it("should send verification email for new subscriber")` — After calling the mutation with a new subscriber, check that `_sendCalls` has length > 0 and the email `to` field matches.

4. `it("should reject invalid email")` — Call with `{ email: "not-an-email" }`, expect it to throw/reject (Zod validation).

**Style notes:**
- Use `describe/it/expect` from vitest
- Double quotes, 2-space indent, semicolons
- Follow import order: external -> internal packages -> relative -> types
- Reset tracked call arrays in `beforeEach` using the imported mock references
  </action>
  <verify>
Run: `cd /home/lima/repo && npx vitest run --project @gemhog/api -- packages/api/src/routers/subscriber.test.ts`

All tests should pass. Expect 4 test cases.
  </verify>
  <done>
- subscriber.test.ts exists with 4+ passing tests
- Tests cover: success response, service calls, email sending, input validation
- Tests use mock services (no real DB or email)
- `pnpm test` passes with the new tests included
  </done>
</task>

<task type="auto">
  <name>Task 2: Run full test suite to verify no regressions</name>
  <files></files>
  <action>
Run `pnpm test` from the repo root to verify:
1. The new subscriber.test.ts tests pass
2. All existing tests still pass
3. No regressions introduced

If any test fails, fix the issue in subscriber.test.ts (do NOT modify existing tests or source code).
  </action>
  <verify>
`pnpm test` exits with code 0. All unit, integration, and static analysis pass.
  </verify>
  <done>
- `pnpm test` passes completely
- New tests are included in the test run output
- No test regressions
  </done>
</task>

</tasks>

<verification>
1. `packages/api/src/routers/subscriber.test.ts` exists and contains test cases
2. Tests cover the `subscribe` mutation: success path, service calls, email sending, input validation
3. `pnpm test` passes (full pipeline including new tests)
4. No modifications to existing source files (gap closure = add tests only)
</verification>

<success_criteria>
- The tRPC subscriber router `subscribe` mutation has unit test coverage
- Tests use mocked services (no DB or SES dependency)
- All test cases pass
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/02-email-infrastructure/02-08-SUMMARY.md`
</output>
