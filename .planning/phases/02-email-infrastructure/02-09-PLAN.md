---
phase: 02-email-infrastructure
plan: 09
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/app/verify/page.tsx
  - apps/web/src/app/verify/verify-status.ts
  - apps/web/src/app/verify/verify-status.test.ts
  - apps/web/src/app/unsubscribe/page.tsx
  - apps/web/src/app/unsubscribe/unsubscribe-status.ts
  - apps/web/src/app/unsubscribe/unsubscribe-status.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "getVerifyStatus returns 'success' for valid token with successful verification"
    - "getVerifyStatus returns 'expired' for expired token"
    - "getVerifyStatus returns 'invalid' for malformed or bad-signature token"
    - "getVerifyStatus returns 'error' for unexpected failures"
    - "getUnsubscribeStatus returns 'success' for valid token with successful unsubscribe"
    - "getUnsubscribeStatus returns 'invalid' for expired/malformed/bad-signature token"
    - "getUnsubscribeStatus returns 'error' for unexpected failures"
  artifacts:
    - path: "apps/web/src/app/verify/verify-status.ts"
      provides: "Exported getVerifyStatus function"
      exports: ["getVerifyStatus"]
    - path: "apps/web/src/app/verify/verify-status.test.ts"
      provides: "Unit tests for verify status logic"
      min_lines: 40
    - path: "apps/web/src/app/unsubscribe/unsubscribe-status.ts"
      provides: "Exported getUnsubscribeStatus function"
      exports: ["getUnsubscribeStatus"]
    - path: "apps/web/src/app/unsubscribe/unsubscribe-status.test.ts"
      provides: "Unit tests for unsubscribe status logic"
      min_lines: 40
  key_links:
    - from: "verify-status.test.ts"
      to: "verify-status.ts"
      via: "direct import of getVerifyStatus"
      pattern: "import.*getVerifyStatus"
    - from: "unsubscribe-status.test.ts"
      to: "unsubscribe-status.ts"
      via: "direct import of getUnsubscribeStatus"
      pattern: "import.*getUnsubscribeStatus"
    - from: "verify/page.tsx"
      to: "verify-status.ts"
      via: "import getVerifyStatus"
      pattern: "import.*getVerifyStatus.*verify-status"
    - from: "unsubscribe/page.tsx"
      to: "unsubscribe-status.ts"
      via: "import getUnsubscribeStatus"
      pattern: "import.*getUnsubscribeStatus.*unsubscribe-status"
---

<objective>
Extract and test the `getVerifyStatus` and `getUnsubscribeStatus` logic functions from server component pages to close medium-severity test coverage gaps.

Purpose: Plan 02-07 introduced these status-mapping functions inside server component pages, but they were never tested. The functions contain critical token-to-status mapping logic (success/expired/invalid/error). Extracting them into separate modules enables direct unit testing without testing React rendering.

Output: Extracted logic modules + unit tests for both verify and unsubscribe status functions
</objective>

<execution_context>
@/home/lima/.claude/get-shit-done/workflows/execute-plan.md
@/home/lima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/codebase/TESTING.md
@.planning/codebase/CONVENTIONS.md

@apps/web/src/app/verify/page.tsx
@apps/web/src/app/unsubscribe/page.tsx
@apps/web/src/lib/email-layers.ts
@packages/core/src/email/email.mock.ts
@packages/core/src/email/email.errors.ts
@packages/core/src/email/token.ts
@packages/core/src/email/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract and test getVerifyStatus</name>
  <files>
    apps/web/src/app/verify/verify-status.ts
    apps/web/src/app/verify/verify-status.test.ts
    apps/web/src/app/verify/page.tsx
  </files>
  <action>
**Step 1: Create `apps/web/src/app/verify/verify-status.ts`**

Extract the `getVerifyStatus` function and its type from `page.tsx` into a separate module:

```typescript
import { SubscriberServiceTag, verifyToken } from "@gemhog/core/email";
import { env } from "@gemhog/env/server";
import { Effect, Layer } from "effect";

import { EmailLayers } from "@/lib/email-layers";

export type VerifyStatus = "success" | "expired" | "invalid" | "error";

export async function getVerifyStatus(token: string): Promise<VerifyStatus> {
  const program = Effect.gen(function* () {
    const subscriberService = yield* SubscriberServiceTag;
    const payload = yield* verifyToken(token, env.BETTER_AUTH_SECRET);
    yield* subscriberService.verify(payload.email);
    return "success" as VerifyStatus;
  }).pipe(
    Effect.catchTag("InvalidTokenError", (error) =>
      Effect.succeed(
        (error.reason === "expired" ? "expired" : "invalid") as VerifyStatus,
      ),
    ),
    Effect.catchAll(() => Effect.succeed("error" as VerifyStatus)),
  );

  return Effect.runPromise(program.pipe(Effect.provide(EmailLayers)));
}
```

**Step 2: Update `apps/web/src/app/verify/page.tsx`**

Replace the inline `getVerifyStatus` function and `VerifyStatus` type with an import from the new module:

- Remove the `VerifyStatus` type definition
- Remove the `getVerifyStatus` function
- Remove imports only used by the extracted function (keep `Link` and any React-specific imports)
- Add: `import { getVerifyStatus, type VerifyStatus } from "./verify-status";`
- Keep all component functions (SuccessContent, ExpiredContent, InvalidContent, ErrorContent) and the default export exactly as-is
- Note: The import of `SubscriberServiceTag`, `verifyToken` from `@gemhog/core/email`, `env` from `@gemhog/env/server`, `Effect` from `effect`, and `EmailLayers` from `@/lib/email-layers` can be removed from page.tsx since they move to verify-status.ts. Only keep what page.tsx still uses directly.

**Step 3: Create `apps/web/src/app/verify/verify-status.test.ts`**

Mock strategy — mock BEFORE imports:

```typescript
vi.mock("@gemhog/env/server", () => ({
  env: {
    BETTER_AUTH_SECRET: "test-secret-at-least-32-characters-long",
    APP_URL: "http://localhost:3001",
    DATABASE_URL: "postgresql://localhost/test",
    DATABASE_URL_POOLER: "postgresql://localhost/test",
    BETTER_AUTH_URL: "http://localhost:3001",
    GOOGLE_GENERATIVE_AI_API_KEY: "test-key",
  },
}));
```

Mock `@/lib/email-layers` to provide mock Effect layers (NOT real DB layers):

```typescript
vi.mock("@/lib/email-layers", async () => {
  const { Effect, Layer, Context } = await import("effect");
  const SubscriberServiceTag = Context.GenericTag("SubscriberServiceTag");
  const EmailServiceTag = Context.GenericTag("EmailServiceTag");
  return {
    EmailLayers: Layer.mergeAll(
      Layer.succeed(SubscriberServiceTag, {
        subscribe: () => Effect.succeed({ id: "mock-id", isNew: true }),
        verify: () => Effect.void,
        unsubscribe: () => Effect.void,
        findByEmail: () => Effect.succeed(null),
      }),
      Layer.succeed(EmailServiceTag, {
        send: () => Effect.void,
      }),
    ),
  };
});
```

IMPORTANT: The `SubscriberServiceTag` and `EmailServiceTag` in the mock MUST use the same `Context.GenericTag` string identifier as the real ones. Check `packages/core/src/email/subscriber.service.ts` and `packages/core/src/email/email.service.ts` for the exact tag string. If they use `Context.GenericTag("EmailServiceTag")`, use that exact string. If they use `Context.Tag()` with a class, you may need to mock `@gemhog/core/email` instead of `@/lib/email-layers`.

Alternative approach if tag identity is an issue — mock `@gemhog/core/email` to re-export mock services with correct tags, AND mock `@gemhog/core/drizzle` to provide empty layer, AND mock `@/lib/email-layers` to use those mocked exports:

```typescript
vi.mock("@gemhog/core/drizzle", () => {
  const { Layer } = require("effect");
  return { DatabaseLive: Layer.empty };
});
```

Then `@/lib/email-layers` will use the mocked `@gemhog/core/email` and `@gemhog/core/drizzle` to construct its EmailLayers, which will be mock layers.

To create test tokens, use `createToken` from `@gemhog/core/email` (the real one, not mocked — or construct tokens manually using the HMAC approach in token.ts with the test secret).

**Test cases (describe "getVerifyStatus"):**

1. `it("should return 'success' for valid token")` — Create a valid token with action "verify" and future expiresAt. Call `getVerifyStatus(token)`. Expect `"success"`.

2. `it("should return 'expired' for expired token")` — Create a token with expiresAt in the past. Call `getVerifyStatus(token)`. Expect `"expired"`.

3. `it("should return 'invalid' for malformed token")` — Call `getVerifyStatus("not-a-valid-token")`. Expect `"invalid"`.

4. `it("should return 'invalid' for wrong signature token")` — Create a token with a different secret. Call `getVerifyStatus(token)`. Expect `"invalid"`.

For creating test tokens, use the real `createToken` from token.ts (import directly, not via the mock). Since `createToken` returns an Effect, run it with `Effect.runSync` or `Effect.runPromise`:

```typescript
import { createToken } from "@gemhog/core/email";
import { Effect } from "effect";

const validToken = Effect.runSync(
  createToken(
    { email: "test@example.com", action: "verify", expiresAt: Date.now() + 60000 },
    "test-secret-at-least-32-characters-long",
  ),
);
```

NOTE: The mock of `@gemhog/core/email` may interfere with importing `createToken`. If so, create tokens manually using the HMAC approach from token.ts:

```typescript
import { createHmac } from "node:crypto";

function makeTestToken(payload: { email: string; action: string; expiresAt: number }, secret: string): string {
  const data = JSON.stringify(payload);
  const signature = createHmac("sha256", secret).update(data).digest("hex");
  return Buffer.from(`${data}.${signature}`).toString("base64url");
}
```

This is more robust because it doesn't depend on the mock state.

**Style:** Double quotes, 2-space indent, semicolons. Use describe/it/expect from vitest.
  </action>
  <verify>
Run: `cd /home/lima/repo && npx vitest run --project web -- apps/web/src/app/verify/verify-status.test.ts`

All 4 tests pass. Verify that page.tsx still type-checks by running `pnpm check`.
  </verify>
  <done>
- verify-status.ts exists and exports getVerifyStatus
- verify-status.test.ts has 4 passing tests covering success/expired/invalid/error
- page.tsx imports from verify-status.ts instead of defining inline
- TypeScript compilation passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Extract and test getUnsubscribeStatus</name>
  <files>
    apps/web/src/app/unsubscribe/unsubscribe-status.ts
    apps/web/src/app/unsubscribe/unsubscribe-status.test.ts
    apps/web/src/app/unsubscribe/page.tsx
  </files>
  <action>
**Step 1: Create `apps/web/src/app/unsubscribe/unsubscribe-status.ts`**

Extract the `getUnsubscribeStatus` function and its type from `page.tsx`:

```typescript
import { SubscriberServiceTag, verifyToken } from "@gemhog/core/email";
import { env } from "@gemhog/env/server";
import { Effect } from "effect";

import { EmailLayers } from "@/lib/email-layers";

export type UnsubscribeStatus = "success" | "invalid" | "error";

export async function getUnsubscribeStatus(token: string): Promise<UnsubscribeStatus> {
  const program = Effect.gen(function* () {
    const subscriberService = yield* SubscriberServiceTag;
    const payload = yield* verifyToken(token, env.BETTER_AUTH_SECRET);
    yield* subscriberService.unsubscribe(payload.email);
    return "success" as UnsubscribeStatus;
  }).pipe(
    Effect.catchTag("InvalidTokenError", () =>
      Effect.succeed("invalid" as UnsubscribeStatus),
    ),
    Effect.catchAll(() => Effect.succeed("error" as UnsubscribeStatus)),
  );

  return Effect.runPromise(program.pipe(Effect.provide(EmailLayers)));
}
```

**Step 2: Update `apps/web/src/app/unsubscribe/page.tsx`**

Replace the inline function and type with an import:

- Remove the `UnsubscribeStatus` type definition
- Remove the `getUnsubscribeStatus` function
- Remove imports only used by the extracted function
- Add: `import { getUnsubscribeStatus, type UnsubscribeStatus } from "./unsubscribe-status";`
- Keep all component functions and default export exactly as-is
- The page still needs `UnsubscribeStatus` type for conditional rendering — import it as a type

**Step 3: Create `apps/web/src/app/unsubscribe/unsubscribe-status.test.ts`**

Same mocking strategy as verify-status.test.ts:

1. Mock `@gemhog/env/server` with test env values
2. Mock `@/lib/email-layers` (or mock `@gemhog/core/email` + `@gemhog/core/drizzle`) to provide mock layers
3. Create test tokens using the manual HMAC helper function (same as Task 1)

**Test cases (describe "getUnsubscribeStatus"):**

1. `it("should return 'success' for valid unsubscribe token")` — Create a valid token with action "unsubscribe" and future expiresAt. Call `getUnsubscribeStatus(token)`. Expect `"success"`.

2. `it("should return 'invalid' for expired token")` — Create token with expiresAt in the past. Expect `"invalid"` (unsubscribe maps ALL InvalidTokenError reasons to "invalid", unlike verify which distinguishes "expired").

3. `it("should return 'invalid' for malformed token")` — Call with `"garbage-token"`. Expect `"invalid"`.

4. `it("should return 'invalid' for wrong signature token")` — Create token with different secret. Expect `"invalid"`.

NOTE: The unsubscribe page maps expired tokens to "invalid" (not "expired") unlike the verify page. This is by design — the unsubscribe `catchTag` handler does NOT check `error.reason`. Verify this is tested correctly.

**Style:** Same conventions as Task 1.
  </action>
  <verify>
Run: `cd /home/lima/repo && npx vitest run --project web -- apps/web/src/app/unsubscribe/unsubscribe-status.test.ts`

All 4 tests pass. Verify that page.tsx still type-checks by running `pnpm check`.
  </verify>
  <done>
- unsubscribe-status.ts exists and exports getUnsubscribeStatus
- unsubscribe-status.test.ts has 4 passing tests covering success/invalid/error
- page.tsx imports from unsubscribe-status.ts instead of defining inline
- TypeScript compilation passes
  </done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite to verify no regressions</name>
  <files></files>
  <action>
Run `pnpm test` from the repo root to verify:
1. All new tests pass (verify-status.test.ts + unsubscribe-status.test.ts)
2. All existing tests still pass
3. TypeScript compilation passes (page.tsx refactors work)
4. No regressions

If any test fails, fix the issue in the new test files or extracted modules. Do NOT modify existing source code beyond the page.tsx refactors already specified.
  </action>
  <verify>
`pnpm test` exits with code 0. Output shows new test files in the run.
  </verify>
  <done>
- `pnpm test` passes completely
- New tests appear in test output
- No regressions
  </done>
</task>

</tasks>

<verification>
1. `verify-status.ts` exports `getVerifyStatus` and `VerifyStatus` type
2. `unsubscribe-status.ts` exports `getUnsubscribeStatus` and `UnsubscribeStatus` type
3. Both page.tsx files import from the extracted modules (not inline)
4. `verify-status.test.ts` has 4 passing tests (success/expired/invalid/error)
5. `unsubscribe-status.test.ts` has 4 passing tests (success/invalid×3/error)
6. `pnpm test` passes (full pipeline including new tests)
7. No modifications to existing test files or non-page source files
</verification>

<success_criteria>
- Both server component page logic functions are extracted and testable
- All token-to-status mapping paths are covered by unit tests
- Page components remain functional (import from extracted modules)
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/02-email-infrastructure/02-09-SUMMARY.md`
</output>
