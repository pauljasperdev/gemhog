---
phase: 03-core-consolidation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - packages/core/src/auth/auth.sql.ts
  - packages/core/src/auth/auth.errors.ts
  - packages/core/src/auth/auth.service.ts
  - packages/core/src/auth/auth.mock.ts
  - packages/core/src/auth/index.ts
  - packages/core/src/auth/auth.test.ts
autonomous: true

must_haves:
  truths:
    - "Auth schema is migrated to packages/core/src/auth/auth.sql.ts"
    - "Auth service is wrapped in Effect Layer"
    - "better-auth instance is accessible via AuthService"
    - "Mock AuthService layer exists for unit testing"
  artifacts:
    - path: "packages/core/src/auth/auth.sql.ts"
      provides: "Drizzle schema for auth tables"
      contains: "user"
    - path: "packages/core/src/auth/auth.service.ts"
      provides: "AuthService Context.Tag + AuthLive layer"
      exports: ["AuthService", "AuthLive"]
    - path: "packages/core/src/auth/auth.mock.ts"
      provides: "Mock AuthService for testing"
      exports: ["AuthServiceTest"]
    - path: "packages/core/src/auth/index.ts"
      provides: "Auth domain public API"
      exports: ["auth", "AuthService", "AuthLive"]
  key_links:
    - from: "packages/core/src/auth/auth.service.ts"
      to: "better-auth"
      via: "Effect.tryPromise wrapping auth.api calls"
      pattern: "Effect\\.tryPromise"
    - from: "packages/core/src/auth/index.ts"
      to: "packages/core/src/auth/auth.sql.ts"
      via: "schema re-export"
      pattern: "export.*from.*auth\\.sql"
---

<objective>
Migrate auth domain to packages/core with Effect service wrapper

Purpose: Move the authentication schema and better-auth configuration to the new domain-driven structure, wrapping better-auth operations in Effect for testability and dependency injection.

Output: Working auth domain in packages/core with AuthService Effect Layer, mock layer for testing, and all existing auth functionality preserved.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-consolidation/03-CONTEXT.md
@.planning/phases/03-core-consolidation/03-RESEARCH.md

# Prior plan output (database layers)
# Note: 03-01-SUMMARY.md should exist after plan 01 executes

# Current auth implementation to migrate
@packages/auth/src/index.ts
@packages/db/src/schema/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate auth schema and create error types</name>
  <files>
    packages/core/src/auth/auth.sql.ts
    packages/core/src/auth/auth.errors.ts
  </files>
  <action>
1. **src/auth/auth.sql.ts** - Copy Drizzle schema from packages/db/src/schema/auth.ts:
   - user, session, account, verification tables
   - userRelations, sessionRelations, accountRelations
   - Keep all imports from drizzle-orm (relations, pgTable, text, etc.)
   - This is a direct copy — schema unchanged

2. **src/auth/auth.errors.ts** - Create domain-specific error types:
   ```typescript
   import { Data } from "effect";

   export class AuthError extends Data.TaggedError("AuthError")<{
     message: string;
     cause?: unknown;
   }> {}

   export class SessionNotFoundError extends Data.TaggedError("SessionNotFoundError")<{
     token?: string;
   }> {}

   export class SessionExpiredError extends Data.TaggedError("SessionExpiredError")<{
     sessionId: string;
     expiredAt: Date;
   }> {}

   export class UnauthorizedError extends Data.TaggedError("UnauthorizedError")<{
     message: string;
   }> {}
   ```
  </action>
  <verify>
    - File exists: packages/core/src/auth/auth.sql.ts
    - File contains user, session, account, verification exports
    - auth.errors.ts exports AuthError, SessionNotFoundError, etc.
  </verify>
  <done>Auth schema migrated and domain errors defined</done>
</task>

<task type="auto">
  <name>Task 2: Create AuthService with Effect Layer</name>
  <files>
    packages/core/src/auth/auth.service.ts
    packages/core/src/auth/auth.mock.ts
    packages/core/src/auth/index.ts
  </files>
  <action>
1. **src/auth/auth.service.ts** - AuthService Context.Tag wrapping better-auth:
   ```typescript
   import { Context, Effect, Layer } from "effect";
   import { env } from "@gemhog/env/server";
   import { checkout, polar, portal } from "@polar-sh/better-auth";
   import { betterAuth } from "better-auth";
   import { drizzleAdapter } from "better-auth/adapters/drizzle";
   import { Polar } from "@polar-sh/sdk";
   import { drizzle } from "drizzle-orm/node-postgres";
   import * as schema from "./auth.sql";
   import { AuthError } from "./auth.errors";

   // Types
   type Session = Awaited<ReturnType<ReturnType<typeof betterAuth>["api"]["getSession"]>>;

   // Service interface
   interface AuthServiceInterface {
     readonly getSession: (headers: Headers) => Effect.Effect<Session, AuthError>;
     readonly handler: (request: Request) => Promise<Response>;
   }

   // Service tag
   export class AuthService extends Context.Tag("@gemhog/core/AuthService")<
     AuthService,
     AuthServiceInterface
   >() {}

   // Create better-auth instance (internal)
   const createAuth = () => {
     const db = drizzle(env.DATABASE_URL, { schema });
     const polarClient = new Polar({
       accessToken: env.POLAR_ACCESS_TOKEN,
       server: "sandbox",
     });

     return betterAuth({
       database: drizzleAdapter(db, { provider: "pg", schema }),
       trustedOrigins: [env.CORS_ORIGIN],
       emailAndPassword: { enabled: true },
       advanced: {
         defaultCookieAttributes: {
           sameSite: "none",
           secure: true,
           httpOnly: true,
         },
       },
       plugins: [
         polar({
           client: polarClient,
           createCustomerOnSignUp: true,
           enableCustomerPortal: true,
           use: [
             checkout({
               products: [{ productId: "your-product-id", slug: "pro" }],
               successUrl: env.POLAR_SUCCESS_URL,
               authenticatedUsersOnly: true,
             }),
             portal(),
           ],
         }),
       ],
     });
   };

   // Implementation layer
   export const AuthLive = Layer.sync(AuthService, () => {
     const auth = createAuth();
     return {
       getSession: (headers) =>
         Effect.tryPromise({
           try: () => auth.api.getSession({ headers }),
           catch: (error) => new AuthError({ message: "Failed to get session", cause: error }),
         }),
       handler: (request) => auth.handler(request),
     };
   });

   // Export the raw auth instance for backward compatibility during migration
   // This will be used by apps/server until full Effect adoption
   export const auth = createAuth();
   ```

2. **src/auth/auth.mock.ts** - Mock layer for testing:
   ```typescript
   import { Effect, Layer } from "effect";
   import { AuthService } from "./auth.service";

   // Mock session data for testing
   const mockSession = {
     user: { id: "test-user-id", email: "test@example.com", name: "Test User" },
     session: { id: "test-session-id", userId: "test-user-id" },
   };

   // Mock AuthService for unit tests
   export const AuthServiceTest = Layer.succeed(AuthService, {
     getSession: () => Effect.succeed(mockSession as any),
     handler: async () => new Response("OK", { status: 200 }),
   });

   // Mock for unauthenticated scenarios
   export const AuthServiceTestUnauthenticated = Layer.succeed(AuthService, {
     getSession: () => Effect.succeed(null as any),
     handler: async () => new Response("OK", { status: 200 }),
   });
   ```

3. **src/auth/index.ts** - Public API for auth domain:
   ```typescript
   // Auth domain public API
   export { auth, AuthService, AuthLive } from "./auth.service";
   export { AuthServiceTest, AuthServiceTestUnauthenticated } from "./auth.mock";
   export * from "./auth.errors";
   export * as schema from "./auth.sql";
   ```

Key patterns from RESEARCH.md:
- Wrap better-auth calls with Effect.tryPromise at boundary
- Keep better-auth internals unchanged
- Export both Effect service AND raw auth instance for migration compatibility
- Service methods return Effect<A, E, never> (no dependencies leaked)
  </action>
  <verify>
    - `pnpm --filter @gemhog/core check-types` passes
    - src/auth/index.ts exports auth, AuthService, AuthLive
    - src/auth/auth.mock.ts exports AuthServiceTest
  </verify>
  <done>AuthService with Effect Layer created, mock layer for testing ready</done>
</task>

<task type="auto">
  <name>Task 3: Create unit test for AuthService</name>
  <files>
    packages/core/src/auth/auth.test.ts
  </files>
  <action>
Create unit test using @effect/vitest and mock layer:

```typescript
// packages/core/src/auth/auth.test.ts
import { Effect } from "effect";
import { describe, expect, it } from "vitest";
import { AuthService } from "./auth.service";
import { AuthServiceTest, AuthServiceTestUnauthenticated } from "./auth.mock";

describe("AuthService", () => {
  it("getSession returns mock session when authenticated", async () => {
    const program = Effect.gen(function* () {
      const authService = yield* AuthService;
      const session = yield* authService.getSession(new Headers());
      return session;
    }).pipe(Effect.provide(AuthServiceTest));

    const result = await Effect.runPromise(program);
    expect(result).toBeDefined();
    expect(result?.user?.id).toBe("test-user-id");
  });

  it("getSession returns null when unauthenticated", async () => {
    const program = Effect.gen(function* () {
      const authService = yield* AuthService;
      const session = yield* authService.getSession(new Headers());
      return session;
    }).pipe(Effect.provide(AuthServiceTestUnauthenticated));

    const result = await Effect.runPromise(program);
    expect(result).toBeNull();
  });
});
```

Note: These are unit tests using mock layers — no database or network needed.
Run with `pnpm test:unit` from monorepo root.
  </action>
  <verify>
    - `pnpm test:unit` passes (including new auth.test.ts)
    - Test file uses Effect.provide with mock layers
  </verify>
  <done>Unit tests pass using mock AuthService layers</done>
</task>

</tasks>

<verification>
1. packages/core/src/auth/ directory contains all domain files
2. Auth schema (user, session, account, verification) exported from auth.sql.ts
3. AuthService Effect Layer wraps better-auth correctly
4. Mock layers work for testing
5. Unit tests pass
6. `pnpm --filter @gemhog/core check-types` passes
</verification>

<success_criteria>
- Auth domain fully migrated to packages/core/src/auth/
- AuthService wraps better-auth with Effect for DI
- Mock layer enables unit testing without database
- Backward-compatible auth export for gradual migration
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-consolidation/03-02-SUMMARY.md`
</output>
