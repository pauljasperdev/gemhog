---
phase: 03-core-consolidation
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - packages/core/src/payment/payment.service.ts
  - packages/core/src/payment/payment.errors.ts
  - packages/core/src/payment/payment.mock.ts
  - packages/core/src/payment/index.ts
  - packages/core/src/payment/payment.test.ts
autonomous: true

must_haves:
  truths:
    - "Payment service is wrapped in Effect Layer"
    - "Polar SDK client is accessible via PaymentService"
    - "Mock PaymentService layer exists for unit testing"
  artifacts:
    - path: "packages/core/src/payment/payment.service.ts"
      provides: "PaymentService Context.Tag + PaymentLive layer"
      exports: ["PaymentService", "PaymentLive", "polarClient"]
    - path: "packages/core/src/payment/payment.mock.ts"
      provides: "Mock PaymentService for testing"
      exports: ["PaymentServiceTest"]
    - path: "packages/core/src/payment/index.ts"
      provides: "Payment domain public API"
      exports: ["PaymentService", "PaymentLive", "polarClient"]
  key_links:
    - from: "packages/core/src/payment/payment.service.ts"
      to: "@polar-sh/sdk"
      via: "Polar client instantiation"
      pattern: "new Polar"
---

<objective>
Create payment domain in packages/core with Effect service wrapper

Purpose: Extract payment functionality (Polar SDK) into its own domain with Effect Layer, following the same pattern as auth. This separates payment concerns from auth, making the codebase more modular.

Output: Working payment domain in packages/core with PaymentService Effect Layer and mock layer for testing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-consolidation/03-CONTEXT.md
@.planning/phases/03-core-consolidation/03-RESEARCH.md

# Current payment implementation
@packages/auth/src/lib/payments.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PaymentService with Effect Layer</name>
  <files>
    packages/core/src/payment/payment.errors.ts
    packages/core/src/payment/payment.service.ts
  </files>
  <action>
1. **src/payment/payment.errors.ts** - Payment-specific error types:
   ```typescript
   import { Data } from "effect";

   export class PaymentError extends Data.TaggedError("PaymentError")<{
     message: string;
     cause?: unknown;
   }> {}

   export class CheckoutError extends Data.TaggedError("CheckoutError")<{
     message: string;
     productId?: string;
   }> {}

   export class SubscriptionError extends Data.TaggedError("SubscriptionError")<{
     message: string;
     customerId?: string;
   }> {}
   ```

2. **src/payment/payment.service.ts** - PaymentService Context.Tag wrapping Polar SDK:
   ```typescript
   import { Context, Effect, Layer } from "effect";
   import { env } from "@gemhog/env/server";
   import { Polar } from "@polar-sh/sdk";
   import { PaymentError } from "./payment.errors";

   // Service interface - add methods as needed
   interface PaymentServiceInterface {
     readonly getClient: () => Polar;
   }

   // Service tag
   export class PaymentService extends Context.Tag("@gemhog/core/PaymentService")<
     PaymentService,
     PaymentServiceInterface
   >() {}

   // Create Polar client (internal)
   const createPolarClient = () =>
     new Polar({
       accessToken: env.POLAR_ACCESS_TOKEN,
       server: "sandbox",
     });

   // Implementation layer
   export const PaymentLive = Layer.sync(PaymentService, () => {
     const client = createPolarClient();
     return {
       getClient: () => client,
     };
   });

   // Export the raw Polar client for backward compatibility
   // Used by auth domain for better-auth polar plugin
   export const polarClient = createPolarClient();
   ```

Note: The PaymentService is currently minimal because Polar integration is handled through better-auth plugin. This structure allows expansion as payment features grow in V1.
  </action>
  <verify>
    - Files exist in packages/core/src/payment/
    - payment.service.ts exports PaymentService, PaymentLive, polarClient
  </verify>
  <done>PaymentService with Effect Layer created</done>
</task>

<task type="auto">
  <name>Task 2: Create mock layer and public API</name>
  <files>
    packages/core/src/payment/payment.mock.ts
    packages/core/src/payment/index.ts
    packages/core/src/payment/payment.test.ts
  </files>
  <action>
1. **src/payment/payment.mock.ts** - Mock layer for testing:
   ```typescript
   import { Layer } from "effect";
   import { Polar } from "@polar-sh/sdk";
   import { PaymentService } from "./payment.service";

   // Mock Polar client for testing (won't make real API calls)
   const mockPolarClient = {
     // Add mock methods as needed for tests
   } as unknown as Polar;

   // Mock PaymentService for unit tests
   export const PaymentServiceTest = Layer.succeed(PaymentService, {
     getClient: () => mockPolarClient,
   });
   ```

2. **src/payment/index.ts** - Public API for payment domain:
   ```typescript
   // Payment domain public API
   export { PaymentService, PaymentLive, polarClient } from "./payment.service";
   export { PaymentServiceTest } from "./payment.mock";
   export * from "./payment.errors";
   ```

3. **src/payment/payment.test.ts** - Unit test:
   ```typescript
   import { Effect } from "effect";
   import { describe, expect, it } from "vitest";
   import { PaymentService } from "./payment.service";
   import { PaymentServiceTest } from "./payment.mock";

   describe("PaymentService", () => {
     it("provides access to Polar client via mock", async () => {
       const program = Effect.gen(function* () {
         const paymentService = yield* PaymentService;
         const client = paymentService.getClient();
         return client;
       }).pipe(Effect.provide(PaymentServiceTest));

       const result = await Effect.runPromise(program);
       expect(result).toBeDefined();
     });
   });
   ```
  </action>
  <verify>
    - `pnpm test:unit` passes (including payment.test.ts)
    - src/payment/index.ts exports PaymentService, PaymentLive, polarClient
  </verify>
  <done>Payment domain complete with mock layer and tests</done>
</task>

</tasks>

<verification>
1. packages/core/src/payment/ directory contains all domain files
2. PaymentService Effect Layer wraps Polar SDK
3. Mock layer enables unit testing
4. Unit tests pass
5. `pnpm --filter @gemhog/core check-types` passes
</verification>

<success_criteria>
- Payment domain exists in packages/core/src/payment/
- PaymentService wraps Polar SDK with Effect for DI
- Mock layer enables unit testing
- polarClient exported for auth domain integration
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-consolidation/03-03-SUMMARY.md`
</output>
