# Phase 3.1: Code Review Fixes - Research

**Researched:** 2026-01-21 **Domain:** Monorepo maintenance, Effect Config,
Drizzle migrations **Confidence:** HIGH

## Summary

This phase addresses code review findings that accumulated during Phase 3 (core
consolidation). The work spans six distinct areas: database migrations, env
handling, t3-env replacement, auth simplification, dead code removal, and
dependency audit.

The primary blockers are:

1. **Missing database migrations** - Integration tests cannot work without
   schema
2. **Inconsistent env handling** - Multiple packages use dotenv directly instead
   of centralized `@gemhog/env`

The refactoring work (Effect Config, auth simplification, payment removal)
follows established patterns and has clear implementation paths. The dependency
audit is straightforward using knip.

**Primary recommendation:** Execute in dependency order: migrations first
(blocking), then env consolidation, then t3-env replacement (removes dynamic
require hacks), then auth/payment simplification, finally dependency audit.

## Standard Stack

The established libraries/tools for this domain:

### Core

| Library     | Version | Purpose                          | Why Standard                        |
| ----------- | ------- | -------------------------------- | ----------------------------------- |
| effect      | ^3.19   | Config module for env validation | Already in project, replaces t3-env |
| drizzle-kit | ^0.31.8 | Database migrations              | Already configured in packages/core |
| knip        | latest  | Unused dependency detection      | Monorepo-aware, 100+ plugins        |

### Supporting

| Library        | Version | Purpose               | When to Use               |
| -------------- | ------- | --------------------- | ------------------------- |
| @effect/vitest | ^0.27   | Effect test utilities | Testing Config validation |

### Alternatives Considered

| Instead of    | Could Use   | Tradeoff                                              |
| ------------- | ----------- | ----------------------------------------------------- |
| knip          | depcheck    | knip is monorepo-aware; depcheck per-package only     |
| Effect Config | keep t3-env | t3-env uses Zod; Effect Config consolidates on Effect |

**Installation:**

```bash
# Already installed - no new dependencies needed
# knip is used via npx, not installed
npx knip
```

## Architecture Patterns

### Recommended Project Structure

```
packages/env/
├── src/
│   ├── server.ts     # Effect Config for server env
│   └── web.ts        # Effect Config for web env (Next.js)
```

### Pattern 1: Effect Config for Environment Validation

**What:** Replace t3-env/Zod with Effect Config module **When to use:** All
environment variable loading **Example:**

```typescript
// Source: https://effect.website/docs/configuration/
import { Config, Effect, Redacted } from "effect";

const ServerConfig = Config.all({
  DATABASE_URL: Config.redacted("DATABASE_URL"),
  BETTER_AUTH_SECRET: Config.redacted("BETTER_AUTH_SECRET"),
  BETTER_AUTH_URL: Config.string("BETTER_AUTH_URL"),
  POLAR_ACCESS_TOKEN: Config.redacted("POLAR_ACCESS_TOKEN"),
  POLAR_SUCCESS_URL: Config.string("POLAR_SUCCESS_URL"),
  CORS_ORIGIN: Config.string("CORS_ORIGIN"),
  NODE_ENV: Config.string("NODE_ENV").pipe(Config.withDefault("development")),
});

// Validates at import time - fails fast if env missing
export const env = Effect.runSync(ServerConfig);

// Access redacted values when needed
const dbUrl = Redacted.value(env.DATABASE_URL);
```

### Pattern 2: Drizzle Config with @gemhog/env

**What:** Use centralized env instead of dotenv **When to use:**
drizzle.config.ts **Example:**

```typescript
// Source: Drizzle Kit documentation
import { env } from "@gemhog/env/server";
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/*/*.sql.ts",
  out: "./src/migrations",
  dialect: "postgresql",
  dbCredentials: {
    url: Redacted.value(env.DATABASE_URL),
  },
});
```

### Pattern 3: Simplified Auth (No Effect Wrapper)

**What:** Remove Effect Layer around better-auth **When to use:** HTTP boundary
services that are self-contained **Example:**

```typescript
// better-auth is at HTTP boundary - no Effect wrapper needed
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { drizzle } from "drizzle-orm/node-postgres";
import { env } from "@gemhog/env/server";
import { Redacted } from "effect";
import * as schema from "./auth.sql";

const createAuth = () => {
  const db = drizzle(Redacted.value(env.DATABASE_URL), { schema });
  return betterAuth({
    database: drizzleAdapter(db, { provider: "pg", schema }),
    // ... rest of config
  });
};

// Lazy singleton
let _auth: ReturnType<typeof createAuth> | null = null;
export const getAuth = () => (_auth ??= createAuth());

// Convenience proxy for backward compatibility
export const auth = new Proxy({} as ReturnType<typeof betterAuth>, {
  get: (_target, prop) =>
    (getAuth() as unknown as Record<string | symbol, unknown>)[prop],
});

// Plain async helper - no Effect
export const getSession = (headers: Headers) =>
  getAuth().api.getSession({ headers });
```

### Anti-Patterns to Avoid

- **Dynamic require() for deferred validation:** Effect Config validates at
  import time naturally via `Effect.runSync()`
- **Effect wrapper around HTTP-boundary services:** better-auth handles its own
  lifecycle; Effect adds complexity without benefit
- **Multiple dotenv consumers:** Only `@gemhog/env` should load `.env` files

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem              | Don't Build               | Use Instead          | Why                                   |
| -------------------- | ------------------------- | -------------------- | ------------------------------------- |
| Env validation       | Custom validation logic   | Effect Config        | Type-safe, redacted values, fail-fast |
| Unused dep detection | Manual package.json audit | knip                 | Monorepo-aware, catches exports too   |
| Migration generation | Manual SQL                | drizzle-kit generate | Schema-driven, type-safe              |

**Key insight:** Effect Config replaces both t3-env AND the dynamic require()
hack used for deferred validation. `Effect.runSync()` validates at import time,
which is what we want.

## Common Pitfalls

### Pitfall 1: Config.redacted Returns Redacted Type

**What goes wrong:** Code expects string but gets `Redacted<string>` **Why it
happens:** Config.redacted wraps values for security **How to avoid:** Use
`Redacted.value(env.DATABASE_URL)` to extract actual value **Warning signs:**
TypeScript errors about type mismatch with string

### Pitfall 2: Effect.runSync in ES Modules

**What goes wrong:** `Effect.runSync()` at module top level can fail in some
bundlers **Why it happens:** ES module evaluation order issues **How to avoid:**
Keep `Effect.runSync()` call simple; don't chain complex effects **Warning
signs:** Runtime errors during module loading

### Pitfall 3: drizzle-kit Needs Actual String URL

**What goes wrong:** Passing `Redacted<string>` to drizzle-kit config **Why it
happens:** drizzle-kit expects plain string for `dbCredentials.url` **How to
avoid:** Extract with `Redacted.value()` in drizzle.config.ts **Warning signs:**
Migration commands fail with type errors

### Pitfall 4: Circular Import with @gemhog/env

**What goes wrong:** drizzle.config.ts imports @gemhog/env which imports effect
**Why it happens:** drizzle-kit runs outside normal Node context **How to
avoid:** Ensure @gemhog/env has dotenv side-effect import at top **Warning
signs:** "DATABASE_URL is undefined" in drizzle-kit commands

### Pitfall 5: knip False Positives

**What goes wrong:** knip reports dependencies as unused when they're actually
used **Why it happens:** Peer deps, plugins, type-only imports not detected
**How to avoid:** Review each finding; use knip's ignore config for legitimate
cases **Warning signs:** knip reports core deps like `effect` as unused

### Pitfall 6: Migration Folder Must Exist

**What goes wrong:** `pnpm db:generate` fails **Why it happens:** Output folder
`./src/migrations` doesn't exist **How to avoid:** Create folder before first
generate, or drizzle-kit creates it **Warning signs:** "ENOENT" errors from
drizzle-kit

## Code Examples

Verified patterns from official sources:

### Effect Config with Redacted Values

```typescript
// Source: https://effect.website/docs/configuration/
import { Config, Effect, Redacted } from "effect";

// Define config shape
const ServerConfig = Config.all({
  DATABASE_URL: Config.redacted("DATABASE_URL"),
  API_KEY: Config.redacted("API_KEY"),
  PORT: Config.number("PORT").pipe(Config.withDefault(3000)),
  NODE_ENV: Config.string("NODE_ENV").pipe(Config.withDefault("development")),
});

// Validate and export - fails at import time if missing
export const env = Effect.runSync(ServerConfig);

// Type is: { DATABASE_URL: Redacted<string>, API_KEY: Redacted<string>, PORT: number, NODE_ENV: string }
```

### Accessing Redacted Values

```typescript
// Source: https://effect.website/docs/configuration/
import { Redacted } from "effect";
import { env } from "@gemhog/env/server";

// When you need the actual value
const connectionString = Redacted.value(env.DATABASE_URL);

// Logging is safe - shows <redacted>
console.log("DB URL:", env.DATABASE_URL); // DB URL: <redacted>
```

### Web Client Config (Next.js)

```typescript
// Source: Effect docs + Next.js patterns
import { Config, Effect } from "effect";

// Client-side env (NEXT_PUBLIC_ prefix)
const WebConfig = Config.all({
  NEXT_PUBLIC_SERVER_URL: Config.string("NEXT_PUBLIC_SERVER_URL"),
});

export const env = Effect.runSync(WebConfig);
```

### Running knip in Monorepo

```bash
# Source: https://knip.dev/
# Run from repo root - discovers all workspaces
npx knip

# Check specific workspace
npx knip --workspace packages/core

# Fix (remove unused)
npx knip --fix
```

## State of the Art

| Old Approach            | Current Approach   | When Changed     | Impact                        |
| ----------------------- | ------------------ | ---------------- | ----------------------------- |
| t3-env + Zod            | Effect Config      | Project decision | Consolidates on Effect        |
| Dynamic require()       | Static import      | This phase       | Removes hack, cleaner code    |
| Effect wrapper for auth | Direct better-auth | This phase       | Simpler, no false abstraction |

**Deprecated/outdated:**

- `@t3-oss/env-core` and `@t3-oss/env-nextjs`: Being replaced with Effect Config
- `PaymentService` Effect wrapper: Dead code, Polar handled by better-auth
  plugin
- `AuthService` Effect wrapper: Unnecessary for HTTP-boundary service

## Open Questions

Things that couldn't be fully resolved:

1. **Effect Config in Next.js Client Bundle**
   - What we know: Effect is tree-shakeable; Config module is small
   - What's unclear: Bundle size impact on web client
   - Recommendation: Measure before/after; Effect is likely fine

2. **drizzle-kit with Effect Config Import**
   - What we know: drizzle-kit loads config at CLI time
   - What's unclear: Whether Effect.runSync() works reliably in drizzle-kit
     context
   - Recommendation: Test early; fallback is dotenv in drizzle.config.ts only

3. **knip Catalog Support**
   - What we know: pnpm catalogs are relatively new
   - What's unclear: Whether knip fully supports pnpm catalog entries
   - Recommendation: May need manual verification of catalog items

## Sources

### Primary (HIGH confidence)

- [Effect Configuration Documentation](https://effect.website/docs/configuration/) -
  Config.all, Config.redacted, Effect.runSync patterns
- [Drizzle Kit Configuration](https://orm.drizzle.team/docs/drizzle-config-file) -
  Config file structure, env loading
- [Knip Documentation](https://knip.dev/) - Monorepo support, unused dependency
  detection

### Secondary (MEDIUM confidence)

- [Effect Config API Reference](https://effect-ts.github.io/effect/effect/Config.ts.html) -
  Complete Config module API
- [Effect Solutions Config Guide](https://www.effect.solutions/config) -
  Practical Config patterns

### Tertiary (LOW confidence)

- WebSearch results for "Effect-TS Config validate environment variables" -
  General patterns
- t3-env GitHub issues for drizzle.config.ts usage - Known limitations

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH - Effect and Drizzle already in project, well-documented
- Architecture: HIGH - Patterns from official documentation
- Pitfalls: MEDIUM - Some based on general knowledge, not project-specific
  testing

**Research date:** 2026-01-21 **Valid until:** 2026-02-21 (30 days - stable
libraries)

## Task Dependency Analysis

Based on the code review findings, here's the recommended execution order:

```
1. Database Migrations (BLOCKING)
   └── No dependencies

2. Fix drizzle.config.ts
   └── Depends on: t3-env replacement (needs @gemhog/env to work with Effect)

3. Replace t3-env with Effect Config
   └── Depends on: migrations (need working tests to verify)

4. Simplify Auth (remove Effect wrapper)
   └── Depends on: Effect Config (removes dynamic require)

5. Remove Payment Service (dead code)
   └── No dependencies (can parallel with 4)

6. Dependency Audit
   └── Depends on: all above (audit after removals)
```

**Critical path:** Migrations -> Effect Config -> Auth simplification ->
Dependency audit

The migrations are truly blocking - without them, integration tests cannot
verify that the refactoring doesn't break auth functionality.
