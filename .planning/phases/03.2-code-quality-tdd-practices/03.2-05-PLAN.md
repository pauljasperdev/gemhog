---
phase: 03.2-code-quality-tdd-practices
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/server/src/startup.int.test.ts
  - apps/web/startup.int.test.ts
autonomous: true

must_haves:
  truths:
    - "Server process fails to start when DATABASE_URL is missing"
    - "Web build fails when NEXT_PUBLIC_SERVER_URL is missing"
    - "Integration tests verify actual process startup, not just schema validation"
  artifacts:
    - path: "apps/server/src/startup.int.test.ts"
      provides: "Server startup failure integration tests"
      min_lines: 30
    - path: "apps/web/startup.int.test.ts"
      provides: "Web startup failure integration tests"
      min_lines: 25
  key_links:
    - from: "apps/server/src/startup.int.test.ts"
      to: "apps/server/src/index.ts"
      via: "spawns tsx process and verifies exit code"
      pattern: "spawn.*tsx"
    - from: "apps/web/startup.int.test.ts"
      to: "apps/web/next.config.ts"
      via: "spawns next build and verifies exit code"
      pattern: "spawn.*next"
---

<objective>
Add integration tests that verify apps/server and apps/web fail to start when required environment variables are missing.

Purpose: Success criteria #4 states "Server/web startup failure on missing env vars has integration tests". Plan 02 covers unit tests for schema validation, but this plan covers actual process startup verification - spawning the real applications and confirming they exit with errors.

Output: Integration test files that spawn actual processes (tsx for server, next build for web) with missing env vars and assert on exit codes/stderr.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.2-code-quality-tdd-practices/03.2-RESEARCH.md
@packages/env/src/server.ts
@packages/env/src/web.ts
@apps/server/src/index.ts
@apps/web/next.config.ts
@packages/core/src/drizzle/connection.int.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create server startup failure integration test</name>
  <files>apps/server/src/startup.int.test.ts</files>
  <action>
Create `apps/server/src/startup.int.test.ts` that spawns the server process with missing env vars and verifies it fails.

Use Node.js `child_process.spawn` to run `tsx apps/server/src/index.ts` with a sanitized environment (only PATH, no DATABASE_URL etc).

Test cases:
1. Server fails when DATABASE_URL is missing - spawn with empty env (except PATH), verify non-zero exit code and stderr contains error message
2. Server fails when BETTER_AUTH_SECRET is missing - spawn with DATABASE_URL but no BETTER_AUTH_SECRET
3. Server fails when BETTER_AUTH_URL is missing - spawn with DATABASE_URL + BETTER_AUTH_SECRET but no BETTER_AUTH_URL
4. Server fails when CORS_ORIGIN is missing - spawn with all above but no CORS_ORIGIN

Pattern:
```typescript
import { spawn } from "node:child_process";
import path from "node:path";
import { afterEach, beforeEach, describe, expect, it } from "vitest";

describe("server startup", () => {
  const serverPath = path.resolve(__dirname, "index.ts");

  const runServer = (env: Record<string, string>): Promise<{ code: number | null; stderr: string }> => {
    return new Promise((resolve) => {
      const proc = spawn("npx", ["tsx", serverPath], {
        env: { PATH: process.env.PATH, ...env },
        stdio: ["ignore", "ignore", "pipe"],
      });

      let stderr = "";
      proc.stderr.on("data", (data) => { stderr += data.toString(); });
      proc.on("close", (code) => { resolve({ code, stderr }); });
    });
  };

  it("should fail when DATABASE_URL is missing", async () => {
    const { code, stderr } = await runServer({});
    expect(code).not.toBe(0);
    expect(stderr).toContain("DATABASE_URL");
  });
});
```

Important:
- Use `npx tsx` (not direct tsx binary) for cross-platform compatibility
- Set timeout to 10000ms (startup validation happens quickly, but give buffer)
- Clean up any spawned processes in afterEach if needed
- The Effect Config error message will contain the missing variable name
  </action>
  <verify>
Run: `pnpm test:integration -- --run apps/server/src/startup.int.test.ts`
All tests should pass (server should fail to start without env vars).
  </verify>
  <done>Server startup integration tests verify process fails with missing env vars</done>
</task>

<task type="auto">
  <name>Task 2: Create web startup failure integration test</name>
  <files>apps/web/startup.int.test.ts</files>
  <action>
Create `apps/web/startup.int.test.ts` that spawns the Next.js build process with missing env vars and verifies it fails.

Use Node.js `child_process.spawn` to run `next build` in apps/web directory with sanitized environment.

Note: For web, we test `next build` (not `next dev`) because:
- Build validates env at startup via next.config.ts importing @gemhog/env/web
- Build is deterministic and fast to fail
- Dev server would require waiting for startup which is slower

Test cases:
1. Web build fails when NEXT_PUBLIC_SERVER_URL is missing - spawn with empty env (except PATH/NODE), verify non-zero exit code

Pattern:
```typescript
import { spawn } from "node:child_process";
import path from "node:path";
import { describe, expect, it } from "vitest";

describe("web startup", () => {
  const webDir = path.resolve(__dirname, "..");

  const runBuild = (env: Record<string, string>): Promise<{ code: number | null; stderr: string; stdout: string }> => {
    return new Promise((resolve) => {
      const proc = spawn("npx", ["next", "build"], {
        cwd: webDir,
        env: { PATH: process.env.PATH, HOME: process.env.HOME, ...env },
        stdio: ["ignore", "pipe", "pipe"],
      });

      let stdout = "";
      let stderr = "";
      proc.stdout.on("data", (data) => { stdout += data.toString(); });
      proc.stderr.on("data", (data) => { stderr += data.toString(); });
      proc.on("close", (code) => { resolve({ code, stderr, stdout }); });
    });
  };

  it("should fail build when NEXT_PUBLIC_SERVER_URL is missing", async () => {
    const { code, stderr, stdout } = await runBuild({});
    expect(code).not.toBe(0);
    // Error could be in stdout or stderr depending on Next.js version
    const output = stdout + stderr;
    expect(output).toContain("NEXT_PUBLIC_SERVER_URL");
  }, 30000); // Next build can take longer
});
```

Important:
- Set timeout to 30000ms (Next.js build is heavier than tsx startup)
- Include HOME in env (some Node tools need it)
- Capture both stdout and stderr (Next.js may output errors to either)
- The test may take 5-15 seconds due to Next.js build initialization
  </action>
  <verify>
Run: `pnpm test:integration -- --run apps/web/startup.int.test.ts`
Test should pass (build should fail without NEXT_PUBLIC_SERVER_URL).
  </verify>
  <done>Web startup integration test verifies build fails with missing env var</done>
</task>

</tasks>

<verification>
After both tasks:
1. `pnpm test:integration` runs both new integration tests along with existing ones
2. All integration tests pass
3. Tests actually spawn processes (verified by checking stderr contains env var names)
4. `pnpm verify` passes (full pipeline including new tests)
</verification>

<success_criteria>
- apps/server/src/startup.int.test.ts exists with 4 test cases
- apps/web/startup.int.test.ts exists with 1 test case
- Tests spawn real processes (tsx, next build) - NOT unit tests with mocks
- Tests verify non-zero exit codes when required env vars missing
- Tests verify error output contains the missing variable name
- All integration tests pass in `pnpm test:integration`
</success_criteria>

<output>
After completion, create `.planning/phases/03.2-code-quality-tdd-practices/03.2-05-SUMMARY.md`
</output>
