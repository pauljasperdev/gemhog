---
phase: 03.2-code-quality-tdd-practices
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/env/src/web.ts
  - packages/env/src/web.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "packages/env/src/web.ts uses Effect Config.all with Config.string"
    - "web.ts validation runs at import time via Effect.runSync"
    - "Existing tests continue to pass"
  artifacts:
    - path: "packages/env/src/web.ts"
      provides: "Effect-based env validation for web"
      contains: "Config.all"
    - path: "packages/env/src/web.test.ts"
      provides: "Unit tests using ConfigProvider.fromMap"
      contains: "ConfigProvider.fromMap"
  key_links:
    - from: "packages/env/src/web.ts"
      to: "effect"
      via: "import { Config, Effect }"
      pattern: "Config\\.all"
---

<objective>
Restore Effect Config usage in packages/env/src/web.ts to match the pattern used in server.ts.

Purpose: User expects consistency between server.ts and web.ts - both should use Effect Config for env validation. The previous implementation was changed to plain functions due to a misunderstanding about Next.js build-time inlining. Effect Config reads from process.env at runtime, which works fine because:
1. Server-side rendering runs Effect.runSync when the module loads
2. Next.js build process also evaluates this at build time, inlining the values
3. The "incompatibility" only exists if Effect Config runs in the browser at runtime - but the values are already inlined

Output: packages/env/src/web.ts using Effect Config.all and Effect.runSync, with updated tests using ConfigProvider.fromMap for isolation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md

# Reference implementation (correct Effect usage)
@packages/env/src/server.ts
@packages/env/src/server.test.ts

# Files to update
@packages/env/src/web.ts
@packages/env/src/web.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Restore Effect Config in web.ts</name>
  <files>packages/env/src/web.ts</files>
  <action>
Replace the plain getEnv() function with Effect Config pattern matching server.ts:

1. Import { Config, Effect } from "effect"
2. Define WebConfig using Config.all with Config.string for NEXT_PUBLIC_SERVER_URL
3. Export env via Effect.runSync(WebConfig)
4. Keep the WebEnv type export

The new implementation should look like:

```typescript
import { Config, Effect } from "effect";

const WebConfig = Config.all({
  NEXT_PUBLIC_SERVER_URL: Config.string("NEXT_PUBLIC_SERVER_URL"),
});

// Validates at import time - fails fast if env missing
export const env = Effect.runSync(WebConfig);

// Type helper for consumers
export type WebEnv = typeof env;
```

Remove the old comment about Next.js inlining being incompatible with Effect Config - that was incorrect. Effect Config reads process.env at module load time, which is when Next.js does its inlining during build.
  </action>
  <verify>
Run: `pnpm check-types`
Verify packages/env compiles without errors
  </verify>
  <done>web.ts uses Config.all and Effect.runSync matching server.ts pattern</done>
</task>

<task type="auto">
  <name>Task 2: Update web.test.ts to use Effect ConfigProvider</name>
  <files>packages/env/src/web.test.ts</files>
  <action>
Update the test file to use the same testing pattern as server.test.ts:

1. Import { Config, ConfigProvider, Effect } from "effect"
2. Recreate the WebConfig definition for isolated testing (do NOT import from ./web.ts)
3. Use ConfigProvider.fromMap to provide test values
4. Test missing required vars throw errors
5. Test valid config succeeds

Key pattern (from server.test.ts):
- Create a helper: `const createProvider = (vars) => ConfigProvider.fromMap(new Map(Object.entries(vars)))`
- Run config with: `Effect.runPromise(WebConfig.pipe(Effect.withConfigProvider(provider)))`

Remove the process.env manipulation pattern (vi.resetModules, process.env assignment) - ConfigProvider.fromMap is cleaner and more isolated.
  </action>
  <verify>
Run: `pnpm test:unit -- --run packages/env/src/web.test.ts`
All tests should pass
  </verify>
  <done>web.test.ts uses ConfigProvider.fromMap pattern matching server.test.ts</done>
</task>

<task type="auto">
  <name>Task 3: Verify full test suite passes</name>
  <files></files>
  <action>
Run the full verification pipeline to ensure the changes don't break anything:

1. Run unit tests: `pnpm test:unit`
2. Run type check: `pnpm check-types`
3. Run static analysis: `pnpm check`

This confirms:
- Effect Config works correctly for web env
- No regressions in other tests
- Types are correct
  </action>
  <verify>
Run: `pnpm verify:commit`
All checks pass
  </verify>
  <done>Full verification passes with Effect Config in web.ts</done>
</task>

</tasks>

<verification>
1. grep "Config.all" packages/env/src/web.ts returns a match
2. grep "Effect.runSync" packages/env/src/web.ts returns a match
3. grep "ConfigProvider.fromMap" packages/env/src/web.test.ts returns a match
4. pnpm test:unit -- --run packages/env/src/web.test.ts passes
5. pnpm verify:commit passes
</verification>

<success_criteria>
- packages/env/src/web.ts uses Effect Config.all and Effect.runSync (consistent with server.ts)
- packages/env/src/web.test.ts uses ConfigProvider.fromMap for isolated testing
- All existing tests continue to pass
- No regressions in type checking or static analysis
</success_criteria>

<output>
After completion, create `.planning/phases/03.2-code-quality-tdd-practices/03.2-06-SUMMARY.md`
</output>
