# Phase 03.2: Code Quality & TDD Practices - Research

**Researched:** 2026-01-21
**Domain:** Code quality cleanup, TDD practices, test coverage, documentation
**Confidence:** HIGH

## Summary

This phase addresses code quality gaps identified in CODE_REVIEW.md. The work
involves: (1) removing archaeological comments (SEC-fix references), (2)
deleting unused error classes, (3) adding unit tests for env schema validation,
(4) adding integration tests for startup failure on missing env vars, (5)
implementing TDD-style E2E tests that detect application errors, (6) documenting
TDD practices, and (7) documenting comment standards.

The research confirms that all items are straightforward implementation tasks
using existing project patterns. The project already has Vitest configured with
`vi.mock()` patterns for env testing, Playwright for E2E, and established
conventions in TESTING.md and CONVENTIONS.md.

**Primary recommendation:** Execute cleanup tasks first (dead code, comments),
then add tests using TDD approach (write failing test, verify it fails, then
skip/mark as pending until fix is implemented elsewhere), finally update
documentation.

## Standard Stack

The established libraries/tools for this domain:

### Core

| Library    | Version | Purpose             | Why Standard                          |
| ---------- | ------- | ------------------- | ------------------------------------- |
| Vitest     | 4.x     | Unit/Integration    | Already configured in project         |
| Playwright | 1.57.0  | E2E testing         | Already configured in project         |
| Effect     | 3.19    | Config validation   | Already used in packages/env          |

### Supporting

| Library   | Version | Purpose                  | When to Use                 |
| --------- | ------- | ------------------------ | --------------------------- |
| vi.mock   | Vitest  | Module mocking           | Env testing (already used)  |
| vi.stubEnv| Vitest  | Env variable stubbing    | Alternative to module mock  |

### Alternatives Considered

| Instead of         | Could Use          | Tradeoff                                 |
| ------------------ | ------------------ | ---------------------------------------- |
| vi.mock for env    | vi.stubEnv         | vi.mock already established in codebase  |
| Effect Config      | Zod                | Effect already chosen for type safety    |

**No new installations required.** All tools are already in place.

## Architecture Patterns

### Test File Structure

The project already uses co-located test files:

```
src/
  server.ts
  server.test.ts       # Unit test (*.test.ts)
  server.int.test.ts   # Integration test (*.int.test.ts)
apps/web/tests/e2e/
  home.e2e.test.ts     # E2E test (*.e2e.test.ts)
```

### Pattern 1: Env Module Mocking (Existing)

**What:** Mock `@gemhog/env/server` before importing dependent modules
**When to use:** Unit testing modules that import env at module load time
**Example:**

```typescript
// Source: packages/core/src/auth/auth.test.ts (existing pattern)
import { describe, expect, it, vi } from "vitest";

// Mock the env module before any imports that use it
vi.mock("@gemhog/env/server", () => ({
  env: {
    DATABASE_URL: { value: "postgresql://test:test@localhost:5432/test" },
    BETTER_AUTH_SECRET: { value: "test-secret" },
    BETTER_AUTH_URL: "http://localhost:3000",
    CORS_ORIGIN: "http://localhost:3001",
    NODE_ENV: "test",
  },
}));

// Import after mocking
import { someModule } from "./some.module";
```

### Pattern 2: Effect Config Testing

**What:** Test Config schema validation by running Effect with ConfigProvider
**When to use:** Unit testing env schema validation logic
**Example:**

```typescript
// Source: Effect documentation + project patterns
import { Config, ConfigProvider, Effect, Layer } from "effect";
import { describe, expect, it } from "vitest";

describe("ServerConfig", () => {
  it("should fail when required env var missing", async () => {
    const TestConfig = Config.string("REQUIRED_VAR");

    // Empty config provider - no env vars
    const emptyProvider = ConfigProvider.fromMap(new Map());

    const result = await Effect.runPromise(
      TestConfig.pipe(Effect.withConfigProvider(emptyProvider))
    ).catch((e) => e);

    expect(result).toBeInstanceOf(Error);
  });

  it("should succeed with valid env vars", async () => {
    const TestConfig = Config.string("REQUIRED_VAR");

    const validProvider = ConfigProvider.fromMap(
      new Map([["REQUIRED_VAR", "value"]])
    );

    const result = await Effect.runPromise(
      TestConfig.pipe(Effect.withConfigProvider(validProvider))
    );

    expect(result).toBe("value");
  });
});
```

### Pattern 3: Playwright Error Detection

**What:** Extend Playwright test to detect page errors and console errors
**When to use:** E2E tests that should fail when app has runtime errors
**Example:**

```typescript
// Source: Playwright docs + community patterns
import { test as base, expect } from "@playwright/test";

// Custom test fixture that fails on page errors
export const test = base.extend({
  page: async ({ page }, use) => {
    const errors: string[] = [];

    page.on("console", (msg) => {
      if (msg.type() === "error") {
        errors.push(`[console.error] ${msg.text()}`);
      }
    });

    page.on("pageerror", (error) => {
      errors.push(`[pageerror] ${error.name}: ${error.message}`);
    });

    await use(page);

    // Assert no errors after test completes
    expect(errors, "Page should have no errors").toStrictEqual([]);
  },
});

export { expect };
```

### Anti-Patterns to Avoid

- **Archaeological comments:** Comments like `// SEC-001 fix` that reference
  historical context but not current purpose
- **What-comments:** Comments restating what code does (`// validate input`)
  instead of why (`// prevent injection attacks via user input`)
- **Orphan error classes:** Defining error types "for later" without consumers

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem             | Don't Build              | Use Instead                   | Why                          |
| ------------------- | ------------------------ | ----------------------------- | ---------------------------- |
| Env validation      | Custom Zod schema        | Effect Config (existing)      | Already implemented          |
| Module mocking      | Manual jest.mock polyfill| vi.mock (Vitest built-in)     | Hoisting handled correctly   |
| E2E error detection | Manual console capture   | Playwright page events        | Comprehensive error capture  |

**Key insight:** The project already has all the patterns established. This
phase is about applying them consistently and adding coverage.

## Common Pitfalls

### Pitfall 1: vi.mock Hoisting

**What goes wrong:** Variables referenced in vi.mock factory are undefined
**Why it happens:** vi.mock is hoisted to top of file, before variable
declarations
**How to avoid:** Use inline values in mock factory, or use vi.hoisted()
**Warning signs:** "Cannot access 'X' before initialization" errors

```typescript
// BAD - mockValue is undefined when vi.mock runs
const mockValue = "test";
vi.mock("./module", () => ({ value: mockValue }));

// GOOD - inline the value
vi.mock("./module", () => ({ value: "test" }));

// ALSO GOOD - use vi.hoisted
const mockValue = vi.hoisted(() => "test");
vi.mock("./module", () => ({ value: mockValue }));
```

### Pitfall 2: TDD Test-First Confusion

**What goes wrong:** Writing test that passes immediately, missing the "red"
phase
**Why it happens:** Misunderstanding TDD - test should fail first to prove it
tests the right thing
**How to avoid:** Always verify test fails before implementing fix
**Warning signs:** Test passes on first run, test doesn't break when
implementation removed

### Pitfall 3: E2E Tests Passing Despite App Errors

**What goes wrong:** Tests check only URL/visibility, not actual app health
**Why it happens:** Default Playwright assertions don't check console/page
errors
**How to avoid:** Use custom fixture with error collection (Pattern 3 above)
**Warning signs:** E2E passes but manual testing shows errors

### Pitfall 4: Integration Test as Unit Test

**What goes wrong:** Testing env validation by actually loading env vars
**Why it happens:** Confusion about what makes a unit vs integration test
**How to avoid:** Unit tests mock externals (env, fs); integration tests use
real resources
**Warning signs:** Tests fail in CI due to missing env vars

## Code Examples

Verified patterns from official sources and existing project code:

### Env Schema Unit Test

```typescript
// packages/env/src/server.test.ts
import { Config, ConfigProvider, Effect } from "effect";
import { describe, expect, it } from "vitest";

// Create the config definition (don't import the validated env)
const ServerConfig = Config.all({
  DATABASE_URL: Config.redacted("DATABASE_URL"),
  BETTER_AUTH_SECRET: Config.redacted("BETTER_AUTH_SECRET"),
  BETTER_AUTH_URL: Config.string("BETTER_AUTH_URL"),
  CORS_ORIGIN: Config.string("CORS_ORIGIN"),
  NODE_ENV: Config.string("NODE_ENV").pipe(Config.withDefault("development")),
});

describe("ServerConfig schema", () => {
  it("should fail when DATABASE_URL is missing", async () => {
    const provider = ConfigProvider.fromMap(
      new Map([
        ["BETTER_AUTH_SECRET", "secret"],
        ["BETTER_AUTH_URL", "http://localhost"],
        ["CORS_ORIGIN", "http://localhost"],
      ])
    );

    await expect(
      Effect.runPromise(ServerConfig.pipe(Effect.withConfigProvider(provider)))
    ).rejects.toThrow();
  });

  it("should succeed with all required vars", async () => {
    const provider = ConfigProvider.fromMap(
      new Map([
        ["DATABASE_URL", "postgresql://test"],
        ["BETTER_AUTH_SECRET", "secret"],
        ["BETTER_AUTH_URL", "http://localhost"],
        ["CORS_ORIGIN", "http://localhost"],
      ])
    );

    const result = await Effect.runPromise(
      ServerConfig.pipe(Effect.withConfigProvider(provider))
    );

    expect(result.BETTER_AUTH_URL).toBe("http://localhost");
    expect(result.NODE_ENV).toBe("development"); // default
  });
});
```

### E2E Test with Error Detection

```typescript
// apps/web/tests/e2e/fixtures.ts
import { test as base, expect } from "@playwright/test";

export const test = base.extend({
  page: async ({ page }, use) => {
    const errors: string[] = [];

    page.on("console", (msg) => {
      if (msg.type() === "error") {
        errors.push(`[console] ${msg.text()}`);
      }
    });

    page.on("pageerror", (error) => {
      errors.push(`[page] ${error.message}`);
    });

    await use(page);

    expect(errors, "No page errors expected").toStrictEqual([]);
  },
});

export { expect };

// apps/web/tests/e2e/home.e2e.test.ts
import { test, expect } from "./fixtures";

test("homepage loads without errors", async ({ page }) => {
  await page.goto("/");
  await expect(page).toHaveURL("/");
  // Error detection happens automatically via fixture
});
```

## State of the Art

| Old Approach           | Current Approach           | When Changed | Impact              |
| ---------------------- | -------------------------- | ------------ | ------------------- |
| dotenv + manual checks | Effect Config validation   | Phase 3.1    | Type-safe env       |
| jest.mock              | vi.mock (Vitest)           | Phase 1      | Better ESM support  |
| Manual error capture   | Playwright page events     | Current      | Comprehensive       |

**Deprecated/outdated:**

- `dotenv` direct usage in packages/env: Should be removed per CODE_REVIEW.md
  issue #2 (it's a dependency but may not be needed post Effect Config
  integration)

## Open Questions

Things that couldn't be fully resolved:

1. **dotenv dependency in packages/env**

   - What we know: dotenv is listed as dependency, `import "dotenv/config"` at
     top of server.ts
   - What's unclear: Is this still needed? Effect Config reads from process.env,
     but does it handle .env file loading?
   - Recommendation: Test if removing `import "dotenv/config"` breaks local dev.
     If so, keep it. If not, remove the import AND the dependency.

2. **E2E test scope for "app error detection"**
   - What we know: Current test just checks URL, doesn't catch console/page
     errors
   - What's unclear: What specific error is occurring at localhost:3001? The
     CODE_REVIEW mentions it but doesn't detail the error.
   - Recommendation: First implement error detection fixture, then investigate
     and document the specific error in the TDD test.

## Sources

### Primary (HIGH confidence)

- Vitest Mocking Guide - vi.mock, vi.stubEnv patterns
- Effect Documentation - Config module, ConfigProvider for testing
- Playwright Documentation - page.on('pageerror'), page.on('console')
- Existing project code: `packages/core/src/auth/auth.test.ts` (vi.mock pattern)
- Existing project code: `packages/env/src/server.ts` (Effect Config usage)

### Secondary (MEDIUM confidence)

- [Vitest Mocking Guide](https://vitest.dev/guide/mocking) - vi.stubEnv,
  vi.unstubAllEnvs
- [Effect Configuration Docs](https://effect.website/docs/configuration/) -
  Config.all, ConfigProvider
- [Playwright Console/Error Events](https://alisterscott.github.io/Automatede2eTesting/AutomaticallyCheckingForPlaywrightConsoleErrors.html) -
  Community pattern for error detection fixture

### Tertiary (LOW confidence)

- TDD best practices from various blog posts - general guidance, not
  project-specific

## TDD Practice Documentation (for TESTING.md)

The following section should be added to TESTING.md:

### TDD Workflow: Red-Green-Refactor

1. **RED**: Write a failing test that describes the behavior you want
2. **GREEN**: Write the minimum code to make the test pass
3. **REFACTOR**: Clean up while keeping tests green

**Why "red first" matters:**

- Proves the test actually tests something (false passes are dangerous)
- Forces you to think about the interface before implementation
- Creates documentation of expected behavior

**Example workflow:**

```bash
# 1. Write the test (it should fail)
pnpm test:unit -- --run src/feature.test.ts
# Expected: FAIL - feature not implemented yet

# 2. Implement the feature
# ... write code ...

# 3. Run test again (it should pass)
pnpm test:unit -- --run src/feature.test.ts
# Expected: PASS

# 4. Refactor if needed, keep tests green
```

## Comment Standards Documentation (for CONVENTIONS.md)

The following section should be added to CONVENTIONS.md:

### Comment Standards

**Explain WHY, not WHAT:**

```typescript
// BAD: Restates the code
// Validate input
const result = schema.parse(input);

// GOOD: Explains the purpose
// Prevent injection attacks - user input must match expected schema
const result = schema.parse(input);
```

**Avoid archaeological comments:**

```typescript
// BAD: References historical context, not current purpose
// SEC-001 fix
// Removed in refactor #123

// GOOD: Explains current purpose or remove entirely
// Rate limiting prevents abuse of expensive AI operations
```

**When to comment:**

- Non-obvious business logic
- Complex algorithms
- Security-critical code (explain the threat model)
- Workarounds for external bugs (link to issue)

**When NOT to comment:**

- Self-explanatory code
- Historical references (use git history)
- TODOs without issue links (create an issue instead)

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH - all tools already in project
- Architecture: HIGH - patterns exist in codebase
- Pitfalls: MEDIUM - based on common issues, not project-specific incidents

**Research date:** 2026-01-21
**Valid until:** 60 days (stable patterns, unlikely to change)
