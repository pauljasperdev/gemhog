---
phase: 03.4-integration-test-coverage
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/package.json
  - packages/core/src/drizzle/connection.int.test.ts
autonomous: true

must_haves:
  truths:
    - "connection.int.test.ts uses Effect DatabaseLive layer (not manual pg.Pool)"
    - "Tests verify database queries work through Effect layer composition"
  artifacts:
    - path: "packages/core/src/drizzle/connection.int.test.ts"
      provides: "Effect-based database connection tests"
      contains: "DatabaseLive"
      min_lines: 30
  key_links:
    - from: "packages/core/src/drizzle/connection.int.test.ts"
      to: "packages/core/src/drizzle/index.ts"
      via: "DatabaseLive layer import"
      pattern: "import.*DatabaseLive"
---

<objective>
Update connection.int.test.ts to use Effect layers

Purpose: Test database connectivity through the actual Effect layers (DatabaseLive) that the application uses, rather than manual pg.Pool creation. This validates the Effect layer composition works correctly.

Output: Refactored connection.int.test.ts using Effect.runPromise and DatabaseLive layer.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.4-integration-test-coverage/03.4-CONTEXT.md
@.planning/phases/03.4-integration-test-coverage/03.4-RESEARCH.md
@packages/core/src/drizzle/index.ts
@packages/core/src/drizzle/client.ts
@packages/core/src/drizzle/connection.int.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor connection.int.test.ts to use Effect layers</name>
  <files>packages/core/src/drizzle/connection.int.test.ts</files>
  <action>
Refactor the existing connection.int.test.ts to use Effect layers instead of manual pg.Pool creation.

Current state: Creates manual pg.Pool and drizzle instance in beforeAll/afterAll.

Target state: Use Effect.runPromise with DatabaseLive layer for each test.

Implementation approach:
1. Import Effect from "effect"
2. Import PgDrizzle from "@effect/sql-drizzle/Pg" for the Drizzle service
3. Import DatabaseLive from "./index"
4. Remove manual pool/db creation in beforeAll/afterAll
5. Each test uses Effect.gen + Effect.runPromise pattern:
   ```typescript
   it("should connect via Effect layer", async () => {
     const program = Effect.gen(function* () {
       const db = yield* PgDrizzle.PgDrizzle;
       // db.execute returns Effect, so need tryPromise or direct await
       const result = yield* Effect.tryPromise(() =>
         db.execute(sql`SELECT 1 as value`)
       );
       return result;
     }).pipe(Effect.provide(DatabaseLive));

     const result = await Effect.runPromise(program);
     expect(result.rows[0]).toEqual({ value: 1 });
   });
   ```

Note: PgLive uses Config.redacted("DATABASE_URL") which reads from process.env at layer construction time. DATABASE_URL is set by the integration test setup.

Alternative if PgDrizzle approach is complex: Use @effect/sql-pg's PgClient.PgClient service directly for raw SQL queries. Both approaches validate layer composition works.
  </action>
  <verify>Run `pnpm test:integration --filter=@gemhog/core` and verify connection.int.test.ts passes with Effect-based tests</verify>
  <done>connection.int.test.ts uses Effect.runPromise with DatabaseLive layer, no manual pg.Pool</done>
</task>

</tasks>

<verification>
1. Run `pnpm test:integration --filter=@gemhog/core` - all tests pass
2. Verify connection.int.test.ts imports DatabaseLive (grep for "DatabaseLive")
3. Verify no manual pg.Pool creation (grep should NOT find "new pg.Pool")
4. Type check passes: `pnpm check-types`
</verification>

<success_criteria>
- connection.int.test.ts uses Effect layers (DatabaseLive) instead of manual pool
- Tests execute queries through Effect layer composition
- All integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03.4-integration-test-coverage/03.4-02-SUMMARY.md`
</output>
