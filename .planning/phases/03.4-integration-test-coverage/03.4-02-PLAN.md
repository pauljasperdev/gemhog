---
phase: 03.4-integration-test-coverage
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/drizzle/connection.int.test.ts
  - packages/core/package.json
autonomous: true

must_haves:
  truths:
    - "connection.int.test.ts uses @effect/vitest layer() function"
    - "Tests use TestPgLive with explicit URL (bypasses Config.redacted)"
    - "Tests verify database queries work through Effect layer composition"
  artifacts:
    - path: "packages/core/src/drizzle/connection.int.test.ts"
      provides: "Effect-based database connection tests using @effect/vitest"
      contains: "@effect/vitest"
      min_lines: 30
  key_links:
    - from: "packages/core/src/drizzle/connection.int.test.ts"
      to: "@effect/vitest"
      via: "layer() import"
      pattern: "import.*layer.*from.*@effect/vitest"
---

<objective>
Update connection.int.test.ts to use @effect/vitest layer() pattern

Purpose: Test database connectivity through Effect layers using the official @effect/vitest testing library. This provides proper Effect test context, timeouts, and cleanup.

Output: Refactored connection.int.test.ts using @effect/vitest layer() function with test-specific PgClient layer.

**Code type:** Effect runtime code â€” MUST be tested with Effect patterns.
The DatabaseLive layer is Effect code that the application uses at runtime. Tests must use Effect patterns. Using @effect/vitest provides the cleanest integration with Vitest.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.4-integration-test-coverage/03.4-CONTEXT.md
@.planning/phases/03.4-integration-test-coverage/03.4-RESEARCH.md
@packages/core/src/drizzle/index.ts
@packages/core/src/drizzle/client.ts
@packages/core/src/drizzle/connection.int.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add @effect/vitest dependency</name>
  <files>packages/core/package.json</files>
  <action>
Add @effect/vitest as a dev dependency to packages/core.

```bash
cd packages/core && pnpm add -D @effect/vitest
```

This provides the `layer()` and `it.effect()` test helpers for Effect testing.
  </action>
  <verify>Check packages/core/package.json contains @effect/vitest in devDependencies</verify>
  <done>@effect/vitest added to packages/core devDependencies</done>
</task>

<task type="auto">
  <name>Task 2: Refactor connection.int.test.ts to use @effect/vitest</name>
  <files>packages/core/src/drizzle/connection.int.test.ts</files>
  <action>
Refactor the existing connection.int.test.ts to use @effect/vitest layer() pattern.

Current state: Creates manual pg.Pool and drizzle instance in beforeAll/afterAll.

Target state: Use @effect/vitest layer() with test-specific PgClient layer.

Implementation pattern (from RESEARCH.md):
```typescript
import { it, layer, expect } from "@effect/vitest";
import { Effect } from "effect";
import { SqlClient } from "@effect/sql";
import { PgClient } from "@effect/sql-pg";
import { describe } from "vitest";

// Test layer with explicit URL (bypasses Config.redacted)
const TestPgLive = PgClient.layer({
  url: process.env.DATABASE_URL
    ?? "postgresql://postgres:password@localhost:5432/gemhog_test",
});

layer(TestPgLive)("database connection (Effect)", (it) => {
  it.effect("should connect and execute query", () =>
    Effect.gen(function* () {
      const sql = yield* SqlClient.SqlClient;
      const result = yield* sql`SELECT 1 as value`;
      expect(result[0]?.value).toBe(1);
    })
  );

  it.effect("should return current timestamp", () =>
    Effect.gen(function* () {
      const sql = yield* SqlClient.SqlClient;
      const result = yield* sql`SELECT NOW() as now`;
      expect(result[0]?.now).toBeInstanceOf(Date);
    })
  );
});
```

**Key insight:** Use `PgClient.layer()` with explicit URL instead of `PgClient.layerConfig()`. This bypasses `Config.redacted()` which would require a ConfigProvider.

**Critical:** The test layer uses the same @effect/sql-pg primitives as DatabaseLive but with hardcoded URL for test isolation. This validates the Effect patterns work correctly.

Remove manual pool/db creation in beforeAll/afterAll - layer() handles setup/teardown.
  </action>
  <verify>Run `pnpm test:integration --filter=@gemhog/core` and verify connection.int.test.ts passes with @effect/vitest tests</verify>
  <done>connection.int.test.ts uses @effect/vitest layer() pattern, no manual pg.Pool</done>
</task>

</tasks>

<verification>
1. Run `pnpm test:integration --filter=@gemhog/core` - all tests pass
2. Verify connection.int.test.ts imports from @effect/vitest (grep for "@effect/vitest")
3. Verify no manual pg.Pool creation (grep should NOT find "new pg.Pool" in connection.int.test.ts)
4. Type check passes: `pnpm check-types`
</verification>

<success_criteria>
- connection.int.test.ts uses @effect/vitest layer() pattern
- TestPgLive uses explicit URL (not Config.redacted)
- Tests execute queries through Effect layer composition
- All integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03.4-integration-test-coverage/03.4-02-SUMMARY.md`
</output>
