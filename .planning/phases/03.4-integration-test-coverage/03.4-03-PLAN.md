---
phase: 03.4-integration-test-coverage
plan: 03
type: execute
wave: 2
depends_on: ["03.4-01"]
files_modified:
  - packages/core/src/auth/auth.int.test.ts
  - packages/core/src/auth/test-fixtures.ts
autonomous: true

must_haves:
  truths:
    - "Auth signup creates user and returns session via better-auth API"
    - "Auth signin authenticates valid credentials and rejects invalid"
    - "Duplicate email signup is rejected"
    - "Test isolation via table truncation before each test"
  artifacts:
    - path: "packages/core/src/auth/auth.int.test.ts"
      provides: "Auth flow integration tests"
      min_lines: 80
    - path: "packages/core/src/auth/test-fixtures.ts"
      provides: "Test data factory functions"
      exports: ["createTestUser", "truncateAuthTables"]
  key_links:
    - from: "packages/core/src/auth/auth.int.test.ts"
      to: "packages/core/src/auth/auth.service.ts"
      via: "getAuth import"
      pattern: "import.*getAuth.*from.*auth\\.service"
    - from: "packages/core/src/auth/auth.int.test.ts"
      to: "packages/core/src/auth/test-fixtures.ts"
      via: "fixture import"
      pattern: "import.*truncateAuthTables"
---

<objective>
Add auth flow integration tests

Purpose: Test real authentication flows (signup, signin, signout) through better-auth API against the actual database. This validates the auth service works end-to-end.

Output: New auth.int.test.ts with signup/signin tests, test-fixtures.ts with reusable test utilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.4-integration-test-coverage/03.4-CONTEXT.md
@.planning/phases/03.4-integration-test-coverage/03.4-RESEARCH.md
@packages/core/src/auth/auth.service.ts
@packages/core/src/auth/auth.sql.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test fixtures for auth tests</name>
  <files>packages/core/src/auth/test-fixtures.ts</files>
  <action>
Create test fixture utilities for auth integration tests.

Per CONTEXT.md decisions:
- Factories live with their domain (packages/core/src/auth/test-fixtures.ts)
- Truncate tables before each test (not after)
- Single shared database (gemhog_test)
- Preserve __drizzle_migrations table during truncation

Implementation:
1. Create test-fixtures.ts in packages/core/src/auth/
2. Export truncateAuthTables(db) function that truncates user, session, account, verification tables with CASCADE
3. Export createTestUser({ email?, password?, name? }) factory that returns test user data object (NOT actually create in DB - just returns the input data for signup)
4. Use sql.raw() for TRUNCATE to handle table names with CASCADE

Example:
```typescript
export async function truncateAuthTables(db: NodePgDatabase) {
  // Truncate in reverse dependency order, or use CASCADE
  await db.execute(sql`TRUNCATE TABLE session, account, verification, "user" CASCADE`);
}

export function createTestUser(overrides?: Partial<TestUserInput>) {
  return {
    email: overrides?.email ?? `test-${Date.now()}@example.com`,
    password: overrides?.password ?? "password123",
    name: overrides?.name ?? "Test User",
  };
}
```
  </action>
  <verify>File exists and exports both functions. Type check passes.</verify>
  <done>test-fixtures.ts exports truncateAuthTables and createTestUser</done>
</task>

<task type="auto">
  <name>Task 2: Create auth flow integration tests</name>
  <files>packages/core/src/auth/auth.int.test.ts</files>
  <action>
Create integration tests for auth flows using better-auth API.

Per CONTEXT.md decisions:
- Test core flows only: signup (email/password), signin, signout
- Verify via response only - don't query DB to check state
- Test error cases: invalid credentials + validation errors
- Truncate tables before each test

Implementation:
1. Create auth.int.test.ts in packages/core/src/auth/
2. Import getAuth from ./auth.service
3. Import truncateAuthTables, createTestUser from ./test-fixtures
4. Create pool/db in beforeAll, close in afterAll
5. Call truncateAuthTables in beforeEach

Test cases to implement:
- describe("signup")
  - it("should create user via email/password") - call auth.api.signUpEmail, verify result.user and result.session exist
  - it("should reject duplicate email") - signup twice with same email, second should throw

- describe("signin")
  - it("should authenticate valid credentials") - signup then signin, verify session returned
  - it("should reject invalid password") - signup then signin with wrong password, should throw
  - it("should reject non-existent user") - signin without signup, should throw

Use getAuth() to get the better-auth instance, then call auth.api.signUpEmail({ body: {...} }) and auth.api.signInEmail({ body: {...} }).

Note: better-auth password hashing adds ~100-150ms per signup. Tests will be slower than pure mocked tests - this is expected for integration tests.
  </action>
  <verify>Run `pnpm test:integration --filter=@gemhog/core` and verify auth.int.test.ts passes with all 5 test cases</verify>
  <done>auth.int.test.ts has 5 test cases covering signup success, duplicate rejection, signin success, invalid password, non-existent user</done>
</task>

</tasks>

<verification>
1. Run `pnpm test:integration --filter=@gemhog/core` - auth.int.test.ts passes
2. Verify test isolation: run tests twice in a row, both should pass (truncation works)
3. Type check passes: `pnpm check-types`
</verification>

<success_criteria>
- auth.int.test.ts has 5+ test cases covering signup and signin flows
- test-fixtures.ts provides reusable truncation and factory functions
- Tests verify via response only (no DB queries to check state)
- All integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03.4-integration-test-coverage/03.4-03-SUMMARY.md`
</output>
