---
phase: 03.4-integration-test-coverage
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/auth/schema.int.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Tests import schema definitions from auth.sql.ts"
    - "Tests insert data using drizzle's typed insert API"
    - "Tests query data using drizzle's typed select API"
    - "Tests verify relationships between user/session/account tables"
    - "Tests use @effect/vitest layer() pattern for database access"
  artifacts:
    - path: "packages/core/src/auth/schema.int.test.ts"
      provides: "Schema CRUD tests using auth.sql.ts definitions"
      contains: "auth.sql"
      min_lines: 80
  key_links:
    - from: "packages/core/src/auth/schema.int.test.ts"
      to: "packages/core/src/auth/auth.sql.ts"
      via: "schema import"
      pattern: "import.*from.*auth\\.sql"
---

<objective>
Add schema CRUD tests using auth.sql.ts definitions

Purpose: Test the drizzle schema definitions directly via typed CRUD operations. This verifies the schema works correctly independent of better-auth.

Output: New schema.int.test.ts with tests that insert/query using the typed drizzle API.

**Gap identified:** Current tests verify tables exist (migrations.int.test.ts) and test via better-auth API (auth.int.test.ts), but no tests verify the schema definitions work correctly via direct drizzle operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@packages/core/src/auth/auth.sql.ts
@packages/core/src/drizzle/connection.int.test.ts
@packages/core/src/auth/test-fixtures.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schema CRUD integration tests</name>
  <files>packages/core/src/auth/schema.int.test.ts</files>
  <action>
Create integration tests that directly test the schema definitions from auth.sql.ts.

Use @effect/vitest with drizzle for typed operations. The tests should:

1. Import schema tables from auth.sql.ts:
   ```typescript
   import { user, session, account, verification } from "./auth.sql";
   ```

2. Use @effect/vitest layer() with drizzle:
   ```typescript
   import { layer, it, expect } from "@effect/vitest";
   import { Effect } from "effect";
   import { SqlClient } from "@effect/sql";
   import { PgClient } from "@effect/sql-pg";
   import { drizzle } from "drizzle-orm/node-postgres";
   ```

3. Test cases:

   describe("user table")
   - it("should insert and query user") - insert user, select by id, verify fields
   - it("should enforce unique email constraint") - insert duplicate email, expect error

   describe("session table")
   - it("should insert session linked to user") - create user, create session with userId, verify relationship
   - it("should enforce foreign key to user") - insert session with non-existent userId, expect error

   describe("account table")
   - it("should insert account linked to user") - create user, create account with userId
   - it("should store provider info correctly") - verify providerId, accountId fields

4. Use truncateAuthTables from test-fixtures.ts in beforeEach for isolation

**Important:**
- Use drizzle's typed API: `db.insert(user).values({...})`, `db.select().from(user).where(...)`
- Tests should use the Effect layer for database connection
- The drizzle instance needs to be created within the Effect context or use a separate setup

Pattern for combining @effect/vitest with drizzle:
```typescript
import { drizzle } from "drizzle-orm/node-postgres";
import pg from "pg";

// Create pool for drizzle (separate from Effect's PgClient)
const pool = new pg.Pool({ connectionString: process.env.DATABASE_URL });
const db = drizzle(pool);

// Use standard vitest describe/it with the drizzle db
describe("schema tests", () => {
  beforeAll(async () => { /* pool setup */ });
  afterAll(async () => { await pool.end(); });
  beforeEach(async () => { await truncateAuthTables(db); });

  it("should insert user", async () => {
    const [inserted] = await db.insert(user).values({
      id: "test-id",
      email: "test@example.com",
      name: "Test User",
      emailVerified: false,
      createdAt: new Date(),
      updatedAt: new Date(),
    }).returning();

    expect(inserted.email).toBe("test@example.com");
  });
});
```

Note: This uses direct drizzle (not Effect) because we're testing the schema definitions themselves. The connection.int.test.ts already tests the Effect SQL layer.
  </action>
  <verify>Run `pnpm test:integration --filter=@gemhog/core` and verify schema.int.test.ts passes</verify>
  <done>schema.int.test.ts has CRUD tests using auth.sql.ts schema definitions</done>
</task>

</tasks>

<verification>
1. Run `pnpm test:integration` - schema.int.test.ts passes
2. Verify tests import from auth.sql.ts
3. Verify tests use drizzle's typed API (insert, select, where)
4. Verify constraint tests (unique email, foreign keys)
5. Type check passes: `pnpm check-types`
</verification>

<success_criteria>
- schema.int.test.ts tests CRUD operations using auth.sql.ts definitions
- Tests verify user, session, account tables work correctly
- Tests verify constraints (unique, foreign keys)
- All integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03.4-integration-test-coverage/03.4-07-SUMMARY.md`
</output>
