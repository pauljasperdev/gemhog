# Phase 3.4: Integration Test Coverage - Context

**Gathered:** 2026-01-22
**Status:** Ready for planning

<domain>
## Phase Boundary

Close integration test coverage gaps: fix db:migrate env loading, update connection.int.test.ts to use Effect layers, test migration apply/rollback, add auth flow integration tests, and add real tRPC procedure tests.

</domain>

<decisions>
## Implementation Decisions

### Test Isolation Strategy
- Truncate tables before each test (not after) — clean slate for every test
- Single shared database (`gemhog_test`) for all packages
- Sequential test execution (no parallelism) — simpler, no race conditions
- Longer timeout for integration tests (30s vs unit test default)
- On test failure, database state is preserved for debugging (agent can inspect)
- Shared factory functions for test data (`createTestUser()`, etc.)
- Factories live with their domain (e.g., `packages/core/src/auth/test-fixtures.ts`)
- Migration runner is shared code (same logic for production deploy and test setup)
- Infrastructure started via pnpm scripts

### Auth Flow Coverage
- Test core flows only: signup (email/password), signin, signout
- Test both levels: direct better-auth API calls AND HTTP endpoint calls
- Verify via response only — don't query DB to check state
- Test error cases: invalid credentials + validation errors

### tRPC Test Approach
- Test both ways: direct tRPC caller AND HTTP /api/trpc/* requests
- Use mock context for auth (fake user/session object, not real sessions)
- Test ALL procedures (full coverage, not just sampling)
- Verify unauthorized access returns correct auth errors

### Migration Testing
- Test both apply AND rollback operations
- Verify resulting schema via information_schema queries
- Use PostgreSQL 16.x (same as production)

### Effect vs Edge Code Testing Strategy

**Principle:** Effect code should be tested with Effect patterns. Edge/boundary code can use direct testing.

**What is Effect code (test with Effect):**
- `packages/core/src/drizzle/` — DatabaseLive, PgLive, DrizzleLive layers
- Future business logic in core — will use Effect for DI and error handling
- Runtime query execution — uses @effect/sql-drizzle

**What is Edge code (test directly):**
- Auth (better-auth) — no Effect wrapper, lives at HTTP boundary
- tRPC router — thin API wrapper, not Effect code internally
- drizzle-kit migrations — CLI tooling, not Effect runtime

**What is CLI tooling (test directly):**
- drizzle-kit (`drizzle.config.ts`) — generates and applies migrations
- Keep using drizzle-kit for migrations — good tooling, well-documented
- @effect/sql-drizzle is for runtime queries, not migration tooling

**Testing approach by code type:**
| Code Type | Example | Testing Pattern |
|-----------|---------|-----------------|
| Effect layers | DatabaseLive | Effect.runPromise + provide layer |
| Edge code | getAuth(), appRouter | Direct API calls |
| CLI tooling | drizzle-kit migrate | Direct drizzle-orm migrate() |

### Claude's Discretion
- Test fixture export approach (subpath export vs internal only)
- Which tables to preserve during truncate (migration tables, etc.)
- Migration auto-run behavior (auto on Docker start vs explicit call)
- Specific factory function signatures and patterns

</decisions>

<specifics>
## Specific Ideas

- "Tests will be mainly executed by an agent, so preserving DB state on failure helps the agent inspect and debug"
- Migration runner should be reusable code — same file can run for production deploy, test setup, and CLI command
- Factory functions should live with their domain so schema changes and fixture changes happen together

</specifics>

<deferred>
## Deferred Ideas

None — discussion stayed within phase scope

</deferred>

---

*Phase: 03.4-integration-test-coverage*
*Context gathered: 2026-01-22*
