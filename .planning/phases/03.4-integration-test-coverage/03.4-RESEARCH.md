# Phase 3.4: Integration Test Coverage - Research

**Researched:** 2026-01-22
**Domain:** Integration testing, database migrations, authentication flows, tRPC testing
**Confidence:** HIGH

## Summary

This research investigates the current state of integration tests in the gemhog monorepo and identifies gaps to close. The codebase has a solid testing foundation (Vitest unit tests, Playwright E2E) but lacks coverage in several critical areas: db:migrate fails from monorepo root, connection.int.test.ts uses manual pool creation instead of Effect layers, no migration tests exist, no auth flow tests exist, and packages/api has only placeholder tests.

The primary issue with `pnpm db:migrate` is that `drizzle.config.ts` imports `@gemhog/env/server` which validates ALL server env vars, but drizzle-kit only needs `DATABASE_URL`. The solution is to create a minimal env loader for drizzle-kit or use dotenv directly in drizzle.config.ts.

**Primary recommendation:** Create focused integration tests that cover: (1) fix drizzle.config.ts to load only DATABASE_URL, (2) update connection.int.test.ts to use Effect DatabaseLive layer, (3) add migration apply/rollback tests using drizzle-orm migrate function, (4) add auth integration tests using better-auth API, (5) add real tRPC procedure tests using createCaller.

## Current State Analysis

### Success Criterion 1: `pnpm db:migrate` works from monorepo root

**Current state:** FAILING
**Root cause:** `drizzle.config.ts` imports `@gemhog/env/server` which requires ALL env vars (DATABASE_URL, BETTER_AUTH_SECRET, BETTER_AUTH_URL, CORS_ORIGIN), but drizzle-kit only needs DATABASE_URL.

```typescript
// packages/core/drizzle.config.ts (current)
import { env } from "@gemhog/env/server";  // <-- Requires ALL server env vars
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/*/*.sql.ts",
  out: "./src/migrations",
  dialect: "postgresql",
  dbCredentials: {
    url: env.DATABASE_URL,  // Only needs this one
  },
});
```

**Error output:**
```
Invalid environment variables: [
  { path: [ 'DATABASE_URL' ], message: 'Invalid input: expected string, received undefined' },
  { path: [ 'BETTER_AUTH_SECRET' ], message: '...' },
  { path: [ 'BETTER_AUTH_URL' ], message: '...' },
  { path: [ 'CORS_ORIGIN' ], message: '...' }
]
```

### Success Criterion 2: connection.int.test.ts uses Effect layers

**Current state:** NOT USING EFFECT LAYERS
**File:** `/home/lima/repo/packages/core/src/drizzle/connection.int.test.ts`

Current implementation creates manual pg.Pool:
```typescript
// Current (manual pool creation)
import pg from "pg";
let pool: pg.Pool;
let db: ReturnType<typeof drizzle>;

beforeAll(() => {
  const connectionString = process.env.DATABASE_URL || "...";
  pool = new pg.Pool({ connectionString });
  db = drizzle(pool);
});
```

Effect layers exist but are unused in tests:
```typescript
// packages/core/src/drizzle/index.ts (available)
export const DatabaseLive = Layer.mergeAll(PgLive, DrizzleLive);
```

### Success Criterion 3: Migration application is tested

**Current state:** NO MIGRATION TESTS EXIST
**Migration files exist:** `/home/lima/repo/packages/core/src/migrations/0000_initial_schema.sql`

The codebase has migrations generated but no tests verify:
- Migrations apply successfully
- Schema matches expected state after migration
- Rollback works (if supported)

### Success Criterion 4: Auth signup/signin flow has integration tests

**Current state:** NO AUTH INTEGRATION TESTS
**Only unit test exists:** `/home/lima/repo/packages/core/src/auth/auth.test.ts` (mocked, just checks exports)

better-auth is configured in `auth.service.ts`:
- Email/password authentication enabled
- Uses drizzle adapter with PostgreSQL
- HTTP-only secure cookies for sessions

### Success Criterion 5: packages/api has real tRPC procedure tests

**Current state:** PLACEHOLDER TEST ONLY
**File:** `/home/lima/repo/packages/api/src/example.test.ts`

```typescript
// Current placeholder test
describe("example", () => {
  it("should pass a basic test", () => {
    expect(1 + 1).toBe(2);
  });
});
```

Actual procedures exist:
- `healthCheck` (public) - returns "OK"
- `privateData` (protected) - returns message + user, requires session

## Standard Stack

### Core Testing Libraries

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| vitest | ^4.0.17 | Test runner | Already in use, Effect-compatible |
| @effect/vitest | ^0.22 | Effect test utilities | Official Effect testing integration |
| drizzle-orm | ^0.45.1 | ORM + migrate function | Already in use, programmatic migrations |
| pg | ^8.16.3 | PostgreSQL client | Already in use |

### Supporting Libraries

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| dotenv | catalog: | Env loading for drizzle-kit | drizzle.config.ts standalone |

**No new dependencies required** - all testing can be done with existing stack.

## Architecture Patterns

### Recommended Test File Structure

```
packages/core/src/
├── drizzle/
│   ├── connection.int.test.ts    # Effect layer database tests
│   └── migrations.int.test.ts    # NEW: Migration apply/rollback tests
├── auth/
│   ├── auth.test.ts              # Unit tests (mocked)
│   └── auth.int.test.ts          # NEW: Real auth flow tests

packages/api/src/
├── routers/
│   └── procedures.int.test.ts    # NEW: Real tRPC procedure tests
```

### Pattern 1: Effect Layer Testing with @effect/vitest

```typescript
// Source: https://github.com/Effect-TS/effect/blob/main/packages/vitest/README.md
import { it } from "@effect/vitest";
import { Effect } from "effect";
import { DatabaseLive } from "./index";

it.scoped("should execute query with Effect layer", () =>
  Effect.gen(function* () {
    const result = yield* Effect.succeed("test");
    expect(result).toBe("test");
  }).pipe(Effect.provide(DatabaseLive))
);
```

**Decision context:** The codebase previously used @effect/vitest but removed it in 03.1-05 because auth was simplified. Now it's needed again for testing DatabaseLive layer. Add it back.

### Pattern 2: Programmatic Migration with drizzle-orm

```typescript
// Source: https://orm.drizzle.team/docs/migrations
import { drizzle } from "drizzle-orm/node-postgres";
import { migrate } from "drizzle-orm/node-postgres/migrator";

const db = drizzle(process.env.DATABASE_URL);
await migrate(db, { migrationsFolder: "./src/migrations" });
```

**Key insight:** The `migrate()` function from drizzle-orm/node-postgres/migrator is for runtime migrations. It's different from drizzle-kit CLI which is for development.

### Pattern 3: tRPC Testing with createCaller

```typescript
// Source: https://trpc.io/docs/v10/server/server-side-calls
import { appRouter } from "@gemhog/api/routers";

// For public procedures
const publicCaller = appRouter.createCaller({ session: null });
const result = await publicCaller.healthCheck();

// For protected procedures (mock session)
const protectedCaller = appRouter.createCaller({
  session: {
    user: { id: "test-user-id", name: "Test User", email: "test@example.com" },
    expires: "2099-01-01T00:00:00.000Z",
  },
});
const data = await protectedCaller.privateData();
```

### Pattern 4: better-auth Testing via API

```typescript
// Source: https://www.better-auth.com/docs/basic-usage
import { getAuth } from "@gemhog/core/auth";

const auth = getAuth();

// Direct API call for signup
const signupResult = await auth.api.signUpEmail({
  body: {
    email: "test@example.com",
    password: "password123",
    name: "Test User",
  },
});

// Direct API call for signin
const signinResult = await auth.api.signInEmail({
  body: {
    email: "test@example.com",
    password: "password123",
  },
});
```

### Anti-Patterns to Avoid

- **Querying DB to verify auth state:** Per CONTEXT.md decision, verify via response only
- **Creating separate test databases:** Use single `gemhog_test` database with truncation
- **Running tests in parallel:** Sequential execution to avoid race conditions
- **Checking user existence in DB after signup:** Verify via response status/cookies

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Test user creation | Manual SQL inserts | better-auth API signup | Proper password hashing, session creation |
| Migration tracking | Custom journal table | drizzle-orm migrate() | Already tracks in __drizzle_migrations |
| Effect test utilities | Manual Effect.runPromise | @effect/vitest | Proper resource cleanup, test context |
| tRPC context mocking | Custom middleware bypass | createCaller with mock context | Official pattern, type-safe |

**Key insight:** better-auth's password hashing adds ~100-150ms per signup. For test performance, consider creating users once per test file rather than per test case.

## Common Pitfalls

### Pitfall 1: drizzle.config.ts env loading

**What goes wrong:** drizzle.config.ts imports full env validation that requires all server vars
**Why it happens:** @gemhog/env/server validates DATABASE_URL + BETTER_AUTH_SECRET + BETTER_AUTH_URL + CORS_ORIGIN together
**How to avoid:** Use dotenv directly in drizzle.config.ts, loading only DATABASE_URL
**Warning signs:** "Invalid environment variables" error mentioning vars other than DATABASE_URL

### Pitfall 2: Effect layer not properly provided

**What goes wrong:** Test fails with "Service not found" error
**Why it happens:** Effect programs require their dependencies to be provided via layers
**How to avoid:** Use `.pipe(Effect.provide(DatabaseLive))` or `it.layer(DatabaseLive)`
**Warning signs:** "Service not found: PgClient" or similar errors

### Pitfall 3: Test isolation with shared database

**What goes wrong:** Tests pass individually but fail when run together
**Why it happens:** Previous test data pollutes subsequent tests
**How to avoid:** Truncate tables BEFORE each test (per CONTEXT.md decision)
**Warning signs:** "duplicate key" errors, unexpected row counts

### Pitfall 4: better-auth session cookies not captured

**What goes wrong:** Auth tests pass but subsequent requests fail auth checks
**Why it happens:** better-auth sets HTTP-only cookies that need to be forwarded
**How to avoid:** Capture Set-Cookie header from signin, forward in subsequent requests
**Warning signs:** Protected endpoints return 401 after successful signin

### Pitfall 5: createCaller deprecation

**What goes wrong:** TypeScript warnings about deprecated API
**Why it happens:** `router.createCaller()` is deprecated in favor of `createCallerFactory`
**How to avoid:** Can still use `appRouter.createCaller()` - it works, just deprecated
**Warning signs:** TypeScript deprecation warnings in IDE

## Code Examples

### Fix drizzle.config.ts env loading

```typescript
// packages/core/drizzle.config.ts (recommended fix)
import "dotenv/config";
import { defineConfig } from "drizzle-kit";

// Use process.env directly - dotenv loads from apps/server/.env
const DATABASE_URL = process.env.DATABASE_URL;
if (!DATABASE_URL) {
  throw new Error("DATABASE_URL environment variable is required for drizzle-kit");
}

export default defineConfig({
  schema: "./src/*/*.sql.ts",
  out: "./src/migrations",
  dialect: "postgresql",
  dbCredentials: {
    url: DATABASE_URL,
  },
});
```

**Alternative:** Create a minimal env loader in packages/env that only validates DATABASE_URL for migration use cases.

### connection.int.test.ts with Effect layer

```typescript
// packages/core/src/drizzle/connection.int.test.ts (refactored)
import * as PgDrizzle from "@effect/sql-drizzle/Pg";
import { it } from "@effect/vitest";
import { Effect } from "effect";
import { describe, expect } from "vitest";
import { DatabaseLive } from "./index";

describe("database connection (Effect)", () => {
  it.scoped("should connect and execute a query", () =>
    Effect.gen(function* () {
      const db = yield* PgDrizzle.PgDrizzle;
      const result = yield* Effect.tryPromise(() =>
        db.execute(sql`SELECT 1 as value`)
      );
      expect(result.rows[0]).toEqual({ value: 1 });
    }).pipe(Effect.provide(DatabaseLive))
  );
});
```

### Migration integration test

```typescript
// packages/core/src/drizzle/migrations.int.test.ts (new)
import { drizzle } from "drizzle-orm/node-postgres";
import { migrate } from "drizzle-orm/node-postgres/migrator";
import pg from "pg";
import { afterAll, beforeAll, describe, expect, it } from "vitest";

describe("database migrations", () => {
  let pool: pg.Pool;
  let db: ReturnType<typeof drizzle>;

  beforeAll(async () => {
    pool = new pg.Pool({
      connectionString: process.env.DATABASE_URL
    });
    db = drizzle(pool);
  });

  afterAll(async () => {
    await pool.end();
  });

  it("should apply migrations successfully", async () => {
    // Apply migrations
    await migrate(db, {
      migrationsFolder: "./src/migrations"
    });

    // Verify schema via information_schema
    const result = await db.execute(sql`
      SELECT table_name
      FROM information_schema.tables
      WHERE table_schema = 'public'
      ORDER BY table_name
    `);

    const tables = result.rows.map(r => r.table_name);
    expect(tables).toContain("user");
    expect(tables).toContain("session");
    expect(tables).toContain("account");
    expect(tables).toContain("verification");
  });

  it("should track migrations in __drizzle_migrations", async () => {
    const result = await db.execute(sql`
      SELECT * FROM __drizzle_migrations
    `);
    expect(result.rows.length).toBeGreaterThan(0);
  });
});
```

### Auth flow integration test

```typescript
// packages/core/src/auth/auth.int.test.ts (new)
import { afterEach, beforeEach, describe, expect, it } from "vitest";
import { getAuth } from "./auth.service";
import { drizzle } from "drizzle-orm/node-postgres";
import pg from "pg";
import { sql } from "drizzle-orm";

describe("auth flows", () => {
  let pool: pg.Pool;
  let db: ReturnType<typeof drizzle>;

  beforeEach(async () => {
    pool = new pg.Pool({ connectionString: process.env.DATABASE_URL });
    db = drizzle(pool);

    // Truncate auth tables before each test
    await db.execute(sql`TRUNCATE TABLE session, account, verification, "user" CASCADE`);
  });

  afterEach(async () => {
    await pool.end();
  });

  describe("signup", () => {
    it("should create user via email/password", async () => {
      const auth = getAuth();
      const result = await auth.api.signUpEmail({
        body: {
          email: "test@example.com",
          password: "password123",
          name: "Test User",
        },
      });

      // Verify via response only (per CONTEXT.md decision)
      expect(result.user).toBeDefined();
      expect(result.user.email).toBe("test@example.com");
      expect(result.session).toBeDefined();
    });

    it("should reject duplicate email", async () => {
      const auth = getAuth();

      // First signup
      await auth.api.signUpEmail({
        body: {
          email: "test@example.com",
          password: "password123",
          name: "Test User",
        },
      });

      // Duplicate signup
      await expect(
        auth.api.signUpEmail({
          body: {
            email: "test@example.com",
            password: "password456",
            name: "Another User",
          },
        })
      ).rejects.toThrow();
    });
  });

  describe("signin", () => {
    it("should authenticate valid credentials", async () => {
      const auth = getAuth();

      // Create user first
      await auth.api.signUpEmail({
        body: {
          email: "test@example.com",
          password: "password123",
          name: "Test User",
        },
      });

      // Sign in
      const result = await auth.api.signInEmail({
        body: {
          email: "test@example.com",
          password: "password123",
        },
      });

      expect(result.session).toBeDefined();
      expect(result.user.email).toBe("test@example.com");
    });

    it("should reject invalid password", async () => {
      const auth = getAuth();

      await auth.api.signUpEmail({
        body: {
          email: "test@example.com",
          password: "password123",
          name: "Test User",
        },
      });

      await expect(
        auth.api.signInEmail({
          body: {
            email: "test@example.com",
            password: "wrongpassword",
          },
        })
      ).rejects.toThrow();
    });
  });
});
```

### tRPC procedure integration test

```typescript
// packages/api/src/routers/procedures.int.test.ts (new)
import { TRPCError } from "@trpc/server";
import { describe, expect, it } from "vitest";
import { appRouter } from "./index";

describe("tRPC procedures", () => {
  describe("healthCheck (public)", () => {
    it("should return OK without session", async () => {
      const caller = appRouter.createCaller({ session: null });
      const result = await caller.healthCheck();
      expect(result).toBe("OK");
    });
  });

  describe("privateData (protected)", () => {
    it("should return data with valid session", async () => {
      const mockSession = {
        user: {
          id: "test-user-id",
          name: "Test User",
          email: "test@example.com",
          emailVerified: true,
          image: null,
          createdAt: new Date(),
          updatedAt: new Date(),
        },
        session: {
          id: "test-session-id",
          token: "test-token",
          expiresAt: new Date(Date.now() + 86400000),
          userId: "test-user-id",
          createdAt: new Date(),
          updatedAt: new Date(),
          ipAddress: null,
          userAgent: null,
        },
      };

      const caller = appRouter.createCaller({ session: mockSession });
      const result = await caller.privateData();

      expect(result.message).toBe("This is private");
      expect(result.user.email).toBe("test@example.com");
    });

    it("should reject without session", async () => {
      const caller = appRouter.createCaller({ session: null });

      await expect(caller.privateData()).rejects.toThrow(TRPCError);

      try {
        await caller.privateData();
      } catch (e) {
        expect(e).toBeInstanceOf(TRPCError);
        expect((e as TRPCError).code).toBe("UNAUTHORIZED");
      }
    });
  });
});
```

### Table truncation utility

```typescript
// packages/core/src/test-utils.ts (new)
import { sql } from "drizzle-orm";
import type { NodePgDatabase } from "drizzle-orm/node-postgres";

// Tables to preserve during truncation (migration tracking)
const PRESERVE_TABLES = ["__drizzle_migrations"];

export async function truncateAllTables(db: NodePgDatabase) {
  // Get all user tables
  const result = await db.execute(sql`
    SELECT table_name
    FROM information_schema.tables
    WHERE table_schema = 'public'
    AND table_type = 'BASE TABLE'
  `);

  const tables = result.rows
    .map((r) => r.table_name as string)
    .filter((t) => !PRESERVE_TABLES.includes(t));

  if (tables.length > 0) {
    // Use CASCADE to handle foreign key constraints
    await db.execute(
      sql.raw(`TRUNCATE TABLE ${tables.map((t) => `"${t}"`).join(", ")} CASCADE`)
    );
  }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Effect wrapper around auth | Plain better-auth API | Phase 3.1-04 | Simpler auth testing |
| t3-env for env validation | @t3-oss/env-core | Phase 3.3 | Unified env validation |
| router.createCaller() | createCallerFactory() | tRPC v11 planning | Still works, just deprecated |

**Deprecated/outdated:**
- Effect Config in packages/env: Replaced with t3-env in Phase 3.3
- @effect/vitest in packages/core: Removed in 3.1-05, but needed again for layer tests

## Open Questions

1. **Should @effect/vitest be re-added?**
   - What we know: It was removed in 03.1-05 because auth was simplified
   - What's unclear: Is it worth adding back just for connection tests?
   - Recommendation: Can test Effect layers without @effect/vitest using Effect.runPromise, but @effect/vitest provides better error messages and resource cleanup

2. **Rollback testing for migrations?**
   - What we know: drizzle-kit has no built-in rollback
   - What's unclear: How to test rollback if Drizzle doesn't support it natively
   - Recommendation: Focus on apply testing; rollback would require custom SQL or different tooling

3. **Test database cleanup strategy?**
   - What we know: CONTEXT.md says truncate before each test
   - What's unclear: Should we use a separate test database or gemhog_test?
   - Recommendation: Use gemhog_test database, ensure docker-compose creates it

## Sources

### Primary (HIGH confidence)
- `/home/lima/repo/packages/core/drizzle.config.ts` - Current drizzle-kit configuration
- `/home/lima/repo/packages/core/src/drizzle/connection.int.test.ts` - Current test implementation
- `/home/lima/repo/packages/env/src/server.ts` - Current env validation
- `/home/lima/repo/.planning/STATE.md` - Historical decisions context

### Secondary (MEDIUM confidence)
- [Drizzle Migrations Docs](https://orm.drizzle.team/docs/migrations) - Programmatic migration API
- [tRPC Server-Side Calls](https://trpc.io/docs/v10/server/server-side-calls) - createCaller pattern
- [Better Auth Basic Usage](https://www.better-auth.com/docs/basic-usage) - Auth API

### Tertiary (LOW confidence)
- [GitHub: Better Auth Testing Issue #5609](https://github.com/better-auth/better-auth/issues/5609) - Community patterns for testing
- [@effect/vitest README](https://github.com/Effect-TS/effect/blob/main/packages/vitest/README.md) - Effect test utilities

## Metadata

**Confidence breakdown:**
- drizzle.config.ts fix: HIGH - Verified by running `pnpm db:migrate` and seeing actual error
- Effect layer testing: HIGH - DatabaseLive layer exists, @effect/vitest pattern documented
- Migration testing: HIGH - drizzle-orm migrate function is well-documented
- Auth testing: MEDIUM - better-auth API documented but testing patterns are community-driven
- tRPC testing: HIGH - createCaller is official documented pattern

**Research date:** 2026-01-22
**Valid until:** 30 days (stable libraries, documented APIs)
