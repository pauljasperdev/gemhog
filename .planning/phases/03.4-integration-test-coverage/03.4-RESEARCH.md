# Phase 3.4: Integration Test Coverage - Research

**Researched:** 2026-01-22 (Updated)
**Domain:** Integration testing (database, auth, tRPC) with Vitest + Effect + Drizzle
**Confidence:** HIGH

## Summary

This phase addresses integration test coverage gaps: fixing `db:migrate` env loading, updating connection tests to use Effect layers, testing migrations programmatically, and adding auth flow and tRPC procedure tests.

The codebase uses a modern stack: Vitest 4.x for testing, Drizzle ORM 0.45.x with node-postgres for database, Better-Auth 1.4.x for authentication, tRPC 11.x for API, and Effect 3.19.x for dependency injection. All these tools have well-documented testing patterns.

**Primary recommendation:** Use drizzle-orm's `migrate()` function for programmatic migrations in tests, `@effect/vitest` for Effect layer tests, direct Better-Auth `api` calls for auth testing, and tRPC's `createCallerFactory` for procedure tests.

## Effect vs Edge Code Testing Strategy

**Clarified during planning:** The codebase has distinct code types that require different testing approaches.

| Code Type | Location | Testing Approach | Rationale |
|-----------|----------|------------------|-----------|
| **Effect runtime** | `packages/core/src/drizzle/` (DatabaseLive) | Effect.runPromise + layer provision | Test the actual Effect layers the app uses |
| **Edge/boundary** | Auth (better-auth), tRPC router | Direct API calls | No Effect wrapper, lives at HTTP boundary |
| **CLI tooling** | drizzle-kit, drizzle.config.ts | Direct drizzle-orm | Not Effect runtime code |

**Key principle:** Effect code must be tested with Effect patterns. Do not wrap Effect code in non-Effect patterns to test it.

**drizzle-kit vs @effect/sql-drizzle:**
- **drizzle-kit** = CLI tooling for migrations (generate, push, migrate, studio). Keep using it.
- **@effect/sql-drizzle** = Runtime query execution through Effect layers. Used by app code.
- These are complementary, not competing.

## Current State Analysis

### Success Criterion 1: `pnpm db:migrate` works from monorepo root

**Current state:** FAILING
**Root cause:** `drizzle.config.ts` imports `@gemhog/env/server` which requires ALL env vars (DATABASE_URL, BETTER_AUTH_SECRET, BETTER_AUTH_URL, CORS_ORIGIN), but drizzle-kit only needs DATABASE_URL.

```typescript
// packages/core/drizzle.config.ts (current)
import { env } from "@gemhog/env/server";  // <-- Requires ALL server env vars
```

### Success Criterion 2: connection.int.test.ts uses Effect layers

**Current state:** NOT USING EFFECT LAYERS
**File:** `/home/lima/repo/packages/core/src/drizzle/connection.int.test.ts`

Current implementation creates manual pg.Pool instead of using Effect layers.

### Success Criterion 3: Migration application is tested

**Current state:** NO MIGRATION TESTS EXIST
**Migration files exist:** `/home/lima/repo/packages/core/src/migrations/0000_initial_schema.sql`

### Success Criterion 4: Auth signup/signin flow has integration tests

**Current state:** NO AUTH INTEGRATION TESTS

### Success Criterion 5: packages/api has real tRPC procedure tests

**Current state:** PLACEHOLDER TEST ONLY (`packages/api/src/example.test.ts`)

## Standard Stack

### Core Testing Libraries

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| vitest | ^4.0.17 | Test runner | Already in use, native ESM, fast |
| @effect/vitest | latest | Effect test helpers | Official Effect testing integration |
| drizzle-orm/migrator | 0.45.1 | Programmatic migrations | Built-in Drizzle feature |

### Supporting Libraries

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| pg | 8.16.3 | PostgreSQL client | Already used by drizzle/better-auth |
| @effect/sql-pg | 0.50 | Effect PgClient | For Effect layer tests |

**Installation:**
```bash
pnpm add -D @effect/vitest
```

## Architecture Patterns

### Recommended Test File Structure

```
packages/core/src/
├── drizzle/
│   ├── connection.int.test.ts    # Effect layer database tests
│   └── migrations.int.test.ts    # Migration apply tests
├── auth/
│   └── auth.int.test.ts          # Auth flow tests (signup/signin/signout)

packages/api/src/
├── routers/
│   └── index.int.test.ts         # tRPC procedure tests
```

### Pattern 1: Database Truncation Before Tests

**What:** Clean database state before each test
**When to use:** All integration tests that write to database

```typescript
// Source: https://gist.github.com/rphlmr/0d1722a794ed5a16da0fdf6652902b15
import { sql } from "drizzle-orm";

const TABLES_TO_PRESERVE = ["__drizzle_migrations"];

export async function truncateAllTables(db: ReturnType<typeof drizzle>) {
  const result = await db.execute<{ table_name: string }>(sql`
    SELECT table_name
    FROM information_schema.tables
    WHERE table_schema = 'public'
    AND table_type = 'BASE TABLE'
  `);

  const tables = result.rows
    .map((r) => r.table_name as string)
    .filter((t) => !TABLES_TO_PRESERVE.includes(t));

  if (tables.length > 0) {
    await db.execute(
      sql.raw(`TRUNCATE TABLE ${tables.map((t) => `"${t}"`).join(", ")} CASCADE`)
    );
  }
}
```

### Pattern 2: Effect Layer Testing with @effect/vitest

**What:** Test Effect programs with proper layer provision
**When to use:** Testing code that uses Effect services (DatabaseLive, PgLive)

```typescript
// Source: https://github.com/Effect-TS/effect/blob/main/packages/vitest/README.md
import { it, layer, expect } from "@effect/vitest";
import { Effect, ConfigProvider, Layer } from "effect";
import { SqlClient } from "@effect/sql";
import { PgClient } from "@effect/sql-pg";

// Create test layer with explicit config (bypasses Config.redacted)
const TestPgLive = PgClient.layer({
  url: process.env.DATABASE_URL ?? "postgresql://postgres:password@localhost:5432/gemhog_test",
});

layer(TestPgLive)("Database connection via Effect", (it) => {
  it.effect("should execute query", () =>
    Effect.gen(function* () {
      const sql = yield* SqlClient.SqlClient;
      const result = yield* sql`SELECT 1 as value`;
      expect(result[0]?.value).toBe(1);
    })
  );
});
```

### Pattern 3: Programmatic Migrations with drizzle-orm

**What:** Apply migrations from code instead of CLI
**When to use:** Test setup, migration testing

```typescript
// Source: https://orm.drizzle.team/docs/migrations
import { drizzle } from "drizzle-orm/node-postgres";
import { migrate } from "drizzle-orm/node-postgres/migrator";
import { Pool } from "pg";

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const db = drizzle(pool);

await migrate(db, {
  migrationsFolder: "./src/migrations",
  migrationsTable: "__drizzle_migrations"
});
```

### Pattern 4: tRPC Testing with createCallerFactory

**What:** Test tRPC procedures directly without HTTP
**When to use:** Testing procedure logic and auth middleware

```typescript
// Source: https://trpc.io/docs/v10/server/server-side-calls
import { t } from "../index";
import { appRouter } from "./index";

const createCaller = t.createCallerFactory(appRouter);

// Test public procedure
const publicCaller = createCaller({ session: null });
const result = await publicCaller.healthCheck();
expect(result).toBe("OK");

// Test protected procedure with mock session
const mockSession = {
  user: { id: "test-user", name: "Test", email: "test@example.com" },
  session: { id: "session-1", expiresAt: new Date() }
};
const protectedCaller = createCaller({ session: mockSession });
const privateData = await protectedCaller.privateData();
```

**Note:** `router.createCaller()` is deprecated but still works. Prefer `t.createCallerFactory(router)`.

### Pattern 5: Better-Auth API Testing

**What:** Test auth flows using direct API calls
**When to use:** Testing signup/signin/signout without HTTP

```typescript
// Source: https://www.better-auth.com/docs/authentication/email-password
import { getAuth } from "@gemhog/core/auth";

const auth = getAuth();

// Signup
const signupResult = await auth.api.signUpEmail({
  body: {
    name: "Test User",
    email: "test@example.com",
    password: "password123",
  },
});

// Signin
const signinResult = await auth.api.signInEmail({
  body: {
    email: "test@example.com",
    password: "password123",
  },
});
```

### Anti-Patterns to Avoid

- **Parallel integration tests:** Causes race conditions with database truncation. Use `fileParallelism: false` (already configured).
- **Manual pool creation in Effect tests:** Use Effect layers. Don't create new pools when testing Effect code.
- **afterEach cleanup:** Truncate BEFORE each test (per CONTEXT.md), not after. Preserves state on failure for debugging.
- **Querying DB to verify auth state:** Verify via response only (per CONTEXT.md decision).

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Migration execution | Shell out to drizzle-kit | `drizzle-orm/node-postgres/migrator` | Type-safe, no subprocess overhead |
| Effect test runner | Custom Effect.runPromise wrapper | `@effect/vitest` | Handles TestContext, timeouts, proper cleanup |
| tRPC test client | HTTP fetch in tests | `createCallerFactory` | Type-safe, no HTTP overhead |
| Test user creation | Manual SQL inserts | better-auth API signup | Proper password hashing, session creation |

**Key insight:** better-auth's password hashing adds ~100-150ms per signup. For test performance, consider creating users once per test file rather than per test case.

## Common Pitfalls

### Pitfall 1: drizzle.config.ts env loading

**What goes wrong:** drizzle.config.ts imports full env validation that requires all server vars
**Why it happens:** @gemhog/env/server validates DATABASE_URL + BETTER_AUTH_SECRET + BETTER_AUTH_URL + CORS_ORIGIN together
**How to avoid:** Use dotenv directly in drizzle.config.ts, loading only DATABASE_URL
**Warning signs:** "Invalid environment variables" error mentioning vars other than DATABASE_URL

### Pitfall 2: Effect Config.redacted in tests

**What goes wrong:** Effect PgClient layer fails in tests due to missing Config provider
**Why it happens:** `PgLive` uses `Config.redacted("DATABASE_URL")` which requires ConfigProvider
**How to avoid:** Create test-specific layer with hardcoded URL using `PgClient.layer()` instead of `layerConfig()`
**Warning signs:** "Config Error" or "Missing config" in test output

### Pitfall 3: Test isolation with shared database

**What goes wrong:** Tests pass individually but fail when run together
**Why it happens:** Previous test data pollutes subsequent tests
**How to avoid:** Truncate tables BEFORE each test (per CONTEXT.md decision)
**Warning signs:** "duplicate key" errors, unexpected row counts

### Pitfall 4: Truncating migration tables

**What goes wrong:** Migration state lost, migrations re-run on every test
**Why it happens:** Truncate logic includes `__drizzle_migrations` table
**How to avoid:** Explicitly exclude migration tables from truncation
**Warning signs:** "relation already exists" errors in test output

### Pitfall 5: better-auth singleton in tests

**What goes wrong:** Auth instance shares state across tests
**Why it happens:** `getAuth()` returns lazy singleton, database connection cached
**How to avoid:** Accept shared instance (usually fine for integration tests), or use `vi.resetModules()` if state must be reset
**Warning signs:** Tests pass individually but fail together

## Code Examples

### Fix drizzle.config.ts env loading

```typescript
// packages/core/drizzle.config.ts (recommended fix)
import "dotenv/config";
import { defineConfig } from "drizzle-kit";

const DATABASE_URL = process.env.DATABASE_URL;
if (!DATABASE_URL) {
  throw new Error("DATABASE_URL environment variable is required");
}

export default defineConfig({
  schema: "./src/*/*.sql.ts",
  out: "./src/migrations",
  dialect: "postgresql",
  dbCredentials: {
    url: DATABASE_URL,
  },
});
```

### Effect Layer Connection Test

```typescript
// packages/core/src/drizzle/connection.int.test.ts
import { it, layer, expect } from "@effect/vitest";
import { Effect } from "effect";
import { SqlClient } from "@effect/sql";
import { PgClient } from "@effect/sql-pg";
import { describe } from "vitest";

// Test layer with explicit URL (bypasses Config.redacted)
const TestPgLive = PgClient.layer({
  url: process.env.DATABASE_URL
    ?? "postgresql://postgres:password@localhost:5432/gemhog_test",
});

layer(TestPgLive)("database connection (Effect)", (it) => {
  it.effect("should connect and execute query", () =>
    Effect.gen(function* () {
      const sql = yield* SqlClient.SqlClient;
      const result = yield* sql`SELECT 1 as value`;
      expect(result[0]?.value).toBe(1);
    })
  );

  it.effect("should return current timestamp", () =>
    Effect.gen(function* () {
      const sql = yield* SqlClient.SqlClient;
      const result = yield* sql`SELECT NOW() as now`;
      expect(result[0]?.now).toBeInstanceOf(Date);
    })
  );
});
```

### Migration Integration Test

```typescript
// packages/core/src/drizzle/migrations.int.test.ts
import { sql } from "drizzle-orm";
import { drizzle } from "drizzle-orm/node-postgres";
import { migrate } from "drizzle-orm/node-postgres/migrator";
import pg from "pg";
import path from "path";
import { fileURLToPath } from "url";
import { afterAll, beforeAll, describe, expect, it } from "vitest";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

describe("database migrations", () => {
  let pool: pg.Pool;
  let db: ReturnType<typeof drizzle>;

  beforeAll(async () => {
    pool = new pg.Pool({
      connectionString: process.env.DATABASE_URL
        ?? "postgresql://postgres:password@localhost:5432/gemhog_test",
    });
    db = drizzle(pool);
  });

  afterAll(async () => {
    await pool.end();
  });

  it("should apply migrations successfully", async () => {
    await migrate(db, {
      migrationsFolder: path.resolve(__dirname, "../migrations"),
    });

    const result = await db.execute(sql`
      SELECT table_name
      FROM information_schema.tables
      WHERE table_schema = 'public'
      ORDER BY table_name
    `);

    const tables = result.rows.map((r) => r.table_name);
    expect(tables).toContain("user");
    expect(tables).toContain("session");
    expect(tables).toContain("account");
    expect(tables).toContain("verification");
  });

  it("should track migrations in __drizzle_migrations", async () => {
    const result = await db.execute(sql`
      SELECT * FROM "__drizzle_migrations"
    `);
    expect(result.rows.length).toBeGreaterThan(0);
  });
});
```

### Auth Flow Integration Test

```typescript
// packages/core/src/auth/auth.int.test.ts
import { sql } from "drizzle-orm";
import { drizzle } from "drizzle-orm/node-postgres";
import pg from "pg";
import { afterAll, beforeAll, beforeEach, describe, expect, it } from "vitest";

describe("auth flows", () => {
  let pool: pg.Pool;
  let db: ReturnType<typeof drizzle>;

  beforeAll(async () => {
    pool = new pg.Pool({
      connectionString: process.env.DATABASE_URL
        ?? "postgresql://postgres:password@localhost:5432/gemhog_test",
    });
    db = drizzle(pool);
  });

  beforeEach(async () => {
    // Truncate auth tables before each test
    await db.execute(
      sql`TRUNCATE TABLE session, account, verification, "user" CASCADE`
    );
  });

  afterAll(async () => {
    await pool.end();
  });

  describe("signup", () => {
    it("should create user via email/password", async () => {
      const { getAuth } = await import("./auth.service");
      const auth = getAuth();

      const result = await auth.api.signUpEmail({
        body: {
          email: "test@example.com",
          password: "password123",
          name: "Test User",
        },
      });

      // Verify via response only (per CONTEXT.md decision)
      expect(result.user).toBeDefined();
      expect(result.user?.email).toBe("test@example.com");
    });

    it("should reject invalid email format", async () => {
      const { getAuth } = await import("./auth.service");
      const auth = getAuth();

      await expect(
        auth.api.signUpEmail({
          body: {
            email: "not-an-email",
            password: "password123",
            name: "Test User",
          },
        })
      ).rejects.toThrow();
    });
  });

  describe("signin", () => {
    it("should authenticate valid credentials", async () => {
      const { getAuth } = await import("./auth.service");
      const auth = getAuth();

      // Create user first
      await auth.api.signUpEmail({
        body: {
          email: "test@example.com",
          password: "password123",
          name: "Test User",
        },
      });

      // Sign in
      const result = await auth.api.signInEmail({
        body: {
          email: "test@example.com",
          password: "password123",
        },
      });

      expect(result.session).toBeDefined();
      expect(result.user?.email).toBe("test@example.com");
    });

    it("should reject invalid password", async () => {
      const { getAuth } = await import("./auth.service");
      const auth = getAuth();

      await auth.api.signUpEmail({
        body: {
          email: "test@example.com",
          password: "password123",
          name: "Test User",
        },
      });

      await expect(
        auth.api.signInEmail({
          body: {
            email: "test@example.com",
            password: "wrongpassword",
          },
        })
      ).rejects.toThrow();
    });
  });
});
```

### tRPC Procedure Integration Test

```typescript
// packages/api/src/routers/index.int.test.ts
import { TRPCError } from "@trpc/server";
import { describe, expect, it } from "vitest";
import { t } from "../index";
import { appRouter } from "./index";

const createCaller = t.createCallerFactory(appRouter);

describe("tRPC procedures", () => {
  describe("healthCheck (public)", () => {
    it("should return OK without session", async () => {
      const caller = createCaller({ session: null });
      const result = await caller.healthCheck();
      expect(result).toBe("OK");
    });
  });

  describe("privateData (protected)", () => {
    it("should return data with valid session", async () => {
      const mockSession = {
        user: {
          id: "test-user-id",
          name: "Test User",
          email: "test@example.com",
          emailVerified: true,
          image: null,
          createdAt: new Date(),
          updatedAt: new Date(),
        },
        session: {
          id: "test-session-id",
          token: "test-token",
          expiresAt: new Date(Date.now() + 86400000),
          userId: "test-user-id",
          createdAt: new Date(),
          updatedAt: new Date(),
          ipAddress: null,
          userAgent: null,
        },
      };

      const caller = createCaller({ session: mockSession });
      const result = await caller.privateData();

      expect(result.message).toBe("This is private");
      expect(result.user.email).toBe("test@example.com");
    });

    it("should reject without session", async () => {
      const caller = createCaller({ session: null });

      await expect(caller.privateData()).rejects.toThrow(TRPCError);

      try {
        await caller.privateData();
      } catch (e) {
        expect(e).toBeInstanceOf(TRPCError);
        expect((e as TRPCError).code).toBe("UNAUTHORIZED");
      }
    });
  });
});
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Effect wrapper around auth | Plain better-auth API | Phase 3.1-04 | Simpler auth testing |
| router.createCaller() | t.createCallerFactory() | tRPC v11 | Old method deprecated |
| Effect Config for env | t3-env | Phase 3.3 | Unified env validation |

**Deprecated/outdated:**
- `router.createCaller()`: Deprecated in tRPC v11, use `t.createCallerFactory(router)` instead
- Effect Config in packages/env: Replaced with t3-env in Phase 3.3

## Open Questions

1. **@effect/vitest layer() shared vs fresh**
   - What we know: `layer()` provides layer to all nested tests
   - What's unclear: Whether layer is constructed once or per-test
   - Recommendation: Use `layer()` for database connection (want shared), validate in testing

2. **Test database creation**
   - What we know: Docker compose creates `gemhog` database
   - What's unclear: Whether to use `gemhog` or create separate `gemhog_test`
   - Recommendation: Use `gemhog` database, truncate tables. Separate DB adds complexity.

3. **Rollback testing**
   - What we know: drizzle-kit has no built-in rollback
   - What's unclear: How to test rollback if needed
   - Recommendation: Focus on apply testing; rollback would require custom SQL

## Sources

### Primary (HIGH confidence)
- [Drizzle ORM Migrations](https://orm.drizzle.team/docs/migrations) - Programmatic migration API
- [tRPC Server Side Calls](https://trpc.io/docs/v10/server/server-side-calls) - createCallerFactory usage
- [@effect/vitest README](https://github.com/Effect-TS/effect/blob/main/packages/vitest/README.md) - Effect testing patterns
- [Better Auth Email/Password](https://www.better-auth.com/docs/authentication/email-password) - Auth API

### Secondary (MEDIUM confidence)
- [Vitest Test Lifecycle](https://vitest.dev/guide/lifecycle) - beforeEach/afterEach patterns
- [@effect/sql-pg PgClient](https://effect-ts.github.io/effect/sql-pg/PgClient.ts.html) - Layer configuration
- [PostgreSQL TRUNCATE](https://www.postgresql.org/docs/current/sql-truncate.html) - Truncate with CASCADE

### Tertiary (LOW confidence)
- [Drizzle truncate gist](https://gist.github.com/rphlmr/0d1722a794ed5a16da0fdf6652902b15) - Truncate all tables pattern
- [Better Auth Testing Issue](https://github.com/better-auth/better-auth/issues/5609) - Community testing patterns

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already in use, documented patterns
- Architecture: HIGH - Patterns from official docs, matches existing codebase
- Pitfalls: HIGH - Verified through codebase analysis and official docs

**Research date:** 2026-01-22
**Valid until:** 2026-02-22 (30 days - stable technologies)
