---
phase: 04-sst-deployment
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - sst.config.ts
  - infra/secrets.ts
  - infra/neon.ts
autonomous: true

must_haves:
  truths:
    - "sst.config.ts exists at repo root with correct app configuration"
    - "SST secrets are defined for all required env vars"
    - "Neon Linkable provides DATABASE_URL for both direct and pooled connections"
  artifacts:
    - path: "sst.config.ts"
      provides: "SST app configuration"
      exports: ["$config"]
    - path: "infra/secrets.ts"
      provides: "SST secret definitions"
      exports: ["secrets"]
    - path: "infra/neon.ts"
      provides: "Neon database Linkable"
      exports: ["neon"]
  key_links:
    - from: "sst.config.ts"
      to: "infra/secrets.ts"
      via: "dynamic import"
      pattern: "import.*./infra/secrets"
    - from: "infra/neon.ts"
      to: "infra/secrets.ts"
      via: "secrets import"
      pattern: "from.*./secrets"
---

<objective>
Create SST configuration and secrets/database infrastructure files.

Purpose: Establish the SST project structure with secrets management and Neon database linkable. This follows the monorepo pattern from RESEARCH.md - dynamic imports in sst.config.ts, one file per resource type in infra/.

Output: sst.config.ts, infra/secrets.ts, infra/neon.ts ready for use by api.ts and web.ts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-sst-deployment/04-CONTEXT.md
@.planning/phases/04-sst-deployment/04-RESEARCH.md
@.planning/phases/04-sst-deployment/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sst.config.ts with app configuration</name>
  <files>sst.config.ts</files>
  <action>
Create `sst.config.ts` at repo root with the SST v3 configuration:

```typescript
/// <reference path="./.sst/platform/config.d.ts" />

export default $config({
  app(input) {
    return {
      name: "gemhog",
      removal: input.stage === "prod" ? "retain" : "remove",
      protect: ["prod"].includes(input.stage),
      home: "aws",
      providers: {
        aws: { region: "eu-central-1" },
        cloudflare: true,
      },
    };
  },
  async run() {
    // Dynamic imports for infra modules
    const secrets = await import("./infra/secrets");
    const neon = await import("./infra/neon");
    const api = await import("./infra/api");
    const web = await import("./infra/web");

    // Collect and return outputs
    return {
      ...(api.outputs || {}),
      ...(web.outputs || {}),
    };
  },
});
```

Configuration choices per CONTEXT.md:
- Region: eu-central-1 (Frankfurt)
- Stages: dev, test, prod (protect prod only)
- Providers: AWS (home) + Cloudflare (DNS)
- Removal: retain resources in prod, remove in other stages
  </action>
  <verify>
```bash
# File exists with correct structure
cat sst.config.ts

# Note: `sst deploy` will fail until infra files exist - that's expected
```
  </verify>
  <done>sst.config.ts created with app config and dynamic infra imports</done>
</task>

<task type="auto">
  <name>Task 2: Create infra/secrets.ts with SST secrets</name>
  <files>infra/secrets.ts</files>
  <action>
Create `infra/secrets.ts` with all required SST secrets:

```typescript
// SST secrets managed via `sst secret set <name> <value>`
// These map to environment variables in linked resources
export const secrets = {
  // Database
  DatabaseUrl: new sst.Secret("DatabaseUrl"),
  DatabaseUrlPooler: new sst.Secret("DatabaseUrlPooler"),

  // Auth
  BetterAuthSecret: new sst.Secret("BetterAuthSecret"),

  // AI
  GoogleApiKey: new sst.Secret("GoogleApiKey"),
};
```

Secrets needed (from packages/env/src/server.ts + CONTEXT.md):
- DatabaseUrl: Direct Neon connection (for migrations)
- DatabaseUrlPooler: Pooled Neon connection (for runtime)
- BetterAuthSecret: Auth session encryption
- GoogleApiKey: Google Generative AI API key

Note: BETTER_AUTH_URL and CORS_ORIGIN are derived from stage, not secrets (set in api.ts environment).
  </action>
  <verify>
```bash
# File exists
cat infra/secrets.ts
```
  </verify>
  <done>infra/secrets.ts created with DatabaseUrl, DatabaseUrlPooler, BetterAuthSecret, GoogleApiKey secrets</done>
</task>

<task type="auto">
  <name>Task 3: Create infra/neon.ts with database Linkable</name>
  <files>infra/neon.ts</files>
  <action>
Create `infra/neon.ts` with the Neon Linkable pattern:

```typescript
import { secrets } from "./secrets";

// Neon is an external database, not SST-managed
// Create a Linkable to expose connection URLs to linked resources
export const neon = new sst.Linkable("Neon", {
  properties: {
    // Direct connection URL (for migrations)
    url: secrets.DatabaseUrl.value,
    // Pooled connection URL (for Lambda runtime)
    urlPooler: secrets.DatabaseUrlPooler.value,
  },
});
```

Why two URLs per RESEARCH.md (Pitfall 2):
- Direct URL for migrations (DDL operations)
- Pooled URL for Lambda runtime (serverless connection reuse)

When linked to a function, SST injects:
- `NEON_URL` (direct)
- `NEON_URL_POOLER` (pooled)
  </action>
  <verify>
```bash
# File exists with correct structure
cat infra/neon.ts
```
  </verify>
  <done>infra/neon.ts created with Neon Linkable exposing direct and pooled URLs</done>
</task>

</tasks>

<verification>
```bash
# All infra files exist
ls -la sst.config.ts infra/

# TypeScript compilation (may have type errors until .sst types generated)
# This is expected - types are generated on first `sst dev` or `sst deploy`
```
</verification>

<success_criteria>
- sst.config.ts exists at repo root with gemhog app config
- infra/secrets.ts defines DatabaseUrl, DatabaseUrlPooler, BetterAuthSecret, GoogleApiKey
- infra/neon.ts creates Linkable with url and urlPooler properties
- Code follows patterns from RESEARCH.md
</success_criteria>

<output>
After completion, create `.planning/phases/04-sst-deployment/04-02-SUMMARY.md`
</output>
