---
phase: 04-sst-deployment
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - infra/api.ts
  - infra/web.ts
autonomous: true

must_haves:
  truths:
    - "Hono Lambda function is configured with streaming and Router"
    - "Next.js app is configured with domain and env vars"
    - "Both components link to Neon and required secrets"
    - "Stage-conditional domains work for dev and prod"
  artifacts:
    - path: "infra/api.ts"
      provides: "Hono Lambda function configuration"
      exports: ["api", "router", "outputs"]
    - path: "infra/web.ts"
      provides: "Next.js deployment configuration"
      exports: ["web", "outputs"]
  key_links:
    - from: "infra/api.ts"
      to: "infra/secrets.ts"
      via: "secrets import"
      pattern: "from.*./secrets"
    - from: "infra/api.ts"
      to: "infra/neon.ts"
      via: "neon import"
      pattern: "from.*./neon"
    - from: "infra/web.ts"
      to: "infra/api.ts"
      via: "api import for URL"
      pattern: "from.*./api"
---

<objective>
Create SST component configurations for Hono Lambda API and Next.js web app.

Purpose: Define the AWS resources for deploying both apps. The API uses Function URL with Router for streaming support (per RESEARCH.md - API Gateway doesn't support streaming). Next.js uses the sst.aws.Nextjs component.

Output: infra/api.ts and infra/web.ts configuring both applications for AWS deployment.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-sst-deployment/04-CONTEXT.md
@.planning/phases/04-sst-deployment/04-RESEARCH.md
@.planning/phases/04-sst-deployment/04-02-SUMMARY.md
@.planning/phases/04-sst-deployment/04-03-SUMMARY.md
@infra/secrets.ts
@infra/neon.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create infra/api.ts with Hono Lambda configuration</name>
  <files>infra/api.ts</files>
  <action>
Create `infra/api.ts` with the Hono Lambda function and Router:

```typescript
import { secrets } from "./secrets";
import { neon } from "./neon";

// Router for CloudFront domain routing
// Skip domain for personal stages (use Function URL directly)
const domainConfig = ["dev", "test", "prod"].includes($app.stage)
  ? {
      domain: {
        name:
          $app.stage === "prod"
            ? "api.gemhog.com"
            : `api.${$app.stage}.gemhog.com`,
        dns: sst.cloudflare.dns({
          zone: process.env.CLOUDFLARE_ZONE_ID!,
        }),
      },
    }
  : {};

export const router = new sst.aws.Router("ApiRouter", domainConfig);

// Hono Lambda with conditional streaming
// streaming: false in $dev because sst dev doesn't support it
export const api = new sst.aws.Function("Api", {
  handler: "apps/server/src/lambda.handler",
  runtime: "nodejs22.x",
  streaming: !$dev,
  timeout: "15 minutes", // For long AI conversations
  memory: "512 MB",
  url: {
    router: ["dev", "test", "prod"].includes($app.stage)
      ? { instance: router }
      : true, // Personal stages use direct Function URL
    cors: {
      allowOrigins: [
        "https://gemhog.com",
        "https://*.gemhog.com",
        "http://localhost:3001", // Local Next.js dev
      ],
      allowMethods: ["GET", "POST", "OPTIONS"],
      allowHeaders: ["Content-Type", "Authorization"],
      allowCredentials: true,
    },
  },
  link: [neon, secrets.BetterAuthSecret, secrets.GoogleApiKey],
  environment: {
    NODE_ENV: "production",
    // DATABASE_URL comes from linked Neon (pooled for Lambda)
    DATABASE_URL: neon.properties.urlPooler,
    // Stage-conditional URLs
    CORS_ORIGIN:
      $app.stage === "prod"
        ? "https://gemhog.com"
        : $app.stage === "dev" || $app.stage === "test"
          ? `https://${$app.stage}.gemhog.com`
          : "http://localhost:3001",
    BETTER_AUTH_URL:
      $app.stage === "prod"
        ? "https://api.gemhog.com"
        : $app.stage === "dev" || $app.stage === "test"
          ? `https://api.${$app.stage}.gemhog.com`
          : api.url,
    // Linked secrets become env vars automatically
    BETTER_AUTH_SECRET: secrets.BetterAuthSecret.value,
    GOOGLE_GENERATIVE_AI_API_KEY: secrets.GoogleApiKey.value,
  },
});

export const outputs = {
  apiUrl: api.url,
};
```

Key configuration per CONTEXT.md and RESEARCH.md:
- Router with Cloudflare DNS for api.gemhog.com / api.dev.gemhog.com
- Function URL with streaming (disabled in $dev)
- 15 min timeout for AI conversations
- Neon pooled URL for Lambda connection reuse
- All required env vars from secrets or stage-conditional values
  </action>
  <verify>
```bash
# File exists with exports
grep -E "export.*(api|router|outputs)" infra/api.ts
```
  </verify>
  <done>infra/api.ts created with Hono Lambda, Router, CORS, and all env vars</done>
</task>

<task type="auto">
  <name>Task 2: Create infra/web.ts with Next.js configuration</name>
  <files>infra/web.ts</files>
  <action>
Create `infra/web.ts` with the Next.js SST component:

```typescript
import { secrets } from "./secrets";
import { neon } from "./neon";
import { api } from "./api";

// Skip domain for personal stages
const domainConfig = ["dev", "test", "prod"].includes($app.stage)
  ? {
      domain: {
        name:
          $app.stage === "prod" ? "gemhog.com" : `${$app.stage}.gemhog.com`,
        dns: sst.cloudflare.dns({
          zone: process.env.CLOUDFLARE_ZONE_ID!,
        }),
      },
    }
  : {};

export const web = new sst.aws.Nextjs("Web", {
  path: "apps/web",
  ...domainConfig,
  link: [neon, secrets.BetterAuthSecret],
  environment: {
    // Public env var for client-side API calls
    NEXT_PUBLIC_SERVER_URL:
      $app.stage === "prod"
        ? "https://api.gemhog.com"
        : $app.stage === "dev" || $app.stage === "test"
          ? `https://api.${$app.stage}.gemhog.com`
          : api.url,
    // Server-side env vars
    DATABASE_URL: neon.properties.urlPooler,
    BETTER_AUTH_SECRET: secrets.BetterAuthSecret.value,
    BETTER_AUTH_URL:
      $app.stage === "prod"
        ? "https://api.gemhog.com"
        : $app.stage === "dev" || $app.stage === "test"
          ? `https://api.${$app.stage}.gemhog.com`
          : api.url,
    CORS_ORIGIN:
      $app.stage === "prod"
        ? "https://gemhog.com"
        : $app.stage === "dev" || $app.stage === "test"
          ? `https://${$app.stage}.gemhog.com`
          : "http://localhost:3001",
  },
});

export const outputs = {
  webUrl: web.url,
};
```

Key configuration per CONTEXT.md:
- Cloudflare DNS for gemhog.com / dev.gemhog.com
- NEXT_PUBLIC_SERVER_URL for client-side API calls
- Links to Neon and auth secret (Next.js server-side rendering needs DB access)
- Personal stages skip domain, use CloudFront URL directly
  </action>
  <verify>
```bash
# File exists with exports
grep -E "export.*(web|outputs)" infra/web.ts
```
  </verify>
  <done>infra/web.ts created with Next.js component, domain config, and env vars</done>
</task>

</tasks>

<verification>
```bash
# All infra files exist
ls infra/

# Check for complete SST structure
cat sst.config.ts
cat infra/secrets.ts
cat infra/neon.ts
cat infra/api.ts
cat infra/web.ts
```
</verification>

<success_criteria>
- infra/api.ts configures Hono Lambda with streaming, Router, and all env vars
- infra/web.ts configures Next.js with domain and environment
- Both link to Neon and required secrets
- Stage-conditional domains (prod, dev, test vs personal stages)
- CORS configured for *.gemhog.com and localhost
</success_criteria>

<output>
After completion, create `.planning/phases/04-sst-deployment/04-04-SUMMARY.md`
</output>
