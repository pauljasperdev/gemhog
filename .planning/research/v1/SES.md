# AWS SES Research

**Project:** Gemhog V1 - Email Infrastructure
**Researched:** 2026-01-24
**Confidence:** HIGH (verified with official AWS docs and SST documentation)

## Summary

AWS SES is the right choice for Gemhog's email infrastructure: $0 cost at low volume (3,000 free emails/month for first 12 months, then $0.10/1,000), native SST v3 integration via the `Email` component, and full control over deliverability. The main complexity is the production access request (requires domain verification with DKIM/SPF/DMARC, bounce/complaint handling, and a detailed use case explanation). Double opt-in requires implementing verification tokens and a confirmation endpoint. Bounce handling is mandatory and best done via SNS -> Lambda to update the suppression list.

## Setup & Configuration

### Domain Verification with SST

SST v3 provides an `Email` component that wraps SES identity creation and configuration:

```typescript
// infra/email.ts
export const email = new sst.aws.Email("GemhogEmail", {
  sender: "gemhog.com",
  dmarc: "v=DMARC1; p=quarantine; adkim=s; aspf=s;",
  dns: sst.cloudflare.dns(), // Since project uses Cloudflare
});
```

When using a domain, SST handles:
- Creating the SES domain identity
- Generating DKIM records (2048-bit by default)
- Setting up the configuration set for event tracking

### DNS Records Required

For full email authentication, you need these DNS records:

| Record Type | Name | Purpose |
|-------------|------|---------|
| CNAME x3 | Auto-generated by SES | DKIM signing (Easy DKIM) |
| TXT | `_dmarc.gemhog.com` | DMARC policy |
| MX | Custom MAIL FROM subdomain | SPF alignment |
| TXT | Custom MAIL FROM subdomain | SPF record |

### DKIM Setup

SES Easy DKIM automatically adds a 2048-bit DKIM signature to every email. When you create an email identity via SST or the SES console:

1. SES generates 3 CNAME records
2. Add these to your DNS provider (Cloudflare in this case)
3. SES verifies and enables DKIM signing

```
# Example CNAME records (actual values from SES console)
abc123._domainkey.gemhog.com -> abc123.dkim.amazonses.com
def456._domainkey.gemhog.com -> def456.dkim.amazonses.com
ghi789._domainkey.gemhog.com -> ghi789.dkim.amazonses.com
```

### SPF with Custom MAIL FROM Domain

For SPF alignment, configure a custom MAIL FROM domain:

1. Choose a subdomain (e.g., `mail.gemhog.com`)
2. Add MX record: `mail.gemhog.com -> feedback-smtp.eu-central-1.amazonses.com` (priority 10)
3. Add TXT record: `mail.gemhog.com -> "v=spf1 include:amazonses.com ~all"`

This ensures the MAIL FROM domain aligns with your From address, passing SPF checks.

### DMARC Policy

Start with monitoring, then tighten:

```
# Phase 1: Monitor (no enforcement)
v=DMARC1; p=none; rua=mailto:dmarc@gemhog.com;

# Phase 2: Quarantine (after confirming all legit email passes)
v=DMARC1; p=quarantine; adkim=s; aspf=s; rua=mailto:dmarc@gemhog.com;

# Phase 3: Reject (full protection)
v=DMARC1; p=reject; adkim=s; aspf=s; rua=mailto:dmarc@gemhog.com;
```

## Double Opt-In Implementation

### Flow

```
1. User submits email on landing page
2. Server validates email, generates secure token
3. Store subscriber with status="pending", token, token_expiry
4. Send verification email via SES
5. User clicks verification link
6. Server validates token, updates status="active"
7. Delete/invalidate token
```

### Database Schema

```sql
CREATE TABLE subscribers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL UNIQUE,
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'active', 'unsubscribed'
  verification_token TEXT,
  verification_expires_at TIMESTAMP WITH TIME ZONE,
  confirmed_at TIMESTAMP WITH TIME ZONE,
  unsubscribed_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_subscribers_email ON subscribers(email);
CREATE INDEX idx_subscribers_status ON subscribers(status);
CREATE INDEX idx_subscribers_verification_token ON subscribers(verification_token);
```

### Token Generation

Use cryptographically secure tokens with expiration:

```typescript
import { randomBytes } from "crypto";

function generateVerificationToken(): {
  token: string;
  expiresAt: Date;
} {
  // 32 bytes = 256 bits of entropy
  const token = randomBytes(32).toString("hex");
  // 24-hour expiration
  const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000);
  return { token, expiresAt };
}
```

**Security notes:**
- Never use MD5 or simple hashes
- 24-hour expiration is standard (1 hour for high-security)
- Single-use: invalidate after successful verification
- Implement resend with fresh token (invalidate old one)

### Verification Email Template

```html
Subject: Confirm your Gemhog subscription

<html>
<body>
  <h1>Confirm your subscription</h1>
  <p>Thanks for signing up for Gemhog updates!</p>
  <p>Click the button below to confirm your email address:</p>
  <a href="{{verificationUrl}}" style="
    display: inline-block;
    padding: 12px 24px;
    background-color: #2563eb;
    color: white;
    text-decoration: none;
    border-radius: 6px;
  ">Confirm Email</a>
  <p style="color: #666; font-size: 14px;">
    This link expires in 24 hours. If you didn't sign up, you can ignore this email.
  </p>
</body>
</html>
```

### API Endpoints

```typescript
// POST /api/subscribe
// - Validate email format
// - Check if already subscribed (return success silently to prevent enumeration)
// - Generate verification token
// - Store subscriber with pending status
// - Send verification email
// - Return success (don't reveal if email exists)

// GET /api/verify?token=xxx
// - Find subscriber by token
// - Check expiration
// - Update status to 'active', set confirmed_at
// - Clear token
// - Redirect to success page

// GET /api/unsubscribe?email=xxx&token=xxx
// - Validate unsubscribe token (HMAC of email + secret)
// - Update status to 'unsubscribed', set unsubscribed_at
// - Redirect to confirmation page
```

## Bounce & Complaint Handling

### Why It's Required

- AWS requires bounce/complaint handling for production access
- Keep bounce rate < 5% and complaint rate < 0.1%
- Exceeding these thresholds can result in account suspension
- Hard bounces and complaints must be suppressed from future sends

### Architecture

```
SES -> Configuration Set -> SNS Topic -> Lambda -> Database
                                              |
                                              v
                                    Update suppression list
                                    + CloudWatch alarm (optional)
```

### SST Configuration

```typescript
// infra/email.ts
const bounceTopic = new sst.aws.SnsTopic("BounceTopic");
const complaintTopic = new sst.aws.SnsTopic("ComplaintTopic");

export const email = new sst.aws.Email("GemhogEmail", {
  sender: "gemhog.com",
  dmarc: "v=DMARC1; p=quarantine; adkim=s; aspf=s;",
  dns: sst.cloudflare.dns(),
  events: [
    {
      name: "Bounce",
      types: ["bounce"],
      topic: bounceTopic.arn,
    },
    {
      name: "Complaint",
      types: ["complaint"],
      topic: complaintTopic.arn,
    },
  ],
});

// Lambda to handle bounce notifications
const bounceHandler = new sst.aws.Function("BounceHandler", {
  handler: "packages/functions/src/email/bounce-handler.handler",
  link: [/* database connection */],
});

bounceTopic.subscribe(bounceHandler.arn);
complaintTopic.subscribe(bounceHandler.arn);
```

### Bounce Handler Lambda

```typescript
// packages/functions/src/email/bounce-handler.ts
import { SNSEvent } from "aws-lambda";

interface SESBounceNotification {
  notificationType: "Bounce" | "Complaint";
  bounce?: {
    bounceType: "Permanent" | "Transient";
    bouncedRecipients: Array<{ emailAddress: string }>;
  };
  complaint?: {
    complainedRecipients: Array<{ emailAddress: string }>;
  };
}

export async function handler(event: SNSEvent) {
  for (const record of event.Records) {
    const notification: SESBounceNotification = JSON.parse(record.Sns.Message);

    if (notification.notificationType === "Bounce" && notification.bounce) {
      // Only suppress permanent (hard) bounces
      if (notification.bounce.bounceType === "Permanent") {
        for (const recipient of notification.bounce.bouncedRecipients) {
          await suppressEmail(recipient.emailAddress, "hard_bounce");
        }
      }
    }

    if (notification.notificationType === "Complaint" && notification.complaint) {
      for (const recipient of notification.complaint.complainedRecipients) {
        await suppressEmail(recipient.emailAddress, "complaint");
      }
    }
  }
}

async function suppressEmail(email: string, reason: string) {
  // Update subscriber status to suppressed
  // Log the suppression with reason and timestamp
  // This email should never receive future emails
}
```

### Suppression Table

```sql
CREATE TABLE email_suppressions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL UNIQUE,
  reason TEXT NOT NULL, -- 'hard_bounce', 'complaint', 'manual'
  original_error TEXT,
  suppressed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_suppressions_email ON email_suppressions(email);
```

### Pre-send Check

Before sending any email, check the suppression list:

```typescript
async function canSendTo(email: string): Promise<boolean> {
  const suppressed = await db.query.emailSuppressions.findFirst({
    where: eq(emailSuppressions.email, email.toLowerCase()),
  });
  return !suppressed;
}
```

## Sending Patterns

### Transactional vs Bulk

| Type | Use Case | Method | Rate |
|------|----------|--------|------|
| Transactional | Verification emails, password reset | `SendEmailCommand` | Immediate |
| Bulk | Newsletters | `SendBulkEmailCommand` or batched `SendEmailCommand` | Rate-limited |

### Transactional Email (Single)

```typescript
import { SESv2Client, SendEmailCommand } from "@aws-sdk/client-sesv2";
import { Resource } from "sst";

const client = new SESv2Client({});

export async function sendVerificationEmail(
  to: string,
  verificationUrl: string
) {
  const command = new SendEmailCommand({
    FromEmailAddress: `Gemhog <noreply@${Resource.GemhogEmail.sender}>`,
    Destination: { ToAddresses: [to] },
    Content: {
      Simple: {
        Subject: { Data: "Confirm your Gemhog subscription" },
        Body: {
          Html: {
            Data: `
              <h1>Confirm your subscription</h1>
              <p><a href="${verificationUrl}">Click here to confirm</a></p>
            `,
          },
          Text: {
            Data: `Confirm your subscription: ${verificationUrl}`,
          },
        },
      },
    },
    ConfigurationSetName: Resource.GemhogEmail.configSet,
  });

  await client.send(command);
}
```

### Bulk Email (Newsletter)

For newsletters, use templates and `SendBulkEmailCommand`:

```typescript
import {
  SESv2Client,
  CreateEmailTemplateCommand,
  SendBulkEmailCommand,
} from "@aws-sdk/client-sesv2";

// Create template once
await client.send(new CreateEmailTemplateCommand({
  TemplateName: "Newsletter",
  TemplateContent: {
    Subject: "{{subject}}",
    Html: "{{htmlContent}}",
    Text: "{{textContent}}",
  },
}));

// Send bulk (up to 50 destinations per call)
const subscribers = await getActiveSubscribers();
const batches = chunk(subscribers, 50);

for (const batch of batches) {
  await client.send(new SendBulkEmailCommand({
    FromEmailAddress: `Gemhog <newsletter@${Resource.GemhogEmail.sender}>`,
    DefaultContent: {
      Template: {
        TemplateName: "Newsletter",
        TemplateData: JSON.stringify({
          subject: "Weekly Investment Insights",
          htmlContent: newsletterHtml,
          textContent: newsletterText,
        }),
      },
    },
    BulkEmailEntries: batch.map(sub => ({
      Destination: { ToAddresses: [sub.email] },
      ReplacementEmailContent: {
        ReplacementTemplate: {
          ReplacementTemplateData: JSON.stringify({
            // Per-recipient data like unsubscribe links
            unsubscribeUrl: generateUnsubscribeUrl(sub.email),
          }),
        },
      },
    })),
    ConfigurationSetName: Resource.GemhogEmail.configSet,
  }));

  // Respect rate limits - add delay between batches if needed
  await delay(100);
}
```

### Rate Limits

| Status | Daily Limit | Per-Second Rate |
|--------|-------------|-----------------|
| Sandbox | 200 emails | 1 email/sec |
| Production (new) | 50,000 emails | 14 emails/sec |
| Production (established) | Can request increases | Up to 500+ emails/sec |

**Important:** After production access, AWS grants 50,000/day and 14/sec. You can request increases as your reputation builds.

## SST Integration

### Complete Infrastructure Setup

```typescript
// infra/email.ts
import { sns, email, fn } from "./";

// SNS Topics for bounce/complaint handling
export const bounceTopic = new sst.aws.SnsTopic("BounceTopic");
export const complaintTopic = new sst.aws.SnsTopic("ComplaintTopic");

// SES Email Identity with domain verification
export const emailIdentity = new sst.aws.Email("GemhogEmail", {
  sender: "gemhog.com",
  dmarc: "v=DMARC1; p=quarantine; adkim=s; aspf=s;",
  dns: sst.cloudflare.dns(),
  events: [
    { name: "Bounce", types: ["bounce"], topic: bounceTopic.arn },
    { name: "Complaint", types: ["complaint"], topic: complaintTopic.arn },
  ],
});

// Bounce/Complaint handler
export const bounceHandler = new sst.aws.Function("BounceHandler", {
  handler: "packages/functions/src/email/bounce-handler.handler",
  link: [database],
});

bounceTopic.subscribe(bounceHandler.arn);
complaintTopic.subscribe(bounceHandler.arn);

// Export for use in other infrastructure
export const outputs = {
  emailSender: emailIdentity.sender,
  emailConfigSet: emailIdentity.configSet,
};
```

### Linking to API Functions

```typescript
// infra/api.ts
import { emailIdentity } from "./email";

export const api = new sst.aws.Function("Api", {
  handler: "apps/server/src/index.handler",
  link: [
    emailIdentity,
    database,
    // ... other resources
  ],
});
```

### Using in Application Code

```typescript
// apps/server/src/services/email.ts
import { Resource } from "sst";
import { SESv2Client, SendEmailCommand } from "@aws-sdk/client-sesv2";

const client = new SESv2Client({});

export const EmailService = {
  async sendVerification(to: string, token: string) {
    const verificationUrl = `${process.env.APP_URL}/api/verify?token=${token}`;

    await client.send(new SendEmailCommand({
      FromEmailAddress: `Gemhog <noreply@${Resource.GemhogEmail.sender}>`,
      Destination: { ToAddresses: [to] },
      Content: {
        Simple: {
          Subject: { Data: "Confirm your Gemhog subscription" },
          Body: {
            Html: { Data: renderVerificationEmail(verificationUrl) },
            Text: { Data: `Confirm: ${verificationUrl}` },
          },
        },
      },
      ConfigurationSetName: Resource.GemhogEmail.configSet,
    }));
  },
};
```

## Cost Analysis

### SES Pricing (eu-central-1)

| Component | Cost |
|-----------|------|
| Outbound email | $0.10 per 1,000 emails |
| Attachments | $0.12 per GB |
| Free tier (first 12 months) | 3,000 emails/month free |

### Projected Costs for Gemhog

| Scenario | Monthly Emails | Monthly Cost |
|----------|----------------|--------------|
| Launch (Year 1) | < 3,000 | $0 (free tier) |
| Growing (100 subs, weekly newsletter) | ~500 | $0.05 |
| Established (1,000 subs, weekly) | ~4,500 | $0.45 |
| Scaling (10,000 subs, weekly) | ~45,000 | $4.50 |

### Cost Comparison

| Service | 10,000 emails/month |
|---------|---------------------|
| AWS SES | $1.00 |
| Resend | $20.00 (free tier: 3,000/month) |
| SendGrid | $19.95 |
| Mailgun | $15.00 |

**Verdict:** SES is 10-20x cheaper than alternatives at scale.

## Sandbox to Production

### Requirements Checklist

1. **Domain verification** with DKIM, SPF, DMARC configured
2. **Website URL** that explains your business
3. **Bounce/complaint handling** via SNS or event publishing
4. **Use case documentation** (1,000+ words recommended):
   - What type of email (transactional, marketing, both)
   - How recipients opt-in (double opt-in flow)
   - How you handle bounces and complaints
   - Expected daily/weekly volume
   - Projected growth

### Production Access Request

Via AWS Console:
1. SES Console -> Account dashboard -> Request production access
2. Fill in:
   - Mail type: "Marketing" (for newsletter) or both
   - Website URL: `https://gemhog.com`
   - Use case description (detailed)
   - Acknowledgement of sending to consenting recipients only

Via AWS CLI:
```bash
aws sesv2 put-account-details \
  --production-access-enabled \
  --mail-type MARKETING \
  --website-url https://gemhog.com \
  --additional-contact-email-addresses admin@gemhog.com \
  --contact-language EN
```

### Timeline
- Initial response: 24 hours
- Approval: Usually same day if requirements met
- May request additional information

## Recommendations

### For Gemhog V1

1. **Use domain-based identity** (`gemhog.com`) not individual email addresses
   - Enables sending from any `@gemhog.com` address
   - Better for DMARC alignment
   - More professional

2. **Set up these DNS records before requesting production access:**
   - DKIM (3 CNAME records from SES)
   - SPF on custom MAIL FROM subdomain (`mail.gemhog.com`)
   - DMARC starting with `p=none` for monitoring

3. **Implement bounce handling before sending any emails**
   - Required for production access
   - Protects sender reputation from day one

4. **Use configuration sets for all email sends**
   - Enables event tracking (opens, clicks, bounces)
   - Required for SNS event destinations

5. **Start in sandbox for development/testing**
   - Verify your own email addresses
   - Test the complete flow (signup -> verification -> unsubscribe)
   - Request production access when ready to launch

6. **Email addresses to use:**
   - `noreply@gemhog.com` - Transactional (verification)
   - `newsletter@gemhog.com` - Newsletters
   - `hello@gemhog.com` - Reply-to for user contact

### Implementation Order

1. Add SST Email component with domain
2. Configure DNS records (DKIM, SPF, DMARC)
3. Create bounce/complaint handling infrastructure
4. Implement double opt-in endpoints
5. Test in sandbox with verified emails
6. Request production access with detailed use case
7. Launch

## Sources

### Official AWS Documentation
- [Amazon SES Developer Guide](https://docs.aws.amazon.com/ses/latest/dg/)
- [Easy DKIM Setup](https://docs.aws.amazon.com/ses/latest/dg/send-email-authentication-dkim-easy.html)
- [DMARC Authentication](https://docs.aws.amazon.com/ses/latest/dg/send-email-authentication-dmarc.html)
- [Request Production Access](https://docs.aws.amazon.com/ses/latest/dg/request-production-access.html)
- [Event Notifications Setup](https://docs.aws.amazon.com/ses/latest/dg/monitor-sending-activity-using-notifications.html)
- [Using Templates for Personalized Email](https://docs.aws.amazon.com/ses/latest/dg/send-personalized-email-api.html)
- [SESv2Client Reference](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/sesv2/)

### SST Documentation
- [SST Email Component](https://sst.dev/docs/component/aws/email/)
- [Send Emails in AWS with SST](https://sst.dev/docs/start/aws/email/)

### AWS Blogs
- [Email Authentication and DMARC Policy](https://aws.amazon.com/blogs/messaging-and-targeting/email-authenctication-dmarc-policy/)
- [Set Up Notifications for Bounces and Complaints](https://aws.amazon.com/blogs/messaging-and-targeting/amazon-ses-set-up-notifications-for-bounces-and-complaints/)
- [Handling Bounces and Complaints](https://aws.amazon.com/blogs/messaging-and-targeting/handling-bounces-and-complaints/)

### Pricing
- [Amazon SES Pricing](https://aws.amazon.com/ses/pricing/)
